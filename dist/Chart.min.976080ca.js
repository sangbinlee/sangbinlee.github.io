// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles
parcelRequire = (function (modules, cache, entry, globalName) {
  // Save the require from previous bundle to this closure if any
  var previousRequire = typeof parcelRequire === 'function' && parcelRequire;
  var nodeRequire = typeof require === 'function' && require;

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire = typeof parcelRequire === 'function' && parcelRequire;
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error('Cannot find module \'' + name + '\'');
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = cache[name] = new newRequire.Module(name);

      modules[name][0].call(module.exports, localRequire, module, module.exports, this);
    }

    return cache[name].exports;

    function localRequire(x){
      return newRequire(localRequire.resolve(x));
    }

    function resolve(x){
      return modules[name][1][x] || x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function (id, exports) {
    modules[id] = [function (require, module) {
      module.exports = exports;
    }, {}];
  };

  var error;
  for (var i = 0; i < entry.length; i++) {
    try {
      newRequire(entry[i]);
    } catch (e) {
      // Save first error but execute all entries
      if (!error) {
        error = e;
      }
    }
  }

  if (entry.length) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(entry[entry.length - 1]);

    // CommonJS
    if (typeof exports === "object" && typeof module !== "undefined") {
      module.exports = mainExports;

    // RequireJS
    } else if (typeof define === "function" && define.amd) {
     define(function () {
       return mainExports;
     });

    // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }

  // Override the current require with this new one
  parcelRequire = newRequire;

  if (error) {
    // throw error from earlier, _after updating parcelRequire_
    throw error;
  }

  return newRequire;
})({"node_modules/moment/moment.js":[function(require,module,exports) {
var define;
var global = arguments[3];
//! moment.js

;(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    global.moment = factory()
}(this, (function () { 'use strict';

    var hookCallback;

    function hooks () {
        return hookCallback.apply(null, arguments);
    }

    // This is done to register the method called with moment()
    // without creating circular dependencies.
    function setHookCallback (callback) {
        hookCallback = callback;
    }

    function isArray(input) {
        return input instanceof Array || Object.prototype.toString.call(input) === '[object Array]';
    }

    function isObject(input) {
        // IE8 will treat undefined and null as object if it wasn't for
        // input != null
        return input != null && Object.prototype.toString.call(input) === '[object Object]';
    }

    function isObjectEmpty(obj) {
        if (Object.getOwnPropertyNames) {
            return (Object.getOwnPropertyNames(obj).length === 0);
        } else {
            var k;
            for (k in obj) {
                if (obj.hasOwnProperty(k)) {
                    return false;
                }
            }
            return true;
        }
    }

    function isUndefined(input) {
        return input === void 0;
    }

    function isNumber(input) {
        return typeof input === 'number' || Object.prototype.toString.call(input) === '[object Number]';
    }

    function isDate(input) {
        return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';
    }

    function map(arr, fn) {
        var res = [], i;
        for (i = 0; i < arr.length; ++i) {
            res.push(fn(arr[i], i));
        }
        return res;
    }

    function hasOwnProp(a, b) {
        return Object.prototype.hasOwnProperty.call(a, b);
    }

    function extend(a, b) {
        for (var i in b) {
            if (hasOwnProp(b, i)) {
                a[i] = b[i];
            }
        }

        if (hasOwnProp(b, 'toString')) {
            a.toString = b.toString;
        }

        if (hasOwnProp(b, 'valueOf')) {
            a.valueOf = b.valueOf;
        }

        return a;
    }

    function createUTC (input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, true).utc();
    }

    function defaultParsingFlags() {
        // We need to deep clone this object.
        return {
            empty           : false,
            unusedTokens    : [],
            unusedInput     : [],
            overflow        : -2,
            charsLeftOver   : 0,
            nullInput       : false,
            invalidMonth    : null,
            invalidFormat   : false,
            userInvalidated : false,
            iso             : false,
            parsedDateParts : [],
            meridiem        : null,
            rfc2822         : false,
            weekdayMismatch : false
        };
    }

    function getParsingFlags(m) {
        if (m._pf == null) {
            m._pf = defaultParsingFlags();
        }
        return m._pf;
    }

    var some;
    if (Array.prototype.some) {
        some = Array.prototype.some;
    } else {
        some = function (fun) {
            var t = Object(this);
            var len = t.length >>> 0;

            for (var i = 0; i < len; i++) {
                if (i in t && fun.call(this, t[i], i, t)) {
                    return true;
                }
            }

            return false;
        };
    }

    function isValid(m) {
        if (m._isValid == null) {
            var flags = getParsingFlags(m);
            var parsedParts = some.call(flags.parsedDateParts, function (i) {
                return i != null;
            });
            var isNowValid = !isNaN(m._d.getTime()) &&
                flags.overflow < 0 &&
                !flags.empty &&
                !flags.invalidMonth &&
                !flags.invalidWeekday &&
                !flags.weekdayMismatch &&
                !flags.nullInput &&
                !flags.invalidFormat &&
                !flags.userInvalidated &&
                (!flags.meridiem || (flags.meridiem && parsedParts));

            if (m._strict) {
                isNowValid = isNowValid &&
                    flags.charsLeftOver === 0 &&
                    flags.unusedTokens.length === 0 &&
                    flags.bigHour === undefined;
            }

            if (Object.isFrozen == null || !Object.isFrozen(m)) {
                m._isValid = isNowValid;
            }
            else {
                return isNowValid;
            }
        }
        return m._isValid;
    }

    function createInvalid (flags) {
        var m = createUTC(NaN);
        if (flags != null) {
            extend(getParsingFlags(m), flags);
        }
        else {
            getParsingFlags(m).userInvalidated = true;
        }

        return m;
    }

    // Plugins that add properties should also add the key here (null value),
    // so we can properly clone ourselves.
    var momentProperties = hooks.momentProperties = [];

    function copyConfig(to, from) {
        var i, prop, val;

        if (!isUndefined(from._isAMomentObject)) {
            to._isAMomentObject = from._isAMomentObject;
        }
        if (!isUndefined(from._i)) {
            to._i = from._i;
        }
        if (!isUndefined(from._f)) {
            to._f = from._f;
        }
        if (!isUndefined(from._l)) {
            to._l = from._l;
        }
        if (!isUndefined(from._strict)) {
            to._strict = from._strict;
        }
        if (!isUndefined(from._tzm)) {
            to._tzm = from._tzm;
        }
        if (!isUndefined(from._isUTC)) {
            to._isUTC = from._isUTC;
        }
        if (!isUndefined(from._offset)) {
            to._offset = from._offset;
        }
        if (!isUndefined(from._pf)) {
            to._pf = getParsingFlags(from);
        }
        if (!isUndefined(from._locale)) {
            to._locale = from._locale;
        }

        if (momentProperties.length > 0) {
            for (i = 0; i < momentProperties.length; i++) {
                prop = momentProperties[i];
                val = from[prop];
                if (!isUndefined(val)) {
                    to[prop] = val;
                }
            }
        }

        return to;
    }

    var updateInProgress = false;

    // Moment prototype object
    function Moment(config) {
        copyConfig(this, config);
        this._d = new Date(config._d != null ? config._d.getTime() : NaN);
        if (!this.isValid()) {
            this._d = new Date(NaN);
        }
        // Prevent infinite loop in case updateOffset creates new moment
        // objects.
        if (updateInProgress === false) {
            updateInProgress = true;
            hooks.updateOffset(this);
            updateInProgress = false;
        }
    }

    function isMoment (obj) {
        return obj instanceof Moment || (obj != null && obj._isAMomentObject != null);
    }

    function absFloor (number) {
        if (number < 0) {
            // -0 -> 0
            return Math.ceil(number) || 0;
        } else {
            return Math.floor(number);
        }
    }

    function toInt(argumentForCoercion) {
        var coercedNumber = +argumentForCoercion,
            value = 0;

        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
            value = absFloor(coercedNumber);
        }

        return value;
    }

    // compare two arrays, return the number of differences
    function compareArrays(array1, array2, dontConvert) {
        var len = Math.min(array1.length, array2.length),
            lengthDiff = Math.abs(array1.length - array2.length),
            diffs = 0,
            i;
        for (i = 0; i < len; i++) {
            if ((dontConvert && array1[i] !== array2[i]) ||
                (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
                diffs++;
            }
        }
        return diffs + lengthDiff;
    }

    function warn(msg) {
        if (hooks.suppressDeprecationWarnings === false &&
                (typeof console !==  'undefined') && console.warn) {
            console.warn('Deprecation warning: ' + msg);
        }
    }

    function deprecate(msg, fn) {
        var firstTime = true;

        return extend(function () {
            if (hooks.deprecationHandler != null) {
                hooks.deprecationHandler(null, msg);
            }
            if (firstTime) {
                var args = [];
                var arg;
                for (var i = 0; i < arguments.length; i++) {
                    arg = '';
                    if (typeof arguments[i] === 'object') {
                        arg += '\n[' + i + '] ';
                        for (var key in arguments[0]) {
                            arg += key + ': ' + arguments[0][key] + ', ';
                        }
                        arg = arg.slice(0, -2); // Remove trailing comma and space
                    } else {
                        arg = arguments[i];
                    }
                    args.push(arg);
                }
                warn(msg + '\nArguments: ' + Array.prototype.slice.call(args).join('') + '\n' + (new Error()).stack);
                firstTime = false;
            }
            return fn.apply(this, arguments);
        }, fn);
    }

    var deprecations = {};

    function deprecateSimple(name, msg) {
        if (hooks.deprecationHandler != null) {
            hooks.deprecationHandler(name, msg);
        }
        if (!deprecations[name]) {
            warn(msg);
            deprecations[name] = true;
        }
    }

    hooks.suppressDeprecationWarnings = false;
    hooks.deprecationHandler = null;

    function isFunction(input) {
        return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
    }

    function set (config) {
        var prop, i;
        for (i in config) {
            prop = config[i];
            if (isFunction(prop)) {
                this[i] = prop;
            } else {
                this['_' + i] = prop;
            }
        }
        this._config = config;
        // Lenient ordinal parsing accepts just a number in addition to
        // number + (possibly) stuff coming from _dayOfMonthOrdinalParse.
        // TODO: Remove "ordinalParse" fallback in next major release.
        this._dayOfMonthOrdinalParseLenient = new RegExp(
            (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) +
                '|' + (/\d{1,2}/).source);
    }

    function mergeConfigs(parentConfig, childConfig) {
        var res = extend({}, parentConfig), prop;
        for (prop in childConfig) {
            if (hasOwnProp(childConfig, prop)) {
                if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
                    res[prop] = {};
                    extend(res[prop], parentConfig[prop]);
                    extend(res[prop], childConfig[prop]);
                } else if (childConfig[prop] != null) {
                    res[prop] = childConfig[prop];
                } else {
                    delete res[prop];
                }
            }
        }
        for (prop in parentConfig) {
            if (hasOwnProp(parentConfig, prop) &&
                    !hasOwnProp(childConfig, prop) &&
                    isObject(parentConfig[prop])) {
                // make sure changes to properties don't modify parent config
                res[prop] = extend({}, res[prop]);
            }
        }
        return res;
    }

    function Locale(config) {
        if (config != null) {
            this.set(config);
        }
    }

    var keys;

    if (Object.keys) {
        keys = Object.keys;
    } else {
        keys = function (obj) {
            var i, res = [];
            for (i in obj) {
                if (hasOwnProp(obj, i)) {
                    res.push(i);
                }
            }
            return res;
        };
    }

    var defaultCalendar = {
        sameDay : '[Today at] LT',
        nextDay : '[Tomorrow at] LT',
        nextWeek : 'dddd [at] LT',
        lastDay : '[Yesterday at] LT',
        lastWeek : '[Last] dddd [at] LT',
        sameElse : 'L'
    };

    function calendar (key, mom, now) {
        var output = this._calendar[key] || this._calendar['sameElse'];
        return isFunction(output) ? output.call(mom, now) : output;
    }

    var defaultLongDateFormat = {
        LTS  : 'h:mm:ss A',
        LT   : 'h:mm A',
        L    : 'MM/DD/YYYY',
        LL   : 'MMMM D, YYYY',
        LLL  : 'MMMM D, YYYY h:mm A',
        LLLL : 'dddd, MMMM D, YYYY h:mm A'
    };

    function longDateFormat (key) {
        var format = this._longDateFormat[key],
            formatUpper = this._longDateFormat[key.toUpperCase()];

        if (format || !formatUpper) {
            return format;
        }

        this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function (val) {
            return val.slice(1);
        });

        return this._longDateFormat[key];
    }

    var defaultInvalidDate = 'Invalid date';

    function invalidDate () {
        return this._invalidDate;
    }

    var defaultOrdinal = '%d';
    var defaultDayOfMonthOrdinalParse = /\d{1,2}/;

    function ordinal (number) {
        return this._ordinal.replace('%d', number);
    }

    var defaultRelativeTime = {
        future : 'in %s',
        past   : '%s ago',
        s  : 'a few seconds',
        ss : '%d seconds',
        m  : 'a minute',
        mm : '%d minutes',
        h  : 'an hour',
        hh : '%d hours',
        d  : 'a day',
        dd : '%d days',
        M  : 'a month',
        MM : '%d months',
        y  : 'a year',
        yy : '%d years'
    };

    function relativeTime (number, withoutSuffix, string, isFuture) {
        var output = this._relativeTime[string];
        return (isFunction(output)) ?
            output(number, withoutSuffix, string, isFuture) :
            output.replace(/%d/i, number);
    }

    function pastFuture (diff, output) {
        var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
        return isFunction(format) ? format(output) : format.replace(/%s/i, output);
    }

    var aliases = {};

    function addUnitAlias (unit, shorthand) {
        var lowerCase = unit.toLowerCase();
        aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
    }

    function normalizeUnits(units) {
        return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;
    }

    function normalizeObjectUnits(inputObject) {
        var normalizedInput = {},
            normalizedProp,
            prop;

        for (prop in inputObject) {
            if (hasOwnProp(inputObject, prop)) {
                normalizedProp = normalizeUnits(prop);
                if (normalizedProp) {
                    normalizedInput[normalizedProp] = inputObject[prop];
                }
            }
        }

        return normalizedInput;
    }

    var priorities = {};

    function addUnitPriority(unit, priority) {
        priorities[unit] = priority;
    }

    function getPrioritizedUnits(unitsObj) {
        var units = [];
        for (var u in unitsObj) {
            units.push({unit: u, priority: priorities[u]});
        }
        units.sort(function (a, b) {
            return a.priority - b.priority;
        });
        return units;
    }

    function zeroFill(number, targetLength, forceSign) {
        var absNumber = '' + Math.abs(number),
            zerosToFill = targetLength - absNumber.length,
            sign = number >= 0;
        return (sign ? (forceSign ? '+' : '') : '-') +
            Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
    }

    var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;

    var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;

    var formatFunctions = {};

    var formatTokenFunctions = {};

    // token:    'M'
    // padded:   ['MM', 2]
    // ordinal:  'Mo'
    // callback: function () { this.month() + 1 }
    function addFormatToken (token, padded, ordinal, callback) {
        var func = callback;
        if (typeof callback === 'string') {
            func = function () {
                return this[callback]();
            };
        }
        if (token) {
            formatTokenFunctions[token] = func;
        }
        if (padded) {
            formatTokenFunctions[padded[0]] = function () {
                return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
            };
        }
        if (ordinal) {
            formatTokenFunctions[ordinal] = function () {
                return this.localeData().ordinal(func.apply(this, arguments), token);
            };
        }
    }

    function removeFormattingTokens(input) {
        if (input.match(/\[[\s\S]/)) {
            return input.replace(/^\[|\]$/g, '');
        }
        return input.replace(/\\/g, '');
    }

    function makeFormatFunction(format) {
        var array = format.match(formattingTokens), i, length;

        for (i = 0, length = array.length; i < length; i++) {
            if (formatTokenFunctions[array[i]]) {
                array[i] = formatTokenFunctions[array[i]];
            } else {
                array[i] = removeFormattingTokens(array[i]);
            }
        }

        return function (mom) {
            var output = '', i;
            for (i = 0; i < length; i++) {
                output += isFunction(array[i]) ? array[i].call(mom, format) : array[i];
            }
            return output;
        };
    }

    // format date using native date object
    function formatMoment(m, format) {
        if (!m.isValid()) {
            return m.localeData().invalidDate();
        }

        format = expandFormat(format, m.localeData());
        formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);

        return formatFunctions[format](m);
    }

    function expandFormat(format, locale) {
        var i = 5;

        function replaceLongDateFormatTokens(input) {
            return locale.longDateFormat(input) || input;
        }

        localFormattingTokens.lastIndex = 0;
        while (i >= 0 && localFormattingTokens.test(format)) {
            format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
            localFormattingTokens.lastIndex = 0;
            i -= 1;
        }

        return format;
    }

    var match1         = /\d/;            //       0 - 9
    var match2         = /\d\d/;          //      00 - 99
    var match3         = /\d{3}/;         //     000 - 999
    var match4         = /\d{4}/;         //    0000 - 9999
    var match6         = /[+-]?\d{6}/;    // -999999 - 999999
    var match1to2      = /\d\d?/;         //       0 - 99
    var match3to4      = /\d\d\d\d?/;     //     999 - 9999
    var match5to6      = /\d\d\d\d\d\d?/; //   99999 - 999999
    var match1to3      = /\d{1,3}/;       //       0 - 999
    var match1to4      = /\d{1,4}/;       //       0 - 9999
    var match1to6      = /[+-]?\d{1,6}/;  // -999999 - 999999

    var matchUnsigned  = /\d+/;           //       0 - inf
    var matchSigned    = /[+-]?\d+/;      //    -inf - inf

    var matchOffset    = /Z|[+-]\d\d:?\d\d/gi; // +00:00 -00:00 +0000 -0000 or Z
    var matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi; // +00 -00 +00:00 -00:00 +0000 -0000 or Z

    var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/; // 123456789 123456789.123

    // any word (or two) characters or numbers including two/three word month in arabic.
    // includes scottish gaelic two word and hyphenated months
    var matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i;

    var regexes = {};

    function addRegexToken (token, regex, strictRegex) {
        regexes[token] = isFunction(regex) ? regex : function (isStrict, localeData) {
            return (isStrict && strictRegex) ? strictRegex : regex;
        };
    }

    function getParseRegexForToken (token, config) {
        if (!hasOwnProp(regexes, token)) {
            return new RegExp(unescapeFormat(token));
        }

        return regexes[token](config._strict, config._locale);
    }

    // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
    function unescapeFormat(s) {
        return regexEscape(s.replace('\\', '').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
            return p1 || p2 || p3 || p4;
        }));
    }

    function regexEscape(s) {
        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
    }

    var tokens = {};

    function addParseToken (token, callback) {
        var i, func = callback;
        if (typeof token === 'string') {
            token = [token];
        }
        if (isNumber(callback)) {
            func = function (input, array) {
                array[callback] = toInt(input);
            };
        }
        for (i = 0; i < token.length; i++) {
            tokens[token[i]] = func;
        }
    }

    function addWeekParseToken (token, callback) {
        addParseToken(token, function (input, array, config, token) {
            config._w = config._w || {};
            callback(input, config._w, config, token);
        });
    }

    function addTimeToArrayFromToken(token, input, config) {
        if (input != null && hasOwnProp(tokens, token)) {
            tokens[token](input, config._a, config, token);
        }
    }

    var YEAR = 0;
    var MONTH = 1;
    var DATE = 2;
    var HOUR = 3;
    var MINUTE = 4;
    var SECOND = 5;
    var MILLISECOND = 6;
    var WEEK = 7;
    var WEEKDAY = 8;

    // FORMATTING

    addFormatToken('Y', 0, 0, function () {
        var y = this.year();
        return y <= 9999 ? '' + y : '+' + y;
    });

    addFormatToken(0, ['YY', 2], 0, function () {
        return this.year() % 100;
    });

    addFormatToken(0, ['YYYY',   4],       0, 'year');
    addFormatToken(0, ['YYYYY',  5],       0, 'year');
    addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');

    // ALIASES

    addUnitAlias('year', 'y');

    // PRIORITIES

    addUnitPriority('year', 1);

    // PARSING

    addRegexToken('Y',      matchSigned);
    addRegexToken('YY',     match1to2, match2);
    addRegexToken('YYYY',   match1to4, match4);
    addRegexToken('YYYYY',  match1to6, match6);
    addRegexToken('YYYYYY', match1to6, match6);

    addParseToken(['YYYYY', 'YYYYYY'], YEAR);
    addParseToken('YYYY', function (input, array) {
        array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
    });
    addParseToken('YY', function (input, array) {
        array[YEAR] = hooks.parseTwoDigitYear(input);
    });
    addParseToken('Y', function (input, array) {
        array[YEAR] = parseInt(input, 10);
    });

    // HELPERS

    function daysInYear(year) {
        return isLeapYear(year) ? 366 : 365;
    }

    function isLeapYear(year) {
        return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
    }

    // HOOKS

    hooks.parseTwoDigitYear = function (input) {
        return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
    };

    // MOMENTS

    var getSetYear = makeGetSet('FullYear', true);

    function getIsLeapYear () {
        return isLeapYear(this.year());
    }

    function makeGetSet (unit, keepTime) {
        return function (value) {
            if (value != null) {
                set$1(this, unit, value);
                hooks.updateOffset(this, keepTime);
                return this;
            } else {
                return get(this, unit);
            }
        };
    }

    function get (mom, unit) {
        return mom.isValid() ?
            mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]() : NaN;
    }

    function set$1 (mom, unit, value) {
        if (mom.isValid() && !isNaN(value)) {
            if (unit === 'FullYear' && isLeapYear(mom.year()) && mom.month() === 1 && mom.date() === 29) {
                mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value, mom.month(), daysInMonth(value, mom.month()));
            }
            else {
                mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
            }
        }
    }

    // MOMENTS

    function stringGet (units) {
        units = normalizeUnits(units);
        if (isFunction(this[units])) {
            return this[units]();
        }
        return this;
    }


    function stringSet (units, value) {
        if (typeof units === 'object') {
            units = normalizeObjectUnits(units);
            var prioritized = getPrioritizedUnits(units);
            for (var i = 0; i < prioritized.length; i++) {
                this[prioritized[i].unit](units[prioritized[i].unit]);
            }
        } else {
            units = normalizeUnits(units);
            if (isFunction(this[units])) {
                return this[units](value);
            }
        }
        return this;
    }

    function mod(n, x) {
        return ((n % x) + x) % x;
    }

    var indexOf;

    if (Array.prototype.indexOf) {
        indexOf = Array.prototype.indexOf;
    } else {
        indexOf = function (o) {
            // I know
            var i;
            for (i = 0; i < this.length; ++i) {
                if (this[i] === o) {
                    return i;
                }
            }
            return -1;
        };
    }

    function daysInMonth(year, month) {
        if (isNaN(year) || isNaN(month)) {
            return NaN;
        }
        var modMonth = mod(month, 12);
        year += (month - modMonth) / 12;
        return modMonth === 1 ? (isLeapYear(year) ? 29 : 28) : (31 - modMonth % 7 % 2);
    }

    // FORMATTING

    addFormatToken('M', ['MM', 2], 'Mo', function () {
        return this.month() + 1;
    });

    addFormatToken('MMM', 0, 0, function (format) {
        return this.localeData().monthsShort(this, format);
    });

    addFormatToken('MMMM', 0, 0, function (format) {
        return this.localeData().months(this, format);
    });

    // ALIASES

    addUnitAlias('month', 'M');

    // PRIORITY

    addUnitPriority('month', 8);

    // PARSING

    addRegexToken('M',    match1to2);
    addRegexToken('MM',   match1to2, match2);
    addRegexToken('MMM',  function (isStrict, locale) {
        return locale.monthsShortRegex(isStrict);
    });
    addRegexToken('MMMM', function (isStrict, locale) {
        return locale.monthsRegex(isStrict);
    });

    addParseToken(['M', 'MM'], function (input, array) {
        array[MONTH] = toInt(input) - 1;
    });

    addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
        var month = config._locale.monthsParse(input, token, config._strict);
        // if we didn't find a month name, mark the date as invalid.
        if (month != null) {
            array[MONTH] = month;
        } else {
            getParsingFlags(config).invalidMonth = input;
        }
    });

    // LOCALES

    var MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/;
    var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');
    function localeMonths (m, format) {
        if (!m) {
            return isArray(this._months) ? this._months :
                this._months['standalone'];
        }
        return isArray(this._months) ? this._months[m.month()] :
            this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? 'format' : 'standalone'][m.month()];
    }

    var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');
    function localeMonthsShort (m, format) {
        if (!m) {
            return isArray(this._monthsShort) ? this._monthsShort :
                this._monthsShort['standalone'];
        }
        return isArray(this._monthsShort) ? this._monthsShort[m.month()] :
            this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];
    }

    function handleStrictParse(monthName, format, strict) {
        var i, ii, mom, llc = monthName.toLocaleLowerCase();
        if (!this._monthsParse) {
            // this is not used
            this._monthsParse = [];
            this._longMonthsParse = [];
            this._shortMonthsParse = [];
            for (i = 0; i < 12; ++i) {
                mom = createUTC([2000, i]);
                this._shortMonthsParse[i] = this.monthsShort(mom, '').toLocaleLowerCase();
                this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();
            }
        }

        if (strict) {
            if (format === 'MMM') {
                ii = indexOf.call(this._shortMonthsParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._longMonthsParse, llc);
                return ii !== -1 ? ii : null;
            }
        } else {
            if (format === 'MMM') {
                ii = indexOf.call(this._shortMonthsParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._longMonthsParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._longMonthsParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._shortMonthsParse, llc);
                return ii !== -1 ? ii : null;
            }
        }
    }

    function localeMonthsParse (monthName, format, strict) {
        var i, mom, regex;

        if (this._monthsParseExact) {
            return handleStrictParse.call(this, monthName, format, strict);
        }

        if (!this._monthsParse) {
            this._monthsParse = [];
            this._longMonthsParse = [];
            this._shortMonthsParse = [];
        }

        // TODO: add sorting
        // Sorting makes sure if one month (or abbr) is a prefix of another
        // see sorting in computeMonthsParse
        for (i = 0; i < 12; i++) {
            // make the regex if we don't have it already
            mom = createUTC([2000, i]);
            if (strict && !this._longMonthsParse[i]) {
                this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
                this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
            }
            if (!strict && !this._monthsParse[i]) {
                regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
                this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
            }
            // test the regex
            if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
                return i;
            } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
                return i;
            } else if (!strict && this._monthsParse[i].test(monthName)) {
                return i;
            }
        }
    }

    // MOMENTS

    function setMonth (mom, value) {
        var dayOfMonth;

        if (!mom.isValid()) {
            // No op
            return mom;
        }

        if (typeof value === 'string') {
            if (/^\d+$/.test(value)) {
                value = toInt(value);
            } else {
                value = mom.localeData().monthsParse(value);
                // TODO: Another silent failure?
                if (!isNumber(value)) {
                    return mom;
                }
            }
        }

        dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
        mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
        return mom;
    }

    function getSetMonth (value) {
        if (value != null) {
            setMonth(this, value);
            hooks.updateOffset(this, true);
            return this;
        } else {
            return get(this, 'Month');
        }
    }

    function getDaysInMonth () {
        return daysInMonth(this.year(), this.month());
    }

    var defaultMonthsShortRegex = matchWord;
    function monthsShortRegex (isStrict) {
        if (this._monthsParseExact) {
            if (!hasOwnProp(this, '_monthsRegex')) {
                computeMonthsParse.call(this);
            }
            if (isStrict) {
                return this._monthsShortStrictRegex;
            } else {
                return this._monthsShortRegex;
            }
        } else {
            if (!hasOwnProp(this, '_monthsShortRegex')) {
                this._monthsShortRegex = defaultMonthsShortRegex;
            }
            return this._monthsShortStrictRegex && isStrict ?
                this._monthsShortStrictRegex : this._monthsShortRegex;
        }
    }

    var defaultMonthsRegex = matchWord;
    function monthsRegex (isStrict) {
        if (this._monthsParseExact) {
            if (!hasOwnProp(this, '_monthsRegex')) {
                computeMonthsParse.call(this);
            }
            if (isStrict) {
                return this._monthsStrictRegex;
            } else {
                return this._monthsRegex;
            }
        } else {
            if (!hasOwnProp(this, '_monthsRegex')) {
                this._monthsRegex = defaultMonthsRegex;
            }
            return this._monthsStrictRegex && isStrict ?
                this._monthsStrictRegex : this._monthsRegex;
        }
    }

    function computeMonthsParse () {
        function cmpLenRev(a, b) {
            return b.length - a.length;
        }

        var shortPieces = [], longPieces = [], mixedPieces = [],
            i, mom;
        for (i = 0; i < 12; i++) {
            // make the regex if we don't have it already
            mom = createUTC([2000, i]);
            shortPieces.push(this.monthsShort(mom, ''));
            longPieces.push(this.months(mom, ''));
            mixedPieces.push(this.months(mom, ''));
            mixedPieces.push(this.monthsShort(mom, ''));
        }
        // Sorting makes sure if one month (or abbr) is a prefix of another it
        // will match the longer piece.
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);
        for (i = 0; i < 12; i++) {
            shortPieces[i] = regexEscape(shortPieces[i]);
            longPieces[i] = regexEscape(longPieces[i]);
        }
        for (i = 0; i < 24; i++) {
            mixedPieces[i] = regexEscape(mixedPieces[i]);
        }

        this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
        this._monthsShortRegex = this._monthsRegex;
        this._monthsStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
        this._monthsShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
    }

    function createDate (y, m, d, h, M, s, ms) {
        // can't just apply() to create a date:
        // https://stackoverflow.com/q/181348
        var date;
        // the date constructor remaps years 0-99 to 1900-1999
        if (y < 100 && y >= 0) {
            // preserve leap years using a full 400 year cycle, then reset
            date = new Date(y + 400, m, d, h, M, s, ms);
            if (isFinite(date.getFullYear())) {
                date.setFullYear(y);
            }
        } else {
            date = new Date(y, m, d, h, M, s, ms);
        }

        return date;
    }

    function createUTCDate (y) {
        var date;
        // the Date.UTC function remaps years 0-99 to 1900-1999
        if (y < 100 && y >= 0) {
            var args = Array.prototype.slice.call(arguments);
            // preserve leap years using a full 400 year cycle, then reset
            args[0] = y + 400;
            date = new Date(Date.UTC.apply(null, args));
            if (isFinite(date.getUTCFullYear())) {
                date.setUTCFullYear(y);
            }
        } else {
            date = new Date(Date.UTC.apply(null, arguments));
        }

        return date;
    }

    // start-of-first-week - start-of-year
    function firstWeekOffset(year, dow, doy) {
        var // first-week day -- which january is always in the first week (4 for iso, 1 for other)
            fwd = 7 + dow - doy,
            // first-week day local weekday -- which local weekday is fwd
            fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;

        return -fwdlw + fwd - 1;
    }

    // https://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
    function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
        var localWeekday = (7 + weekday - dow) % 7,
            weekOffset = firstWeekOffset(year, dow, doy),
            dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
            resYear, resDayOfYear;

        if (dayOfYear <= 0) {
            resYear = year - 1;
            resDayOfYear = daysInYear(resYear) + dayOfYear;
        } else if (dayOfYear > daysInYear(year)) {
            resYear = year + 1;
            resDayOfYear = dayOfYear - daysInYear(year);
        } else {
            resYear = year;
            resDayOfYear = dayOfYear;
        }

        return {
            year: resYear,
            dayOfYear: resDayOfYear
        };
    }

    function weekOfYear(mom, dow, doy) {
        var weekOffset = firstWeekOffset(mom.year(), dow, doy),
            week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
            resWeek, resYear;

        if (week < 1) {
            resYear = mom.year() - 1;
            resWeek = week + weeksInYear(resYear, dow, doy);
        } else if (week > weeksInYear(mom.year(), dow, doy)) {
            resWeek = week - weeksInYear(mom.year(), dow, doy);
            resYear = mom.year() + 1;
        } else {
            resYear = mom.year();
            resWeek = week;
        }

        return {
            week: resWeek,
            year: resYear
        };
    }

    function weeksInYear(year, dow, doy) {
        var weekOffset = firstWeekOffset(year, dow, doy),
            weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
        return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
    }

    // FORMATTING

    addFormatToken('w', ['ww', 2], 'wo', 'week');
    addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');

    // ALIASES

    addUnitAlias('week', 'w');
    addUnitAlias('isoWeek', 'W');

    // PRIORITIES

    addUnitPriority('week', 5);
    addUnitPriority('isoWeek', 5);

    // PARSING

    addRegexToken('w',  match1to2);
    addRegexToken('ww', match1to2, match2);
    addRegexToken('W',  match1to2);
    addRegexToken('WW', match1to2, match2);

    addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {
        week[token.substr(0, 1)] = toInt(input);
    });

    // HELPERS

    // LOCALES

    function localeWeek (mom) {
        return weekOfYear(mom, this._week.dow, this._week.doy).week;
    }

    var defaultLocaleWeek = {
        dow : 0, // Sunday is the first day of the week.
        doy : 6  // The week that contains Jan 6th is the first week of the year.
    };

    function localeFirstDayOfWeek () {
        return this._week.dow;
    }

    function localeFirstDayOfYear () {
        return this._week.doy;
    }

    // MOMENTS

    function getSetWeek (input) {
        var week = this.localeData().week(this);
        return input == null ? week : this.add((input - week) * 7, 'd');
    }

    function getSetISOWeek (input) {
        var week = weekOfYear(this, 1, 4).week;
        return input == null ? week : this.add((input - week) * 7, 'd');
    }

    // FORMATTING

    addFormatToken('d', 0, 'do', 'day');

    addFormatToken('dd', 0, 0, function (format) {
        return this.localeData().weekdaysMin(this, format);
    });

    addFormatToken('ddd', 0, 0, function (format) {
        return this.localeData().weekdaysShort(this, format);
    });

    addFormatToken('dddd', 0, 0, function (format) {
        return this.localeData().weekdays(this, format);
    });

    addFormatToken('e', 0, 0, 'weekday');
    addFormatToken('E', 0, 0, 'isoWeekday');

    // ALIASES

    addUnitAlias('day', 'd');
    addUnitAlias('weekday', 'e');
    addUnitAlias('isoWeekday', 'E');

    // PRIORITY
    addUnitPriority('day', 11);
    addUnitPriority('weekday', 11);
    addUnitPriority('isoWeekday', 11);

    // PARSING

    addRegexToken('d',    match1to2);
    addRegexToken('e',    match1to2);
    addRegexToken('E',    match1to2);
    addRegexToken('dd',   function (isStrict, locale) {
        return locale.weekdaysMinRegex(isStrict);
    });
    addRegexToken('ddd',   function (isStrict, locale) {
        return locale.weekdaysShortRegex(isStrict);
    });
    addRegexToken('dddd',   function (isStrict, locale) {
        return locale.weekdaysRegex(isStrict);
    });

    addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {
        var weekday = config._locale.weekdaysParse(input, token, config._strict);
        // if we didn't get a weekday name, mark the date as invalid
        if (weekday != null) {
            week.d = weekday;
        } else {
            getParsingFlags(config).invalidWeekday = input;
        }
    });

    addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
        week[token] = toInt(input);
    });

    // HELPERS

    function parseWeekday(input, locale) {
        if (typeof input !== 'string') {
            return input;
        }

        if (!isNaN(input)) {
            return parseInt(input, 10);
        }

        input = locale.weekdaysParse(input);
        if (typeof input === 'number') {
            return input;
        }

        return null;
    }

    function parseIsoWeekday(input, locale) {
        if (typeof input === 'string') {
            return locale.weekdaysParse(input) % 7 || 7;
        }
        return isNaN(input) ? null : input;
    }

    // LOCALES
    function shiftWeekdays (ws, n) {
        return ws.slice(n, 7).concat(ws.slice(0, n));
    }

    var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');
    function localeWeekdays (m, format) {
        var weekdays = isArray(this._weekdays) ? this._weekdays :
            this._weekdays[(m && m !== true && this._weekdays.isFormat.test(format)) ? 'format' : 'standalone'];
        return (m === true) ? shiftWeekdays(weekdays, this._week.dow)
            : (m) ? weekdays[m.day()] : weekdays;
    }

    var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');
    function localeWeekdaysShort (m) {
        return (m === true) ? shiftWeekdays(this._weekdaysShort, this._week.dow)
            : (m) ? this._weekdaysShort[m.day()] : this._weekdaysShort;
    }

    var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');
    function localeWeekdaysMin (m) {
        return (m === true) ? shiftWeekdays(this._weekdaysMin, this._week.dow)
            : (m) ? this._weekdaysMin[m.day()] : this._weekdaysMin;
    }

    function handleStrictParse$1(weekdayName, format, strict) {
        var i, ii, mom, llc = weekdayName.toLocaleLowerCase();
        if (!this._weekdaysParse) {
            this._weekdaysParse = [];
            this._shortWeekdaysParse = [];
            this._minWeekdaysParse = [];

            for (i = 0; i < 7; ++i) {
                mom = createUTC([2000, 1]).day(i);
                this._minWeekdaysParse[i] = this.weekdaysMin(mom, '').toLocaleLowerCase();
                this._shortWeekdaysParse[i] = this.weekdaysShort(mom, '').toLocaleLowerCase();
                this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();
            }
        }

        if (strict) {
            if (format === 'dddd') {
                ii = indexOf.call(this._weekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else if (format === 'ddd') {
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            }
        } else {
            if (format === 'dddd') {
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else if (format === 'ddd') {
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._minWeekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            }
        }
    }

    function localeWeekdaysParse (weekdayName, format, strict) {
        var i, mom, regex;

        if (this._weekdaysParseExact) {
            return handleStrictParse$1.call(this, weekdayName, format, strict);
        }

        if (!this._weekdaysParse) {
            this._weekdaysParse = [];
            this._minWeekdaysParse = [];
            this._shortWeekdaysParse = [];
            this._fullWeekdaysParse = [];
        }

        for (i = 0; i < 7; i++) {
            // make the regex if we don't have it already

            mom = createUTC([2000, 1]).day(i);
            if (strict && !this._fullWeekdaysParse[i]) {
                this._fullWeekdaysParse[i] = new RegExp('^' + this.weekdays(mom, '').replace('.', '\\.?') + '$', 'i');
                this._shortWeekdaysParse[i] = new RegExp('^' + this.weekdaysShort(mom, '').replace('.', '\\.?') + '$', 'i');
                this._minWeekdaysParse[i] = new RegExp('^' + this.weekdaysMin(mom, '').replace('.', '\\.?') + '$', 'i');
            }
            if (!this._weekdaysParse[i]) {
                regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
                this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
            }
            // test the regex
            if (strict && format === 'dddd' && this._fullWeekdaysParse[i].test(weekdayName)) {
                return i;
            } else if (strict && format === 'ddd' && this._shortWeekdaysParse[i].test(weekdayName)) {
                return i;
            } else if (strict && format === 'dd' && this._minWeekdaysParse[i].test(weekdayName)) {
                return i;
            } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
                return i;
            }
        }
    }

    // MOMENTS

    function getSetDayOfWeek (input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
        if (input != null) {
            input = parseWeekday(input, this.localeData());
            return this.add(input - day, 'd');
        } else {
            return day;
        }
    }

    function getSetLocaleDayOfWeek (input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
        return input == null ? weekday : this.add(input - weekday, 'd');
    }

    function getSetISODayOfWeek (input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }

        // behaves the same as moment#day except
        // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
        // as a setter, sunday should belong to the previous week.

        if (input != null) {
            var weekday = parseIsoWeekday(input, this.localeData());
            return this.day(this.day() % 7 ? weekday : weekday - 7);
        } else {
            return this.day() || 7;
        }
    }

    var defaultWeekdaysRegex = matchWord;
    function weekdaysRegex (isStrict) {
        if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                computeWeekdaysParse.call(this);
            }
            if (isStrict) {
                return this._weekdaysStrictRegex;
            } else {
                return this._weekdaysRegex;
            }
        } else {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                this._weekdaysRegex = defaultWeekdaysRegex;
            }
            return this._weekdaysStrictRegex && isStrict ?
                this._weekdaysStrictRegex : this._weekdaysRegex;
        }
    }

    var defaultWeekdaysShortRegex = matchWord;
    function weekdaysShortRegex (isStrict) {
        if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                computeWeekdaysParse.call(this);
            }
            if (isStrict) {
                return this._weekdaysShortStrictRegex;
            } else {
                return this._weekdaysShortRegex;
            }
        } else {
            if (!hasOwnProp(this, '_weekdaysShortRegex')) {
                this._weekdaysShortRegex = defaultWeekdaysShortRegex;
            }
            return this._weekdaysShortStrictRegex && isStrict ?
                this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
        }
    }

    var defaultWeekdaysMinRegex = matchWord;
    function weekdaysMinRegex (isStrict) {
        if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                computeWeekdaysParse.call(this);
            }
            if (isStrict) {
                return this._weekdaysMinStrictRegex;
            } else {
                return this._weekdaysMinRegex;
            }
        } else {
            if (!hasOwnProp(this, '_weekdaysMinRegex')) {
                this._weekdaysMinRegex = defaultWeekdaysMinRegex;
            }
            return this._weekdaysMinStrictRegex && isStrict ?
                this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
        }
    }


    function computeWeekdaysParse () {
        function cmpLenRev(a, b) {
            return b.length - a.length;
        }

        var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [],
            i, mom, minp, shortp, longp;
        for (i = 0; i < 7; i++) {
            // make the regex if we don't have it already
            mom = createUTC([2000, 1]).day(i);
            minp = this.weekdaysMin(mom, '');
            shortp = this.weekdaysShort(mom, '');
            longp = this.weekdays(mom, '');
            minPieces.push(minp);
            shortPieces.push(shortp);
            longPieces.push(longp);
            mixedPieces.push(minp);
            mixedPieces.push(shortp);
            mixedPieces.push(longp);
        }
        // Sorting makes sure if one weekday (or abbr) is a prefix of another it
        // will match the longer piece.
        minPieces.sort(cmpLenRev);
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);
        for (i = 0; i < 7; i++) {
            shortPieces[i] = regexEscape(shortPieces[i]);
            longPieces[i] = regexEscape(longPieces[i]);
            mixedPieces[i] = regexEscape(mixedPieces[i]);
        }

        this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
        this._weekdaysShortRegex = this._weekdaysRegex;
        this._weekdaysMinRegex = this._weekdaysRegex;

        this._weekdaysStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
        this._weekdaysShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
        this._weekdaysMinStrictRegex = new RegExp('^(' + minPieces.join('|') + ')', 'i');
    }

    // FORMATTING

    function hFormat() {
        return this.hours() % 12 || 12;
    }

    function kFormat() {
        return this.hours() || 24;
    }

    addFormatToken('H', ['HH', 2], 0, 'hour');
    addFormatToken('h', ['hh', 2], 0, hFormat);
    addFormatToken('k', ['kk', 2], 0, kFormat);

    addFormatToken('hmm', 0, 0, function () {
        return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
    });

    addFormatToken('hmmss', 0, 0, function () {
        return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2) +
            zeroFill(this.seconds(), 2);
    });

    addFormatToken('Hmm', 0, 0, function () {
        return '' + this.hours() + zeroFill(this.minutes(), 2);
    });

    addFormatToken('Hmmss', 0, 0, function () {
        return '' + this.hours() + zeroFill(this.minutes(), 2) +
            zeroFill(this.seconds(), 2);
    });

    function meridiem (token, lowercase) {
        addFormatToken(token, 0, 0, function () {
            return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
        });
    }

    meridiem('a', true);
    meridiem('A', false);

    // ALIASES

    addUnitAlias('hour', 'h');

    // PRIORITY
    addUnitPriority('hour', 13);

    // PARSING

    function matchMeridiem (isStrict, locale) {
        return locale._meridiemParse;
    }

    addRegexToken('a',  matchMeridiem);
    addRegexToken('A',  matchMeridiem);
    addRegexToken('H',  match1to2);
    addRegexToken('h',  match1to2);
    addRegexToken('k',  match1to2);
    addRegexToken('HH', match1to2, match2);
    addRegexToken('hh', match1to2, match2);
    addRegexToken('kk', match1to2, match2);

    addRegexToken('hmm', match3to4);
    addRegexToken('hmmss', match5to6);
    addRegexToken('Hmm', match3to4);
    addRegexToken('Hmmss', match5to6);

    addParseToken(['H', 'HH'], HOUR);
    addParseToken(['k', 'kk'], function (input, array, config) {
        var kInput = toInt(input);
        array[HOUR] = kInput === 24 ? 0 : kInput;
    });
    addParseToken(['a', 'A'], function (input, array, config) {
        config._isPm = config._locale.isPM(input);
        config._meridiem = input;
    });
    addParseToken(['h', 'hh'], function (input, array, config) {
        array[HOUR] = toInt(input);
        getParsingFlags(config).bigHour = true;
    });
    addParseToken('hmm', function (input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
        getParsingFlags(config).bigHour = true;
    });
    addParseToken('hmmss', function (input, array, config) {
        var pos1 = input.length - 4;
        var pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
        getParsingFlags(config).bigHour = true;
    });
    addParseToken('Hmm', function (input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
    });
    addParseToken('Hmmss', function (input, array, config) {
        var pos1 = input.length - 4;
        var pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
    });

    // LOCALES

    function localeIsPM (input) {
        // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
        // Using charAt should be more compatible.
        return ((input + '').toLowerCase().charAt(0) === 'p');
    }

    var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;
    function localeMeridiem (hours, minutes, isLower) {
        if (hours > 11) {
            return isLower ? 'pm' : 'PM';
        } else {
            return isLower ? 'am' : 'AM';
        }
    }


    // MOMENTS

    // Setting the hour should keep the time, because the user explicitly
    // specified which hour they want. So trying to maintain the same hour (in
    // a new timezone) makes sense. Adding/subtracting hours does not follow
    // this rule.
    var getSetHour = makeGetSet('Hours', true);

    var baseConfig = {
        calendar: defaultCalendar,
        longDateFormat: defaultLongDateFormat,
        invalidDate: defaultInvalidDate,
        ordinal: defaultOrdinal,
        dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
        relativeTime: defaultRelativeTime,

        months: defaultLocaleMonths,
        monthsShort: defaultLocaleMonthsShort,

        week: defaultLocaleWeek,

        weekdays: defaultLocaleWeekdays,
        weekdaysMin: defaultLocaleWeekdaysMin,
        weekdaysShort: defaultLocaleWeekdaysShort,

        meridiemParse: defaultLocaleMeridiemParse
    };

    // internal storage for locale config files
    var locales = {};
    var localeFamilies = {};
    var globalLocale;

    function normalizeLocale(key) {
        return key ? key.toLowerCase().replace('_', '-') : key;
    }

    // pick the locale from the array
    // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
    // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
    function chooseLocale(names) {
        var i = 0, j, next, locale, split;

        while (i < names.length) {
            split = normalizeLocale(names[i]).split('-');
            j = split.length;
            next = normalizeLocale(names[i + 1]);
            next = next ? next.split('-') : null;
            while (j > 0) {
                locale = loadLocale(split.slice(0, j).join('-'));
                if (locale) {
                    return locale;
                }
                if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
                    //the next array item is better than a shallower substring of this one
                    break;
                }
                j--;
            }
            i++;
        }
        return globalLocale;
    }

    function loadLocale(name) {
        var oldLocale = null;
        // TODO: Find a better way to register and load all the locales in Node
        if (!locales[name] && (typeof module !== 'undefined') &&
                module && module.exports) {
            try {
                oldLocale = globalLocale._abbr;
                var aliasedRequire = require;
                aliasedRequire('./locale/' + name);
                getSetGlobalLocale(oldLocale);
            } catch (e) {}
        }
        return locales[name];
    }

    // This function will load locale and then set the global locale.  If
    // no arguments are passed in, it will simply return the current global
    // locale key.
    function getSetGlobalLocale (key, values) {
        var data;
        if (key) {
            if (isUndefined(values)) {
                data = getLocale(key);
            }
            else {
                data = defineLocale(key, values);
            }

            if (data) {
                // moment.duration._locale = moment._locale = data;
                globalLocale = data;
            }
            else {
                if ((typeof console !==  'undefined') && console.warn) {
                    //warn user if arguments are passed but the locale could not be set
                    console.warn('Locale ' + key +  ' not found. Did you forget to load it?');
                }
            }
        }

        return globalLocale._abbr;
    }

    function defineLocale (name, config) {
        if (config !== null) {
            var locale, parentConfig = baseConfig;
            config.abbr = name;
            if (locales[name] != null) {
                deprecateSimple('defineLocaleOverride',
                        'use moment.updateLocale(localeName, config) to change ' +
                        'an existing locale. moment.defineLocale(localeName, ' +
                        'config) should only be used for creating a new locale ' +
                        'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.');
                parentConfig = locales[name]._config;
            } else if (config.parentLocale != null) {
                if (locales[config.parentLocale] != null) {
                    parentConfig = locales[config.parentLocale]._config;
                } else {
                    locale = loadLocale(config.parentLocale);
                    if (locale != null) {
                        parentConfig = locale._config;
                    } else {
                        if (!localeFamilies[config.parentLocale]) {
                            localeFamilies[config.parentLocale] = [];
                        }
                        localeFamilies[config.parentLocale].push({
                            name: name,
                            config: config
                        });
                        return null;
                    }
                }
            }
            locales[name] = new Locale(mergeConfigs(parentConfig, config));

            if (localeFamilies[name]) {
                localeFamilies[name].forEach(function (x) {
                    defineLocale(x.name, x.config);
                });
            }

            // backwards compat for now: also set the locale
            // make sure we set the locale AFTER all child locales have been
            // created, so we won't end up with the child locale set.
            getSetGlobalLocale(name);


            return locales[name];
        } else {
            // useful for testing
            delete locales[name];
            return null;
        }
    }

    function updateLocale(name, config) {
        if (config != null) {
            var locale, tmpLocale, parentConfig = baseConfig;
            // MERGE
            tmpLocale = loadLocale(name);
            if (tmpLocale != null) {
                parentConfig = tmpLocale._config;
            }
            config = mergeConfigs(parentConfig, config);
            locale = new Locale(config);
            locale.parentLocale = locales[name];
            locales[name] = locale;

            // backwards compat for now: also set the locale
            getSetGlobalLocale(name);
        } else {
            // pass null for config to unupdate, useful for tests
            if (locales[name] != null) {
                if (locales[name].parentLocale != null) {
                    locales[name] = locales[name].parentLocale;
                } else if (locales[name] != null) {
                    delete locales[name];
                }
            }
        }
        return locales[name];
    }

    // returns locale data
    function getLocale (key) {
        var locale;

        if (key && key._locale && key._locale._abbr) {
            key = key._locale._abbr;
        }

        if (!key) {
            return globalLocale;
        }

        if (!isArray(key)) {
            //short-circuit everything else
            locale = loadLocale(key);
            if (locale) {
                return locale;
            }
            key = [key];
        }

        return chooseLocale(key);
    }

    function listLocales() {
        return keys(locales);
    }

    function checkOverflow (m) {
        var overflow;
        var a = m._a;

        if (a && getParsingFlags(m).overflow === -2) {
            overflow =
                a[MONTH]       < 0 || a[MONTH]       > 11  ? MONTH :
                a[DATE]        < 1 || a[DATE]        > daysInMonth(a[YEAR], a[MONTH]) ? DATE :
                a[HOUR]        < 0 || a[HOUR]        > 24 || (a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0)) ? HOUR :
                a[MINUTE]      < 0 || a[MINUTE]      > 59  ? MINUTE :
                a[SECOND]      < 0 || a[SECOND]      > 59  ? SECOND :
                a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND :
                -1;

            if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
                overflow = DATE;
            }
            if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
                overflow = WEEK;
            }
            if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
                overflow = WEEKDAY;
            }

            getParsingFlags(m).overflow = overflow;
        }

        return m;
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function currentDateArray(config) {
        // hooks is actually the exported moment object
        var nowValue = new Date(hooks.now());
        if (config._useUTC) {
            return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];
        }
        return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
    }

    // convert an array to a date.
    // the array should mirror the parameters below
    // note: all values past the year are optional and will default to the lowest possible value.
    // [year, month, day , hour, minute, second, millisecond]
    function configFromArray (config) {
        var i, date, input = [], currentDate, expectedWeekday, yearToUse;

        if (config._d) {
            return;
        }

        currentDate = currentDateArray(config);

        //compute day of the year from weeks and weekdays
        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
            dayOfYearFromWeekInfo(config);
        }

        //if the day of the year is set, figure out what it is
        if (config._dayOfYear != null) {
            yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);

            if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {
                getParsingFlags(config)._overflowDayOfYear = true;
            }

            date = createUTCDate(yearToUse, 0, config._dayOfYear);
            config._a[MONTH] = date.getUTCMonth();
            config._a[DATE] = date.getUTCDate();
        }

        // Default to current date.
        // * if no year, month, day of month are given, default to today
        // * if day of month is given, default month and year
        // * if month is given, default only year
        // * if year is given, don't default anything
        for (i = 0; i < 3 && config._a[i] == null; ++i) {
            config._a[i] = input[i] = currentDate[i];
        }

        // Zero out whatever was not defaulted, including time
        for (; i < 7; i++) {
            config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
        }

        // Check for 24:00:00.000
        if (config._a[HOUR] === 24 &&
                config._a[MINUTE] === 0 &&
                config._a[SECOND] === 0 &&
                config._a[MILLISECOND] === 0) {
            config._nextDay = true;
            config._a[HOUR] = 0;
        }

        config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
        expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay();

        // Apply timezone offset from input. The actual utcOffset can be changed
        // with parseZone.
        if (config._tzm != null) {
            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
        }

        if (config._nextDay) {
            config._a[HOUR] = 24;
        }

        // check for mismatching day of week
        if (config._w && typeof config._w.d !== 'undefined' && config._w.d !== expectedWeekday) {
            getParsingFlags(config).weekdayMismatch = true;
        }
    }

    function dayOfYearFromWeekInfo(config) {
        var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow;

        w = config._w;
        if (w.GG != null || w.W != null || w.E != null) {
            dow = 1;
            doy = 4;

            // TODO: We need to take the current isoWeekYear, but that depends on
            // how we interpret now (local, utc, fixed offset). So create
            // a now version of current config (take local/utc/offset flags, and
            // create now).
            weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(createLocal(), 1, 4).year);
            week = defaults(w.W, 1);
            weekday = defaults(w.E, 1);
            if (weekday < 1 || weekday > 7) {
                weekdayOverflow = true;
            }
        } else {
            dow = config._locale._week.dow;
            doy = config._locale._week.doy;

            var curWeek = weekOfYear(createLocal(), dow, doy);

            weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);

            // Default to current week.
            week = defaults(w.w, curWeek.week);

            if (w.d != null) {
                // weekday -- low day numbers are considered next week
                weekday = w.d;
                if (weekday < 0 || weekday > 6) {
                    weekdayOverflow = true;
                }
            } else if (w.e != null) {
                // local weekday -- counting starts from beginning of week
                weekday = w.e + dow;
                if (w.e < 0 || w.e > 6) {
                    weekdayOverflow = true;
                }
            } else {
                // default to beginning of week
                weekday = dow;
            }
        }
        if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
            getParsingFlags(config)._overflowWeeks = true;
        } else if (weekdayOverflow != null) {
            getParsingFlags(config)._overflowWeekday = true;
        } else {
            temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
            config._a[YEAR] = temp.year;
            config._dayOfYear = temp.dayOfYear;
        }
    }

    // iso 8601 regex
    // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
    var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
    var basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;

    var tzRegex = /Z|[+-]\d\d(?::?\d\d)?/;

    var isoDates = [
        ['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/],
        ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/],
        ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/],
        ['GGGG-[W]WW', /\d{4}-W\d\d/, false],
        ['YYYY-DDD', /\d{4}-\d{3}/],
        ['YYYY-MM', /\d{4}-\d\d/, false],
        ['YYYYYYMMDD', /[+-]\d{10}/],
        ['YYYYMMDD', /\d{8}/],
        // YYYYMM is NOT allowed by the standard
        ['GGGG[W]WWE', /\d{4}W\d{3}/],
        ['GGGG[W]WW', /\d{4}W\d{2}/, false],
        ['YYYYDDD', /\d{7}/]
    ];

    // iso time formats and regexes
    var isoTimes = [
        ['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/],
        ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/],
        ['HH:mm:ss', /\d\d:\d\d:\d\d/],
        ['HH:mm', /\d\d:\d\d/],
        ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/],
        ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/],
        ['HHmmss', /\d\d\d\d\d\d/],
        ['HHmm', /\d\d\d\d/],
        ['HH', /\d\d/]
    ];

    var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i;

    // date from iso format
    function configFromISO(config) {
        var i, l,
            string = config._i,
            match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
            allowTime, dateFormat, timeFormat, tzFormat;

        if (match) {
            getParsingFlags(config).iso = true;

            for (i = 0, l = isoDates.length; i < l; i++) {
                if (isoDates[i][1].exec(match[1])) {
                    dateFormat = isoDates[i][0];
                    allowTime = isoDates[i][2] !== false;
                    break;
                }
            }
            if (dateFormat == null) {
                config._isValid = false;
                return;
            }
            if (match[3]) {
                for (i = 0, l = isoTimes.length; i < l; i++) {
                    if (isoTimes[i][1].exec(match[3])) {
                        // match[2] should be 'T' or space
                        timeFormat = (match[2] || ' ') + isoTimes[i][0];
                        break;
                    }
                }
                if (timeFormat == null) {
                    config._isValid = false;
                    return;
                }
            }
            if (!allowTime && timeFormat != null) {
                config._isValid = false;
                return;
            }
            if (match[4]) {
                if (tzRegex.exec(match[4])) {
                    tzFormat = 'Z';
                } else {
                    config._isValid = false;
                    return;
                }
            }
            config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
            configFromStringAndFormat(config);
        } else {
            config._isValid = false;
        }
    }

    // RFC 2822 regex: For details see https://tools.ietf.org/html/rfc2822#section-3.3
    var rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/;

    function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
        var result = [
            untruncateYear(yearStr),
            defaultLocaleMonthsShort.indexOf(monthStr),
            parseInt(dayStr, 10),
            parseInt(hourStr, 10),
            parseInt(minuteStr, 10)
        ];

        if (secondStr) {
            result.push(parseInt(secondStr, 10));
        }

        return result;
    }

    function untruncateYear(yearStr) {
        var year = parseInt(yearStr, 10);
        if (year <= 49) {
            return 2000 + year;
        } else if (year <= 999) {
            return 1900 + year;
        }
        return year;
    }

    function preprocessRFC2822(s) {
        // Remove comments and folding whitespace and replace multiple-spaces with a single space
        return s.replace(/\([^)]*\)|[\n\t]/g, ' ').replace(/(\s\s+)/g, ' ').replace(/^\s\s*/, '').replace(/\s\s*$/, '');
    }

    function checkWeekday(weekdayStr, parsedInput, config) {
        if (weekdayStr) {
            // TODO: Replace the vanilla JS Date object with an indepentent day-of-week check.
            var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr),
                weekdayActual = new Date(parsedInput[0], parsedInput[1], parsedInput[2]).getDay();
            if (weekdayProvided !== weekdayActual) {
                getParsingFlags(config).weekdayMismatch = true;
                config._isValid = false;
                return false;
            }
        }
        return true;
    }

    var obsOffsets = {
        UT: 0,
        GMT: 0,
        EDT: -4 * 60,
        EST: -5 * 60,
        CDT: -5 * 60,
        CST: -6 * 60,
        MDT: -6 * 60,
        MST: -7 * 60,
        PDT: -7 * 60,
        PST: -8 * 60
    };

    function calculateOffset(obsOffset, militaryOffset, numOffset) {
        if (obsOffset) {
            return obsOffsets[obsOffset];
        } else if (militaryOffset) {
            // the only allowed military tz is Z
            return 0;
        } else {
            var hm = parseInt(numOffset, 10);
            var m = hm % 100, h = (hm - m) / 100;
            return h * 60 + m;
        }
    }

    // date and time from ref 2822 format
    function configFromRFC2822(config) {
        var match = rfc2822.exec(preprocessRFC2822(config._i));
        if (match) {
            var parsedArray = extractFromRFC2822Strings(match[4], match[3], match[2], match[5], match[6], match[7]);
            if (!checkWeekday(match[1], parsedArray, config)) {
                return;
            }

            config._a = parsedArray;
            config._tzm = calculateOffset(match[8], match[9], match[10]);

            config._d = createUTCDate.apply(null, config._a);
            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);

            getParsingFlags(config).rfc2822 = true;
        } else {
            config._isValid = false;
        }
    }

    // date from iso format or fallback
    function configFromString(config) {
        var matched = aspNetJsonRegex.exec(config._i);

        if (matched !== null) {
            config._d = new Date(+matched[1]);
            return;
        }

        configFromISO(config);
        if (config._isValid === false) {
            delete config._isValid;
        } else {
            return;
        }

        configFromRFC2822(config);
        if (config._isValid === false) {
            delete config._isValid;
        } else {
            return;
        }

        // Final attempt, use Input Fallback
        hooks.createFromInputFallback(config);
    }

    hooks.createFromInputFallback = deprecate(
        'value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), ' +
        'which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are ' +
        'discouraged and will be removed in an upcoming major release. Please refer to ' +
        'http://momentjs.com/guides/#/warnings/js-date/ for more info.',
        function (config) {
            config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
        }
    );

    // constant that refers to the ISO standard
    hooks.ISO_8601 = function () {};

    // constant that refers to the RFC 2822 form
    hooks.RFC_2822 = function () {};

    // date from string and format string
    function configFromStringAndFormat(config) {
        // TODO: Move this to another part of the creation flow to prevent circular deps
        if (config._f === hooks.ISO_8601) {
            configFromISO(config);
            return;
        }
        if (config._f === hooks.RFC_2822) {
            configFromRFC2822(config);
            return;
        }
        config._a = [];
        getParsingFlags(config).empty = true;

        // This array is used to make a Date, either with `new Date` or `Date.UTC`
        var string = '' + config._i,
            i, parsedInput, tokens, token, skipped,
            stringLength = string.length,
            totalParsedInputLength = 0;

        tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];

        for (i = 0; i < tokens.length; i++) {
            token = tokens[i];
            parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
            // console.log('token', token, 'parsedInput', parsedInput,
            //         'regex', getParseRegexForToken(token, config));
            if (parsedInput) {
                skipped = string.substr(0, string.indexOf(parsedInput));
                if (skipped.length > 0) {
                    getParsingFlags(config).unusedInput.push(skipped);
                }
                string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
                totalParsedInputLength += parsedInput.length;
            }
            // don't parse if it's not a known token
            if (formatTokenFunctions[token]) {
                if (parsedInput) {
                    getParsingFlags(config).empty = false;
                }
                else {
                    getParsingFlags(config).unusedTokens.push(token);
                }
                addTimeToArrayFromToken(token, parsedInput, config);
            }
            else if (config._strict && !parsedInput) {
                getParsingFlags(config).unusedTokens.push(token);
            }
        }

        // add remaining unparsed input length to the string
        getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
        if (string.length > 0) {
            getParsingFlags(config).unusedInput.push(string);
        }

        // clear _12h flag if hour is <= 12
        if (config._a[HOUR] <= 12 &&
            getParsingFlags(config).bigHour === true &&
            config._a[HOUR] > 0) {
            getParsingFlags(config).bigHour = undefined;
        }

        getParsingFlags(config).parsedDateParts = config._a.slice(0);
        getParsingFlags(config).meridiem = config._meridiem;
        // handle meridiem
        config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);

        configFromArray(config);
        checkOverflow(config);
    }


    function meridiemFixWrap (locale, hour, meridiem) {
        var isPm;

        if (meridiem == null) {
            // nothing to do
            return hour;
        }
        if (locale.meridiemHour != null) {
            return locale.meridiemHour(hour, meridiem);
        } else if (locale.isPM != null) {
            // Fallback
            isPm = locale.isPM(meridiem);
            if (isPm && hour < 12) {
                hour += 12;
            }
            if (!isPm && hour === 12) {
                hour = 0;
            }
            return hour;
        } else {
            // this is not supposed to happen
            return hour;
        }
    }

    // date from string and array of format strings
    function configFromStringAndArray(config) {
        var tempConfig,
            bestMoment,

            scoreToBeat,
            i,
            currentScore;

        if (config._f.length === 0) {
            getParsingFlags(config).invalidFormat = true;
            config._d = new Date(NaN);
            return;
        }

        for (i = 0; i < config._f.length; i++) {
            currentScore = 0;
            tempConfig = copyConfig({}, config);
            if (config._useUTC != null) {
                tempConfig._useUTC = config._useUTC;
            }
            tempConfig._f = config._f[i];
            configFromStringAndFormat(tempConfig);

            if (!isValid(tempConfig)) {
                continue;
            }

            // if there is any input that was not parsed add a penalty for that format
            currentScore += getParsingFlags(tempConfig).charsLeftOver;

            //or tokens
            currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;

            getParsingFlags(tempConfig).score = currentScore;

            if (scoreToBeat == null || currentScore < scoreToBeat) {
                scoreToBeat = currentScore;
                bestMoment = tempConfig;
            }
        }

        extend(config, bestMoment || tempConfig);
    }

    function configFromObject(config) {
        if (config._d) {
            return;
        }

        var i = normalizeObjectUnits(config._i);
        config._a = map([i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond], function (obj) {
            return obj && parseInt(obj, 10);
        });

        configFromArray(config);
    }

    function createFromConfig (config) {
        var res = new Moment(checkOverflow(prepareConfig(config)));
        if (res._nextDay) {
            // Adding is smart enough around DST
            res.add(1, 'd');
            res._nextDay = undefined;
        }

        return res;
    }

    function prepareConfig (config) {
        var input = config._i,
            format = config._f;

        config._locale = config._locale || getLocale(config._l);

        if (input === null || (format === undefined && input === '')) {
            return createInvalid({nullInput: true});
        }

        if (typeof input === 'string') {
            config._i = input = config._locale.preparse(input);
        }

        if (isMoment(input)) {
            return new Moment(checkOverflow(input));
        } else if (isDate(input)) {
            config._d = input;
        } else if (isArray(format)) {
            configFromStringAndArray(config);
        } else if (format) {
            configFromStringAndFormat(config);
        }  else {
            configFromInput(config);
        }

        if (!isValid(config)) {
            config._d = null;
        }

        return config;
    }

    function configFromInput(config) {
        var input = config._i;
        if (isUndefined(input)) {
            config._d = new Date(hooks.now());
        } else if (isDate(input)) {
            config._d = new Date(input.valueOf());
        } else if (typeof input === 'string') {
            configFromString(config);
        } else if (isArray(input)) {
            config._a = map(input.slice(0), function (obj) {
                return parseInt(obj, 10);
            });
            configFromArray(config);
        } else if (isObject(input)) {
            configFromObject(config);
        } else if (isNumber(input)) {
            // from milliseconds
            config._d = new Date(input);
        } else {
            hooks.createFromInputFallback(config);
        }
    }

    function createLocalOrUTC (input, format, locale, strict, isUTC) {
        var c = {};

        if (locale === true || locale === false) {
            strict = locale;
            locale = undefined;
        }

        if ((isObject(input) && isObjectEmpty(input)) ||
                (isArray(input) && input.length === 0)) {
            input = undefined;
        }
        // object construction must be done this way.
        // https://github.com/moment/moment/issues/1423
        c._isAMomentObject = true;
        c._useUTC = c._isUTC = isUTC;
        c._l = locale;
        c._i = input;
        c._f = format;
        c._strict = strict;

        return createFromConfig(c);
    }

    function createLocal (input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, false);
    }

    var prototypeMin = deprecate(
        'moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/',
        function () {
            var other = createLocal.apply(null, arguments);
            if (this.isValid() && other.isValid()) {
                return other < this ? this : other;
            } else {
                return createInvalid();
            }
        }
    );

    var prototypeMax = deprecate(
        'moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/',
        function () {
            var other = createLocal.apply(null, arguments);
            if (this.isValid() && other.isValid()) {
                return other > this ? this : other;
            } else {
                return createInvalid();
            }
        }
    );

    // Pick a moment m from moments so that m[fn](other) is true for all
    // other. This relies on the function fn to be transitive.
    //
    // moments should either be an array of moment objects or an array, whose
    // first element is an array of moment objects.
    function pickBy(fn, moments) {
        var res, i;
        if (moments.length === 1 && isArray(moments[0])) {
            moments = moments[0];
        }
        if (!moments.length) {
            return createLocal();
        }
        res = moments[0];
        for (i = 1; i < moments.length; ++i) {
            if (!moments[i].isValid() || moments[i][fn](res)) {
                res = moments[i];
            }
        }
        return res;
    }

    // TODO: Use [].sort instead?
    function min () {
        var args = [].slice.call(arguments, 0);

        return pickBy('isBefore', args);
    }

    function max () {
        var args = [].slice.call(arguments, 0);

        return pickBy('isAfter', args);
    }

    var now = function () {
        return Date.now ? Date.now() : +(new Date());
    };

    var ordering = ['year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', 'millisecond'];

    function isDurationValid(m) {
        for (var key in m) {
            if (!(indexOf.call(ordering, key) !== -1 && (m[key] == null || !isNaN(m[key])))) {
                return false;
            }
        }

        var unitHasDecimal = false;
        for (var i = 0; i < ordering.length; ++i) {
            if (m[ordering[i]]) {
                if (unitHasDecimal) {
                    return false; // only allow non-integers for smallest unit
                }
                if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
                    unitHasDecimal = true;
                }
            }
        }

        return true;
    }

    function isValid$1() {
        return this._isValid;
    }

    function createInvalid$1() {
        return createDuration(NaN);
    }

    function Duration (duration) {
        var normalizedInput = normalizeObjectUnits(duration),
            years = normalizedInput.year || 0,
            quarters = normalizedInput.quarter || 0,
            months = normalizedInput.month || 0,
            weeks = normalizedInput.week || normalizedInput.isoWeek || 0,
            days = normalizedInput.day || 0,
            hours = normalizedInput.hour || 0,
            minutes = normalizedInput.minute || 0,
            seconds = normalizedInput.second || 0,
            milliseconds = normalizedInput.millisecond || 0;

        this._isValid = isDurationValid(normalizedInput);

        // representation for dateAddRemove
        this._milliseconds = +milliseconds +
            seconds * 1e3 + // 1000
            minutes * 6e4 + // 1000 * 60
            hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978
        // Because of dateAddRemove treats 24 hours as different from a
        // day when working around DST, we need to store them separately
        this._days = +days +
            weeks * 7;
        // It is impossible to translate months into days without knowing
        // which months you are are talking about, so we have to store
        // it separately.
        this._months = +months +
            quarters * 3 +
            years * 12;

        this._data = {};

        this._locale = getLocale();

        this._bubble();
    }

    function isDuration (obj) {
        return obj instanceof Duration;
    }

    function absRound (number) {
        if (number < 0) {
            return Math.round(-1 * number) * -1;
        } else {
            return Math.round(number);
        }
    }

    // FORMATTING

    function offset (token, separator) {
        addFormatToken(token, 0, 0, function () {
            var offset = this.utcOffset();
            var sign = '+';
            if (offset < 0) {
                offset = -offset;
                sign = '-';
            }
            return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~(offset) % 60, 2);
        });
    }

    offset('Z', ':');
    offset('ZZ', '');

    // PARSING

    addRegexToken('Z',  matchShortOffset);
    addRegexToken('ZZ', matchShortOffset);
    addParseToken(['Z', 'ZZ'], function (input, array, config) {
        config._useUTC = true;
        config._tzm = offsetFromString(matchShortOffset, input);
    });

    // HELPERS

    // timezone chunker
    // '+10:00' > ['10',  '00']
    // '-1530'  > ['-15', '30']
    var chunkOffset = /([\+\-]|\d\d)/gi;

    function offsetFromString(matcher, string) {
        var matches = (string || '').match(matcher);

        if (matches === null) {
            return null;
        }

        var chunk   = matches[matches.length - 1] || [];
        var parts   = (chunk + '').match(chunkOffset) || ['-', 0, 0];
        var minutes = +(parts[1] * 60) + toInt(parts[2]);

        return minutes === 0 ?
          0 :
          parts[0] === '+' ? minutes : -minutes;
    }

    // Return a moment from input, that is local/utc/zone equivalent to model.
    function cloneWithOffset(input, model) {
        var res, diff;
        if (model._isUTC) {
            res = model.clone();
            diff = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
            // Use low-level api, because this fn is low-level api.
            res._d.setTime(res._d.valueOf() + diff);
            hooks.updateOffset(res, false);
            return res;
        } else {
            return createLocal(input).local();
        }
    }

    function getDateOffset (m) {
        // On Firefox.24 Date#getTimezoneOffset returns a floating point.
        // https://github.com/moment/moment/pull/1871
        return -Math.round(m._d.getTimezoneOffset() / 15) * 15;
    }

    // HOOKS

    // This function will be called whenever a moment is mutated.
    // It is intended to keep the offset in sync with the timezone.
    hooks.updateOffset = function () {};

    // MOMENTS

    // keepLocalTime = true means only change the timezone, without
    // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
    // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
    // +0200, so we adjust the time as needed, to be valid.
    //
    // Keeping the time actually adds/subtracts (one hour)
    // from the actual represented time. That is why we call updateOffset
    // a second time. In case it wants us to change the offset again
    // _changeInProgress == true case, then we have to adjust, because
    // there is no such time in the given timezone.
    function getSetOffset (input, keepLocalTime, keepMinutes) {
        var offset = this._offset || 0,
            localAdjust;
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        if (input != null) {
            if (typeof input === 'string') {
                input = offsetFromString(matchShortOffset, input);
                if (input === null) {
                    return this;
                }
            } else if (Math.abs(input) < 16 && !keepMinutes) {
                input = input * 60;
            }
            if (!this._isUTC && keepLocalTime) {
                localAdjust = getDateOffset(this);
            }
            this._offset = input;
            this._isUTC = true;
            if (localAdjust != null) {
                this.add(localAdjust, 'm');
            }
            if (offset !== input) {
                if (!keepLocalTime || this._changeInProgress) {
                    addSubtract(this, createDuration(input - offset, 'm'), 1, false);
                } else if (!this._changeInProgress) {
                    this._changeInProgress = true;
                    hooks.updateOffset(this, true);
                    this._changeInProgress = null;
                }
            }
            return this;
        } else {
            return this._isUTC ? offset : getDateOffset(this);
        }
    }

    function getSetZone (input, keepLocalTime) {
        if (input != null) {
            if (typeof input !== 'string') {
                input = -input;
            }

            this.utcOffset(input, keepLocalTime);

            return this;
        } else {
            return -this.utcOffset();
        }
    }

    function setOffsetToUTC (keepLocalTime) {
        return this.utcOffset(0, keepLocalTime);
    }

    function setOffsetToLocal (keepLocalTime) {
        if (this._isUTC) {
            this.utcOffset(0, keepLocalTime);
            this._isUTC = false;

            if (keepLocalTime) {
                this.subtract(getDateOffset(this), 'm');
            }
        }
        return this;
    }

    function setOffsetToParsedOffset () {
        if (this._tzm != null) {
            this.utcOffset(this._tzm, false, true);
        } else if (typeof this._i === 'string') {
            var tZone = offsetFromString(matchOffset, this._i);
            if (tZone != null) {
                this.utcOffset(tZone);
            }
            else {
                this.utcOffset(0, true);
            }
        }
        return this;
    }

    function hasAlignedHourOffset (input) {
        if (!this.isValid()) {
            return false;
        }
        input = input ? createLocal(input).utcOffset() : 0;

        return (this.utcOffset() - input) % 60 === 0;
    }

    function isDaylightSavingTime () {
        return (
            this.utcOffset() > this.clone().month(0).utcOffset() ||
            this.utcOffset() > this.clone().month(5).utcOffset()
        );
    }

    function isDaylightSavingTimeShifted () {
        if (!isUndefined(this._isDSTShifted)) {
            return this._isDSTShifted;
        }

        var c = {};

        copyConfig(c, this);
        c = prepareConfig(c);

        if (c._a) {
            var other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
            this._isDSTShifted = this.isValid() &&
                compareArrays(c._a, other.toArray()) > 0;
        } else {
            this._isDSTShifted = false;
        }

        return this._isDSTShifted;
    }

    function isLocal () {
        return this.isValid() ? !this._isUTC : false;
    }

    function isUtcOffset () {
        return this.isValid() ? this._isUTC : false;
    }

    function isUtc () {
        return this.isValid() ? this._isUTC && this._offset === 0 : false;
    }

    // ASP.NET json date format regex
    var aspNetRegex = /^(\-|\+)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)(\.\d*)?)?$/;

    // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
    // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
    // and further modified to allow for strings containing both week and day
    var isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;

    function createDuration (input, key) {
        var duration = input,
            // matching against regexp is expensive, do it on demand
            match = null,
            sign,
            ret,
            diffRes;

        if (isDuration(input)) {
            duration = {
                ms : input._milliseconds,
                d  : input._days,
                M  : input._months
            };
        } else if (isNumber(input)) {
            duration = {};
            if (key) {
                duration[key] = input;
            } else {
                duration.milliseconds = input;
            }
        } else if (!!(match = aspNetRegex.exec(input))) {
            sign = (match[1] === '-') ? -1 : 1;
            duration = {
                y  : 0,
                d  : toInt(match[DATE])                         * sign,
                h  : toInt(match[HOUR])                         * sign,
                m  : toInt(match[MINUTE])                       * sign,
                s  : toInt(match[SECOND])                       * sign,
                ms : toInt(absRound(match[MILLISECOND] * 1000)) * sign // the millisecond decimal point is included in the match
            };
        } else if (!!(match = isoRegex.exec(input))) {
            sign = (match[1] === '-') ? -1 : 1;
            duration = {
                y : parseIso(match[2], sign),
                M : parseIso(match[3], sign),
                w : parseIso(match[4], sign),
                d : parseIso(match[5], sign),
                h : parseIso(match[6], sign),
                m : parseIso(match[7], sign),
                s : parseIso(match[8], sign)
            };
        } else if (duration == null) {// checks for null or undefined
            duration = {};
        } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {
            diffRes = momentsDifference(createLocal(duration.from), createLocal(duration.to));

            duration = {};
            duration.ms = diffRes.milliseconds;
            duration.M = diffRes.months;
        }

        ret = new Duration(duration);

        if (isDuration(input) && hasOwnProp(input, '_locale')) {
            ret._locale = input._locale;
        }

        return ret;
    }

    createDuration.fn = Duration.prototype;
    createDuration.invalid = createInvalid$1;

    function parseIso (inp, sign) {
        // We'd normally use ~~inp for this, but unfortunately it also
        // converts floats to ints.
        // inp may be undefined, so careful calling replace on it.
        var res = inp && parseFloat(inp.replace(',', '.'));
        // apply sign while we're at it
        return (isNaN(res) ? 0 : res) * sign;
    }

    function positiveMomentsDifference(base, other) {
        var res = {};

        res.months = other.month() - base.month() +
            (other.year() - base.year()) * 12;
        if (base.clone().add(res.months, 'M').isAfter(other)) {
            --res.months;
        }

        res.milliseconds = +other - +(base.clone().add(res.months, 'M'));

        return res;
    }

    function momentsDifference(base, other) {
        var res;
        if (!(base.isValid() && other.isValid())) {
            return {milliseconds: 0, months: 0};
        }

        other = cloneWithOffset(other, base);
        if (base.isBefore(other)) {
            res = positiveMomentsDifference(base, other);
        } else {
            res = positiveMomentsDifference(other, base);
            res.milliseconds = -res.milliseconds;
            res.months = -res.months;
        }

        return res;
    }

    // TODO: remove 'name' arg after deprecation is removed
    function createAdder(direction, name) {
        return function (val, period) {
            var dur, tmp;
            //invert the arguments, but complain about it
            if (period !== null && !isNaN(+period)) {
                deprecateSimple(name, 'moment().' + name  + '(period, number) is deprecated. Please use moment().' + name + '(number, period). ' +
                'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.');
                tmp = val; val = period; period = tmp;
            }

            val = typeof val === 'string' ? +val : val;
            dur = createDuration(val, period);
            addSubtract(this, dur, direction);
            return this;
        };
    }

    function addSubtract (mom, duration, isAdding, updateOffset) {
        var milliseconds = duration._milliseconds,
            days = absRound(duration._days),
            months = absRound(duration._months);

        if (!mom.isValid()) {
            // No op
            return;
        }

        updateOffset = updateOffset == null ? true : updateOffset;

        if (months) {
            setMonth(mom, get(mom, 'Month') + months * isAdding);
        }
        if (days) {
            set$1(mom, 'Date', get(mom, 'Date') + days * isAdding);
        }
        if (milliseconds) {
            mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
        }
        if (updateOffset) {
            hooks.updateOffset(mom, days || months);
        }
    }

    var add      = createAdder(1, 'add');
    var subtract = createAdder(-1, 'subtract');

    function getCalendarFormat(myMoment, now) {
        var diff = myMoment.diff(now, 'days', true);
        return diff < -6 ? 'sameElse' :
                diff < -1 ? 'lastWeek' :
                diff < 0 ? 'lastDay' :
                diff < 1 ? 'sameDay' :
                diff < 2 ? 'nextDay' :
                diff < 7 ? 'nextWeek' : 'sameElse';
    }

    function calendar$1 (time, formats) {
        // We want to compare the start of today, vs this.
        // Getting start-of-today depends on whether we're local/utc/offset or not.
        var now = time || createLocal(),
            sod = cloneWithOffset(now, this).startOf('day'),
            format = hooks.calendarFormat(this, sod) || 'sameElse';

        var output = formats && (isFunction(formats[format]) ? formats[format].call(this, now) : formats[format]);

        return this.format(output || this.localeData().calendar(format, this, createLocal(now)));
    }

    function clone () {
        return new Moment(this);
    }

    function isAfter (input, units) {
        var localInput = isMoment(input) ? input : createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(units) || 'millisecond';
        if (units === 'millisecond') {
            return this.valueOf() > localInput.valueOf();
        } else {
            return localInput.valueOf() < this.clone().startOf(units).valueOf();
        }
    }

    function isBefore (input, units) {
        var localInput = isMoment(input) ? input : createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(units) || 'millisecond';
        if (units === 'millisecond') {
            return this.valueOf() < localInput.valueOf();
        } else {
            return this.clone().endOf(units).valueOf() < localInput.valueOf();
        }
    }

    function isBetween (from, to, units, inclusivity) {
        var localFrom = isMoment(from) ? from : createLocal(from),
            localTo = isMoment(to) ? to : createLocal(to);
        if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
            return false;
        }
        inclusivity = inclusivity || '()';
        return (inclusivity[0] === '(' ? this.isAfter(localFrom, units) : !this.isBefore(localFrom, units)) &&
            (inclusivity[1] === ')' ? this.isBefore(localTo, units) : !this.isAfter(localTo, units));
    }

    function isSame (input, units) {
        var localInput = isMoment(input) ? input : createLocal(input),
            inputMs;
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(units) || 'millisecond';
        if (units === 'millisecond') {
            return this.valueOf() === localInput.valueOf();
        } else {
            inputMs = localInput.valueOf();
            return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
        }
    }

    function isSameOrAfter (input, units) {
        return this.isSame(input, units) || this.isAfter(input, units);
    }

    function isSameOrBefore (input, units) {
        return this.isSame(input, units) || this.isBefore(input, units);
    }

    function diff (input, units, asFloat) {
        var that,
            zoneDelta,
            output;

        if (!this.isValid()) {
            return NaN;
        }

        that = cloneWithOffset(input, this);

        if (!that.isValid()) {
            return NaN;
        }

        zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;

        units = normalizeUnits(units);

        switch (units) {
            case 'year': output = monthDiff(this, that) / 12; break;
            case 'month': output = monthDiff(this, that); break;
            case 'quarter': output = monthDiff(this, that) / 3; break;
            case 'second': output = (this - that) / 1e3; break; // 1000
            case 'minute': output = (this - that) / 6e4; break; // 1000 * 60
            case 'hour': output = (this - that) / 36e5; break; // 1000 * 60 * 60
            case 'day': output = (this - that - zoneDelta) / 864e5; break; // 1000 * 60 * 60 * 24, negate dst
            case 'week': output = (this - that - zoneDelta) / 6048e5; break; // 1000 * 60 * 60 * 24 * 7, negate dst
            default: output = this - that;
        }

        return asFloat ? output : absFloor(output);
    }

    function monthDiff (a, b) {
        // difference in months
        var wholeMonthDiff = ((b.year() - a.year()) * 12) + (b.month() - a.month()),
            // b is in (anchor - 1 month, anchor + 1 month)
            anchor = a.clone().add(wholeMonthDiff, 'months'),
            anchor2, adjust;

        if (b - anchor < 0) {
            anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
            // linear across the month
            adjust = (b - anchor) / (anchor - anchor2);
        } else {
            anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
            // linear across the month
            adjust = (b - anchor) / (anchor2 - anchor);
        }

        //check for negative zero, return zero if negative zero
        return -(wholeMonthDiff + adjust) || 0;
    }

    hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
    hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';

    function toString () {
        return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
    }

    function toISOString(keepOffset) {
        if (!this.isValid()) {
            return null;
        }
        var utc = keepOffset !== true;
        var m = utc ? this.clone().utc() : this;
        if (m.year() < 0 || m.year() > 9999) {
            return formatMoment(m, utc ? 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYYYY-MM-DD[T]HH:mm:ss.SSSZ');
        }
        if (isFunction(Date.prototype.toISOString)) {
            // native implementation is ~50x faster, use it when we can
            if (utc) {
                return this.toDate().toISOString();
            } else {
                return new Date(this.valueOf() + this.utcOffset() * 60 * 1000).toISOString().replace('Z', formatMoment(m, 'Z'));
            }
        }
        return formatMoment(m, utc ? 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYY-MM-DD[T]HH:mm:ss.SSSZ');
    }

    /**
     * Return a human readable representation of a moment that can
     * also be evaluated to get a new moment which is the same
     *
     * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects
     */
    function inspect () {
        if (!this.isValid()) {
            return 'moment.invalid(/* ' + this._i + ' */)';
        }
        var func = 'moment';
        var zone = '';
        if (!this.isLocal()) {
            func = this.utcOffset() === 0 ? 'moment.utc' : 'moment.parseZone';
            zone = 'Z';
        }
        var prefix = '[' + func + '("]';
        var year = (0 <= this.year() && this.year() <= 9999) ? 'YYYY' : 'YYYYYY';
        var datetime = '-MM-DD[T]HH:mm:ss.SSS';
        var suffix = zone + '[")]';

        return this.format(prefix + year + datetime + suffix);
    }

    function format (inputString) {
        if (!inputString) {
            inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
        }
        var output = formatMoment(this, inputString);
        return this.localeData().postformat(output);
    }

    function from (time, withoutSuffix) {
        if (this.isValid() &&
                ((isMoment(time) && time.isValid()) ||
                 createLocal(time).isValid())) {
            return createDuration({to: this, from: time}).locale(this.locale()).humanize(!withoutSuffix);
        } else {
            return this.localeData().invalidDate();
        }
    }

    function fromNow (withoutSuffix) {
        return this.from(createLocal(), withoutSuffix);
    }

    function to (time, withoutSuffix) {
        if (this.isValid() &&
                ((isMoment(time) && time.isValid()) ||
                 createLocal(time).isValid())) {
            return createDuration({from: this, to: time}).locale(this.locale()).humanize(!withoutSuffix);
        } else {
            return this.localeData().invalidDate();
        }
    }

    function toNow (withoutSuffix) {
        return this.to(createLocal(), withoutSuffix);
    }

    // If passed a locale key, it will set the locale for this
    // instance.  Otherwise, it will return the locale configuration
    // variables for this instance.
    function locale (key) {
        var newLocaleData;

        if (key === undefined) {
            return this._locale._abbr;
        } else {
            newLocaleData = getLocale(key);
            if (newLocaleData != null) {
                this._locale = newLocaleData;
            }
            return this;
        }
    }

    var lang = deprecate(
        'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',
        function (key) {
            if (key === undefined) {
                return this.localeData();
            } else {
                return this.locale(key);
            }
        }
    );

    function localeData () {
        return this._locale;
    }

    var MS_PER_SECOND = 1000;
    var MS_PER_MINUTE = 60 * MS_PER_SECOND;
    var MS_PER_HOUR = 60 * MS_PER_MINUTE;
    var MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;

    // actual modulo - handles negative numbers (for dates before 1970):
    function mod$1(dividend, divisor) {
        return (dividend % divisor + divisor) % divisor;
    }

    function localStartOfDate(y, m, d) {
        // the date constructor remaps years 0-99 to 1900-1999
        if (y < 100 && y >= 0) {
            // preserve leap years using a full 400 year cycle, then reset
            return new Date(y + 400, m, d) - MS_PER_400_YEARS;
        } else {
            return new Date(y, m, d).valueOf();
        }
    }

    function utcStartOfDate(y, m, d) {
        // Date.UTC remaps years 0-99 to 1900-1999
        if (y < 100 && y >= 0) {
            // preserve leap years using a full 400 year cycle, then reset
            return Date.UTC(y + 400, m, d) - MS_PER_400_YEARS;
        } else {
            return Date.UTC(y, m, d);
        }
    }

    function startOf (units) {
        var time;
        units = normalizeUnits(units);
        if (units === undefined || units === 'millisecond' || !this.isValid()) {
            return this;
        }

        var startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;

        switch (units) {
            case 'year':
                time = startOfDate(this.year(), 0, 1);
                break;
            case 'quarter':
                time = startOfDate(this.year(), this.month() - this.month() % 3, 1);
                break;
            case 'month':
                time = startOfDate(this.year(), this.month(), 1);
                break;
            case 'week':
                time = startOfDate(this.year(), this.month(), this.date() - this.weekday());
                break;
            case 'isoWeek':
                time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1));
                break;
            case 'day':
            case 'date':
                time = startOfDate(this.year(), this.month(), this.date());
                break;
            case 'hour':
                time = this._d.valueOf();
                time -= mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR);
                break;
            case 'minute':
                time = this._d.valueOf();
                time -= mod$1(time, MS_PER_MINUTE);
                break;
            case 'second':
                time = this._d.valueOf();
                time -= mod$1(time, MS_PER_SECOND);
                break;
        }

        this._d.setTime(time);
        hooks.updateOffset(this, true);
        return this;
    }

    function endOf (units) {
        var time;
        units = normalizeUnits(units);
        if (units === undefined || units === 'millisecond' || !this.isValid()) {
            return this;
        }

        var startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;

        switch (units) {
            case 'year':
                time = startOfDate(this.year() + 1, 0, 1) - 1;
                break;
            case 'quarter':
                time = startOfDate(this.year(), this.month() - this.month() % 3 + 3, 1) - 1;
                break;
            case 'month':
                time = startOfDate(this.year(), this.month() + 1, 1) - 1;
                break;
            case 'week':
                time = startOfDate(this.year(), this.month(), this.date() - this.weekday() + 7) - 1;
                break;
            case 'isoWeek':
                time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1) + 7) - 1;
                break;
            case 'day':
            case 'date':
                time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
                break;
            case 'hour':
                time = this._d.valueOf();
                time += MS_PER_HOUR - mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR) - 1;
                break;
            case 'minute':
                time = this._d.valueOf();
                time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
                break;
            case 'second':
                time = this._d.valueOf();
                time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
                break;
        }

        this._d.setTime(time);
        hooks.updateOffset(this, true);
        return this;
    }

    function valueOf () {
        return this._d.valueOf() - ((this._offset || 0) * 60000);
    }

    function unix () {
        return Math.floor(this.valueOf() / 1000);
    }

    function toDate () {
        return new Date(this.valueOf());
    }

    function toArray () {
        var m = this;
        return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
    }

    function toObject () {
        var m = this;
        return {
            years: m.year(),
            months: m.month(),
            date: m.date(),
            hours: m.hours(),
            minutes: m.minutes(),
            seconds: m.seconds(),
            milliseconds: m.milliseconds()
        };
    }

    function toJSON () {
        // new Date(NaN).toJSON() === null
        return this.isValid() ? this.toISOString() : null;
    }

    function isValid$2 () {
        return isValid(this);
    }

    function parsingFlags () {
        return extend({}, getParsingFlags(this));
    }

    function invalidAt () {
        return getParsingFlags(this).overflow;
    }

    function creationData() {
        return {
            input: this._i,
            format: this._f,
            locale: this._locale,
            isUTC: this._isUTC,
            strict: this._strict
        };
    }

    // FORMATTING

    addFormatToken(0, ['gg', 2], 0, function () {
        return this.weekYear() % 100;
    });

    addFormatToken(0, ['GG', 2], 0, function () {
        return this.isoWeekYear() % 100;
    });

    function addWeekYearFormatToken (token, getter) {
        addFormatToken(0, [token, token.length], 0, getter);
    }

    addWeekYearFormatToken('gggg',     'weekYear');
    addWeekYearFormatToken('ggggg',    'weekYear');
    addWeekYearFormatToken('GGGG',  'isoWeekYear');
    addWeekYearFormatToken('GGGGG', 'isoWeekYear');

    // ALIASES

    addUnitAlias('weekYear', 'gg');
    addUnitAlias('isoWeekYear', 'GG');

    // PRIORITY

    addUnitPriority('weekYear', 1);
    addUnitPriority('isoWeekYear', 1);


    // PARSING

    addRegexToken('G',      matchSigned);
    addRegexToken('g',      matchSigned);
    addRegexToken('GG',     match1to2, match2);
    addRegexToken('gg',     match1to2, match2);
    addRegexToken('GGGG',   match1to4, match4);
    addRegexToken('gggg',   match1to4, match4);
    addRegexToken('GGGGG',  match1to6, match6);
    addRegexToken('ggggg',  match1to6, match6);

    addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {
        week[token.substr(0, 2)] = toInt(input);
    });

    addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
        week[token] = hooks.parseTwoDigitYear(input);
    });

    // MOMENTS

    function getSetWeekYear (input) {
        return getSetWeekYearHelper.call(this,
                input,
                this.week(),
                this.weekday(),
                this.localeData()._week.dow,
                this.localeData()._week.doy);
    }

    function getSetISOWeekYear (input) {
        return getSetWeekYearHelper.call(this,
                input, this.isoWeek(), this.isoWeekday(), 1, 4);
    }

    function getISOWeeksInYear () {
        return weeksInYear(this.year(), 1, 4);
    }

    function getWeeksInYear () {
        var weekInfo = this.localeData()._week;
        return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
    }

    function getSetWeekYearHelper(input, week, weekday, dow, doy) {
        var weeksTarget;
        if (input == null) {
            return weekOfYear(this, dow, doy).year;
        } else {
            weeksTarget = weeksInYear(input, dow, doy);
            if (week > weeksTarget) {
                week = weeksTarget;
            }
            return setWeekAll.call(this, input, week, weekday, dow, doy);
        }
    }

    function setWeekAll(weekYear, week, weekday, dow, doy) {
        var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
            date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);

        this.year(date.getUTCFullYear());
        this.month(date.getUTCMonth());
        this.date(date.getUTCDate());
        return this;
    }

    // FORMATTING

    addFormatToken('Q', 0, 'Qo', 'quarter');

    // ALIASES

    addUnitAlias('quarter', 'Q');

    // PRIORITY

    addUnitPriority('quarter', 7);

    // PARSING

    addRegexToken('Q', match1);
    addParseToken('Q', function (input, array) {
        array[MONTH] = (toInt(input) - 1) * 3;
    });

    // MOMENTS

    function getSetQuarter (input) {
        return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
    }

    // FORMATTING

    addFormatToken('D', ['DD', 2], 'Do', 'date');

    // ALIASES

    addUnitAlias('date', 'D');

    // PRIORITY
    addUnitPriority('date', 9);

    // PARSING

    addRegexToken('D',  match1to2);
    addRegexToken('DD', match1to2, match2);
    addRegexToken('Do', function (isStrict, locale) {
        // TODO: Remove "ordinalParse" fallback in next major release.
        return isStrict ?
          (locale._dayOfMonthOrdinalParse || locale._ordinalParse) :
          locale._dayOfMonthOrdinalParseLenient;
    });

    addParseToken(['D', 'DD'], DATE);
    addParseToken('Do', function (input, array) {
        array[DATE] = toInt(input.match(match1to2)[0]);
    });

    // MOMENTS

    var getSetDayOfMonth = makeGetSet('Date', true);

    // FORMATTING

    addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');

    // ALIASES

    addUnitAlias('dayOfYear', 'DDD');

    // PRIORITY
    addUnitPriority('dayOfYear', 4);

    // PARSING

    addRegexToken('DDD',  match1to3);
    addRegexToken('DDDD', match3);
    addParseToken(['DDD', 'DDDD'], function (input, array, config) {
        config._dayOfYear = toInt(input);
    });

    // HELPERS

    // MOMENTS

    function getSetDayOfYear (input) {
        var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;
        return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');
    }

    // FORMATTING

    addFormatToken('m', ['mm', 2], 0, 'minute');

    // ALIASES

    addUnitAlias('minute', 'm');

    // PRIORITY

    addUnitPriority('minute', 14);

    // PARSING

    addRegexToken('m',  match1to2);
    addRegexToken('mm', match1to2, match2);
    addParseToken(['m', 'mm'], MINUTE);

    // MOMENTS

    var getSetMinute = makeGetSet('Minutes', false);

    // FORMATTING

    addFormatToken('s', ['ss', 2], 0, 'second');

    // ALIASES

    addUnitAlias('second', 's');

    // PRIORITY

    addUnitPriority('second', 15);

    // PARSING

    addRegexToken('s',  match1to2);
    addRegexToken('ss', match1to2, match2);
    addParseToken(['s', 'ss'], SECOND);

    // MOMENTS

    var getSetSecond = makeGetSet('Seconds', false);

    // FORMATTING

    addFormatToken('S', 0, 0, function () {
        return ~~(this.millisecond() / 100);
    });

    addFormatToken(0, ['SS', 2], 0, function () {
        return ~~(this.millisecond() / 10);
    });

    addFormatToken(0, ['SSS', 3], 0, 'millisecond');
    addFormatToken(0, ['SSSS', 4], 0, function () {
        return this.millisecond() * 10;
    });
    addFormatToken(0, ['SSSSS', 5], 0, function () {
        return this.millisecond() * 100;
    });
    addFormatToken(0, ['SSSSSS', 6], 0, function () {
        return this.millisecond() * 1000;
    });
    addFormatToken(0, ['SSSSSSS', 7], 0, function () {
        return this.millisecond() * 10000;
    });
    addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
        return this.millisecond() * 100000;
    });
    addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
        return this.millisecond() * 1000000;
    });


    // ALIASES

    addUnitAlias('millisecond', 'ms');

    // PRIORITY

    addUnitPriority('millisecond', 16);

    // PARSING

    addRegexToken('S',    match1to3, match1);
    addRegexToken('SS',   match1to3, match2);
    addRegexToken('SSS',  match1to3, match3);

    var token;
    for (token = 'SSSS'; token.length <= 9; token += 'S') {
        addRegexToken(token, matchUnsigned);
    }

    function parseMs(input, array) {
        array[MILLISECOND] = toInt(('0.' + input) * 1000);
    }

    for (token = 'S'; token.length <= 9; token += 'S') {
        addParseToken(token, parseMs);
    }
    // MOMENTS

    var getSetMillisecond = makeGetSet('Milliseconds', false);

    // FORMATTING

    addFormatToken('z',  0, 0, 'zoneAbbr');
    addFormatToken('zz', 0, 0, 'zoneName');

    // MOMENTS

    function getZoneAbbr () {
        return this._isUTC ? 'UTC' : '';
    }

    function getZoneName () {
        return this._isUTC ? 'Coordinated Universal Time' : '';
    }

    var proto = Moment.prototype;

    proto.add               = add;
    proto.calendar          = calendar$1;
    proto.clone             = clone;
    proto.diff              = diff;
    proto.endOf             = endOf;
    proto.format            = format;
    proto.from              = from;
    proto.fromNow           = fromNow;
    proto.to                = to;
    proto.toNow             = toNow;
    proto.get               = stringGet;
    proto.invalidAt         = invalidAt;
    proto.isAfter           = isAfter;
    proto.isBefore          = isBefore;
    proto.isBetween         = isBetween;
    proto.isSame            = isSame;
    proto.isSameOrAfter     = isSameOrAfter;
    proto.isSameOrBefore    = isSameOrBefore;
    proto.isValid           = isValid$2;
    proto.lang              = lang;
    proto.locale            = locale;
    proto.localeData        = localeData;
    proto.max               = prototypeMax;
    proto.min               = prototypeMin;
    proto.parsingFlags      = parsingFlags;
    proto.set               = stringSet;
    proto.startOf           = startOf;
    proto.subtract          = subtract;
    proto.toArray           = toArray;
    proto.toObject          = toObject;
    proto.toDate            = toDate;
    proto.toISOString       = toISOString;
    proto.inspect           = inspect;
    proto.toJSON            = toJSON;
    proto.toString          = toString;
    proto.unix              = unix;
    proto.valueOf           = valueOf;
    proto.creationData      = creationData;
    proto.year       = getSetYear;
    proto.isLeapYear = getIsLeapYear;
    proto.weekYear    = getSetWeekYear;
    proto.isoWeekYear = getSetISOWeekYear;
    proto.quarter = proto.quarters = getSetQuarter;
    proto.month       = getSetMonth;
    proto.daysInMonth = getDaysInMonth;
    proto.week           = proto.weeks        = getSetWeek;
    proto.isoWeek        = proto.isoWeeks     = getSetISOWeek;
    proto.weeksInYear    = getWeeksInYear;
    proto.isoWeeksInYear = getISOWeeksInYear;
    proto.date       = getSetDayOfMonth;
    proto.day        = proto.days             = getSetDayOfWeek;
    proto.weekday    = getSetLocaleDayOfWeek;
    proto.isoWeekday = getSetISODayOfWeek;
    proto.dayOfYear  = getSetDayOfYear;
    proto.hour = proto.hours = getSetHour;
    proto.minute = proto.minutes = getSetMinute;
    proto.second = proto.seconds = getSetSecond;
    proto.millisecond = proto.milliseconds = getSetMillisecond;
    proto.utcOffset            = getSetOffset;
    proto.utc                  = setOffsetToUTC;
    proto.local                = setOffsetToLocal;
    proto.parseZone            = setOffsetToParsedOffset;
    proto.hasAlignedHourOffset = hasAlignedHourOffset;
    proto.isDST                = isDaylightSavingTime;
    proto.isLocal              = isLocal;
    proto.isUtcOffset          = isUtcOffset;
    proto.isUtc                = isUtc;
    proto.isUTC                = isUtc;
    proto.zoneAbbr = getZoneAbbr;
    proto.zoneName = getZoneName;
    proto.dates  = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);
    proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);
    proto.years  = deprecate('years accessor is deprecated. Use year instead', getSetYear);
    proto.zone   = deprecate('moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/', getSetZone);
    proto.isDSTShifted = deprecate('isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information', isDaylightSavingTimeShifted);

    function createUnix (input) {
        return createLocal(input * 1000);
    }

    function createInZone () {
        return createLocal.apply(null, arguments).parseZone();
    }

    function preParsePostFormat (string) {
        return string;
    }

    var proto$1 = Locale.prototype;

    proto$1.calendar        = calendar;
    proto$1.longDateFormat  = longDateFormat;
    proto$1.invalidDate     = invalidDate;
    proto$1.ordinal         = ordinal;
    proto$1.preparse        = preParsePostFormat;
    proto$1.postformat      = preParsePostFormat;
    proto$1.relativeTime    = relativeTime;
    proto$1.pastFuture      = pastFuture;
    proto$1.set             = set;

    proto$1.months            =        localeMonths;
    proto$1.monthsShort       =        localeMonthsShort;
    proto$1.monthsParse       =        localeMonthsParse;
    proto$1.monthsRegex       = monthsRegex;
    proto$1.monthsShortRegex  = monthsShortRegex;
    proto$1.week = localeWeek;
    proto$1.firstDayOfYear = localeFirstDayOfYear;
    proto$1.firstDayOfWeek = localeFirstDayOfWeek;

    proto$1.weekdays       =        localeWeekdays;
    proto$1.weekdaysMin    =        localeWeekdaysMin;
    proto$1.weekdaysShort  =        localeWeekdaysShort;
    proto$1.weekdaysParse  =        localeWeekdaysParse;

    proto$1.weekdaysRegex       =        weekdaysRegex;
    proto$1.weekdaysShortRegex  =        weekdaysShortRegex;
    proto$1.weekdaysMinRegex    =        weekdaysMinRegex;

    proto$1.isPM = localeIsPM;
    proto$1.meridiem = localeMeridiem;

    function get$1 (format, index, field, setter) {
        var locale = getLocale();
        var utc = createUTC().set(setter, index);
        return locale[field](utc, format);
    }

    function listMonthsImpl (format, index, field) {
        if (isNumber(format)) {
            index = format;
            format = undefined;
        }

        format = format || '';

        if (index != null) {
            return get$1(format, index, field, 'month');
        }

        var i;
        var out = [];
        for (i = 0; i < 12; i++) {
            out[i] = get$1(format, i, field, 'month');
        }
        return out;
    }

    // ()
    // (5)
    // (fmt, 5)
    // (fmt)
    // (true)
    // (true, 5)
    // (true, fmt, 5)
    // (true, fmt)
    function listWeekdaysImpl (localeSorted, format, index, field) {
        if (typeof localeSorted === 'boolean') {
            if (isNumber(format)) {
                index = format;
                format = undefined;
            }

            format = format || '';
        } else {
            format = localeSorted;
            index = format;
            localeSorted = false;

            if (isNumber(format)) {
                index = format;
                format = undefined;
            }

            format = format || '';
        }

        var locale = getLocale(),
            shift = localeSorted ? locale._week.dow : 0;

        if (index != null) {
            return get$1(format, (index + shift) % 7, field, 'day');
        }

        var i;
        var out = [];
        for (i = 0; i < 7; i++) {
            out[i] = get$1(format, (i + shift) % 7, field, 'day');
        }
        return out;
    }

    function listMonths (format, index) {
        return listMonthsImpl(format, index, 'months');
    }

    function listMonthsShort (format, index) {
        return listMonthsImpl(format, index, 'monthsShort');
    }

    function listWeekdays (localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdays');
    }

    function listWeekdaysShort (localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');
    }

    function listWeekdaysMin (localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');
    }

    getSetGlobalLocale('en', {
        dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
        ordinal : function (number) {
            var b = number % 10,
                output = (toInt(number % 100 / 10) === 1) ? 'th' :
                (b === 1) ? 'st' :
                (b === 2) ? 'nd' :
                (b === 3) ? 'rd' : 'th';
            return number + output;
        }
    });

    // Side effect imports

    hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', getSetGlobalLocale);
    hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', getLocale);

    var mathAbs = Math.abs;

    function abs () {
        var data           = this._data;

        this._milliseconds = mathAbs(this._milliseconds);
        this._days         = mathAbs(this._days);
        this._months       = mathAbs(this._months);

        data.milliseconds  = mathAbs(data.milliseconds);
        data.seconds       = mathAbs(data.seconds);
        data.minutes       = mathAbs(data.minutes);
        data.hours         = mathAbs(data.hours);
        data.months        = mathAbs(data.months);
        data.years         = mathAbs(data.years);

        return this;
    }

    function addSubtract$1 (duration, input, value, direction) {
        var other = createDuration(input, value);

        duration._milliseconds += direction * other._milliseconds;
        duration._days         += direction * other._days;
        duration._months       += direction * other._months;

        return duration._bubble();
    }

    // supports only 2.0-style add(1, 's') or add(duration)
    function add$1 (input, value) {
        return addSubtract$1(this, input, value, 1);
    }

    // supports only 2.0-style subtract(1, 's') or subtract(duration)
    function subtract$1 (input, value) {
        return addSubtract$1(this, input, value, -1);
    }

    function absCeil (number) {
        if (number < 0) {
            return Math.floor(number);
        } else {
            return Math.ceil(number);
        }
    }

    function bubble () {
        var milliseconds = this._milliseconds;
        var days         = this._days;
        var months       = this._months;
        var data         = this._data;
        var seconds, minutes, hours, years, monthsFromDays;

        // if we have a mix of positive and negative values, bubble down first
        // check: https://github.com/moment/moment/issues/2166
        if (!((milliseconds >= 0 && days >= 0 && months >= 0) ||
                (milliseconds <= 0 && days <= 0 && months <= 0))) {
            milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
            days = 0;
            months = 0;
        }

        // The following code bubbles up values, see the tests for
        // examples of what that means.
        data.milliseconds = milliseconds % 1000;

        seconds           = absFloor(milliseconds / 1000);
        data.seconds      = seconds % 60;

        minutes           = absFloor(seconds / 60);
        data.minutes      = minutes % 60;

        hours             = absFloor(minutes / 60);
        data.hours        = hours % 24;

        days += absFloor(hours / 24);

        // convert days to months
        monthsFromDays = absFloor(daysToMonths(days));
        months += monthsFromDays;
        days -= absCeil(monthsToDays(monthsFromDays));

        // 12 months -> 1 year
        years = absFloor(months / 12);
        months %= 12;

        data.days   = days;
        data.months = months;
        data.years  = years;

        return this;
    }

    function daysToMonths (days) {
        // 400 years have 146097 days (taking into account leap year rules)
        // 400 years have 12 months === 4800
        return days * 4800 / 146097;
    }

    function monthsToDays (months) {
        // the reverse of daysToMonths
        return months * 146097 / 4800;
    }

    function as (units) {
        if (!this.isValid()) {
            return NaN;
        }
        var days;
        var months;
        var milliseconds = this._milliseconds;

        units = normalizeUnits(units);

        if (units === 'month' || units === 'quarter' || units === 'year') {
            days = this._days + milliseconds / 864e5;
            months = this._months + daysToMonths(days);
            switch (units) {
                case 'month':   return months;
                case 'quarter': return months / 3;
                case 'year':    return months / 12;
            }
        } else {
            // handle milliseconds separately because of floating point math errors (issue #1867)
            days = this._days + Math.round(monthsToDays(this._months));
            switch (units) {
                case 'week'   : return days / 7     + milliseconds / 6048e5;
                case 'day'    : return days         + milliseconds / 864e5;
                case 'hour'   : return days * 24    + milliseconds / 36e5;
                case 'minute' : return days * 1440  + milliseconds / 6e4;
                case 'second' : return days * 86400 + milliseconds / 1000;
                // Math.floor prevents floating point math errors here
                case 'millisecond': return Math.floor(days * 864e5) + milliseconds;
                default: throw new Error('Unknown unit ' + units);
            }
        }
    }

    // TODO: Use this.as('ms')?
    function valueOf$1 () {
        if (!this.isValid()) {
            return NaN;
        }
        return (
            this._milliseconds +
            this._days * 864e5 +
            (this._months % 12) * 2592e6 +
            toInt(this._months / 12) * 31536e6
        );
    }

    function makeAs (alias) {
        return function () {
            return this.as(alias);
        };
    }

    var asMilliseconds = makeAs('ms');
    var asSeconds      = makeAs('s');
    var asMinutes      = makeAs('m');
    var asHours        = makeAs('h');
    var asDays         = makeAs('d');
    var asWeeks        = makeAs('w');
    var asMonths       = makeAs('M');
    var asQuarters     = makeAs('Q');
    var asYears        = makeAs('y');

    function clone$1 () {
        return createDuration(this);
    }

    function get$2 (units) {
        units = normalizeUnits(units);
        return this.isValid() ? this[units + 's']() : NaN;
    }

    function makeGetter(name) {
        return function () {
            return this.isValid() ? this._data[name] : NaN;
        };
    }

    var milliseconds = makeGetter('milliseconds');
    var seconds      = makeGetter('seconds');
    var minutes      = makeGetter('minutes');
    var hours        = makeGetter('hours');
    var days         = makeGetter('days');
    var months       = makeGetter('months');
    var years        = makeGetter('years');

    function weeks () {
        return absFloor(this.days() / 7);
    }

    var round = Math.round;
    var thresholds = {
        ss: 44,         // a few seconds to seconds
        s : 45,         // seconds to minute
        m : 45,         // minutes to hour
        h : 22,         // hours to day
        d : 26,         // days to month
        M : 11          // months to year
    };

    // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
        return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
    }

    function relativeTime$1 (posNegDuration, withoutSuffix, locale) {
        var duration = createDuration(posNegDuration).abs();
        var seconds  = round(duration.as('s'));
        var minutes  = round(duration.as('m'));
        var hours    = round(duration.as('h'));
        var days     = round(duration.as('d'));
        var months   = round(duration.as('M'));
        var years    = round(duration.as('y'));

        var a = seconds <= thresholds.ss && ['s', seconds]  ||
                seconds < thresholds.s   && ['ss', seconds] ||
                minutes <= 1             && ['m']           ||
                minutes < thresholds.m   && ['mm', minutes] ||
                hours   <= 1             && ['h']           ||
                hours   < thresholds.h   && ['hh', hours]   ||
                days    <= 1             && ['d']           ||
                days    < thresholds.d   && ['dd', days]    ||
                months  <= 1             && ['M']           ||
                months  < thresholds.M   && ['MM', months]  ||
                years   <= 1             && ['y']           || ['yy', years];

        a[2] = withoutSuffix;
        a[3] = +posNegDuration > 0;
        a[4] = locale;
        return substituteTimeAgo.apply(null, a);
    }

    // This function allows you to set the rounding function for relative time strings
    function getSetRelativeTimeRounding (roundingFunction) {
        if (roundingFunction === undefined) {
            return round;
        }
        if (typeof(roundingFunction) === 'function') {
            round = roundingFunction;
            return true;
        }
        return false;
    }

    // This function allows you to set a threshold for relative time strings
    function getSetRelativeTimeThreshold (threshold, limit) {
        if (thresholds[threshold] === undefined) {
            return false;
        }
        if (limit === undefined) {
            return thresholds[threshold];
        }
        thresholds[threshold] = limit;
        if (threshold === 's') {
            thresholds.ss = limit - 1;
        }
        return true;
    }

    function humanize (withSuffix) {
        if (!this.isValid()) {
            return this.localeData().invalidDate();
        }

        var locale = this.localeData();
        var output = relativeTime$1(this, !withSuffix, locale);

        if (withSuffix) {
            output = locale.pastFuture(+this, output);
        }

        return locale.postformat(output);
    }

    var abs$1 = Math.abs;

    function sign(x) {
        return ((x > 0) - (x < 0)) || +x;
    }

    function toISOString$1() {
        // for ISO strings we do not use the normal bubbling rules:
        //  * milliseconds bubble up until they become hours
        //  * days do not bubble at all
        //  * months bubble up until they become years
        // This is because there is no context-free conversion between hours and days
        // (think of clock changes)
        // and also not between days and months (28-31 days per month)
        if (!this.isValid()) {
            return this.localeData().invalidDate();
        }

        var seconds = abs$1(this._milliseconds) / 1000;
        var days         = abs$1(this._days);
        var months       = abs$1(this._months);
        var minutes, hours, years;

        // 3600 seconds -> 60 minutes -> 1 hour
        minutes           = absFloor(seconds / 60);
        hours             = absFloor(minutes / 60);
        seconds %= 60;
        minutes %= 60;

        // 12 months -> 1 year
        years  = absFloor(months / 12);
        months %= 12;


        // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
        var Y = years;
        var M = months;
        var D = days;
        var h = hours;
        var m = minutes;
        var s = seconds ? seconds.toFixed(3).replace(/\.?0+$/, '') : '';
        var total = this.asSeconds();

        if (!total) {
            // this is the same as C#'s (Noda) and python (isodate)...
            // but not other JS (goog.date)
            return 'P0D';
        }

        var totalSign = total < 0 ? '-' : '';
        var ymSign = sign(this._months) !== sign(total) ? '-' : '';
        var daysSign = sign(this._days) !== sign(total) ? '-' : '';
        var hmsSign = sign(this._milliseconds) !== sign(total) ? '-' : '';

        return totalSign + 'P' +
            (Y ? ymSign + Y + 'Y' : '') +
            (M ? ymSign + M + 'M' : '') +
            (D ? daysSign + D + 'D' : '') +
            ((h || m || s) ? 'T' : '') +
            (h ? hmsSign + h + 'H' : '') +
            (m ? hmsSign + m + 'M' : '') +
            (s ? hmsSign + s + 'S' : '');
    }

    var proto$2 = Duration.prototype;

    proto$2.isValid        = isValid$1;
    proto$2.abs            = abs;
    proto$2.add            = add$1;
    proto$2.subtract       = subtract$1;
    proto$2.as             = as;
    proto$2.asMilliseconds = asMilliseconds;
    proto$2.asSeconds      = asSeconds;
    proto$2.asMinutes      = asMinutes;
    proto$2.asHours        = asHours;
    proto$2.asDays         = asDays;
    proto$2.asWeeks        = asWeeks;
    proto$2.asMonths       = asMonths;
    proto$2.asQuarters     = asQuarters;
    proto$2.asYears        = asYears;
    proto$2.valueOf        = valueOf$1;
    proto$2._bubble        = bubble;
    proto$2.clone          = clone$1;
    proto$2.get            = get$2;
    proto$2.milliseconds   = milliseconds;
    proto$2.seconds        = seconds;
    proto$2.minutes        = minutes;
    proto$2.hours          = hours;
    proto$2.days           = days;
    proto$2.weeks          = weeks;
    proto$2.months         = months;
    proto$2.years          = years;
    proto$2.humanize       = humanize;
    proto$2.toISOString    = toISOString$1;
    proto$2.toString       = toISOString$1;
    proto$2.toJSON         = toISOString$1;
    proto$2.locale         = locale;
    proto$2.localeData     = localeData;

    proto$2.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', toISOString$1);
    proto$2.lang = lang;

    // Side effect imports

    // FORMATTING

    addFormatToken('X', 0, 0, 'unix');
    addFormatToken('x', 0, 0, 'valueOf');

    // PARSING

    addRegexToken('x', matchSigned);
    addRegexToken('X', matchTimestamp);
    addParseToken('X', function (input, array, config) {
        config._d = new Date(parseFloat(input, 10) * 1000);
    });
    addParseToken('x', function (input, array, config) {
        config._d = new Date(toInt(input));
    });

    // Side effect imports


    hooks.version = '2.24.0';

    setHookCallback(createLocal);

    hooks.fn                    = proto;
    hooks.min                   = min;
    hooks.max                   = max;
    hooks.now                   = now;
    hooks.utc                   = createUTC;
    hooks.unix                  = createUnix;
    hooks.months                = listMonths;
    hooks.isDate                = isDate;
    hooks.locale                = getSetGlobalLocale;
    hooks.invalid               = createInvalid;
    hooks.duration              = createDuration;
    hooks.isMoment              = isMoment;
    hooks.weekdays              = listWeekdays;
    hooks.parseZone             = createInZone;
    hooks.localeData            = getLocale;
    hooks.isDuration            = isDuration;
    hooks.monthsShort           = listMonthsShort;
    hooks.weekdaysMin           = listWeekdaysMin;
    hooks.defineLocale          = defineLocale;
    hooks.updateLocale          = updateLocale;
    hooks.locales               = listLocales;
    hooks.weekdaysShort         = listWeekdaysShort;
    hooks.normalizeUnits        = normalizeUnits;
    hooks.relativeTimeRounding  = getSetRelativeTimeRounding;
    hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
    hooks.calendarFormat        = getCalendarFormat;
    hooks.prototype             = proto;

    // currently HTML5 input type only supports 24-hour formats
    hooks.HTML5_FMT = {
        DATETIME_LOCAL: 'YYYY-MM-DDTHH:mm',             // <input type="datetime-local" />
        DATETIME_LOCAL_SECONDS: 'YYYY-MM-DDTHH:mm:ss',  // <input type="datetime-local" step="1" />
        DATETIME_LOCAL_MS: 'YYYY-MM-DDTHH:mm:ss.SSS',   // <input type="datetime-local" step="0.001" />
        DATE: 'YYYY-MM-DD',                             // <input type="date" />
        TIME: 'HH:mm',                                  // <input type="time" />
        TIME_SECONDS: 'HH:mm:ss',                       // <input type="time" step="1" />
        TIME_MS: 'HH:mm:ss.SSS',                        // <input type="time" step="0.001" />
        WEEK: 'GGGG-[W]WW',                             // <input type="week" />
        MONTH: 'YYYY-MM'                                // <input type="month" />
    };

    return hooks;

})));

},{}],"vendor/chart.js/Chart.min.js":[function(require,module,exports) {
var define;
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/*!
 * Chart.js v2.8.0
 * https://www.chartjs.org
 * (c) 2019 Chart.js Contributors
 * Released under the MIT License
 */
!function (t, e) {
  "object" == (typeof exports === "undefined" ? "undefined" : _typeof(exports)) && "undefined" != typeof module ? module.exports = e(function () {
    try {
      return require("moment");
    } catch (t) {}
  }()) : "function" == typeof define && define.amd ? define(["require"], function (t) {
    return e(function () {
      try {
        return t("moment");
      } catch (t) {}
    }());
  }) : t.Chart = e(t.moment);
}(this, function (t) {
  "use strict";

  t = t && t.hasOwnProperty("default") ? t.default : t;
  var e = {
    rgb2hsl: i,
    rgb2hsv: n,
    rgb2hwb: a,
    rgb2cmyk: o,
    rgb2keyword: s,
    rgb2xyz: l,
    rgb2lab: d,
    rgb2lch: function rgb2lch(t) {
      return x(d(t));
    },
    hsl2rgb: u,
    hsl2hsv: function hsl2hsv(t) {
      var e = t[0],
          i = t[1] / 100,
          n = t[2] / 100;
      if (0 === n) return [0, 0, 0];
      return [e, 100 * (2 * (i *= (n *= 2) <= 1 ? n : 2 - n) / (n + i)), 100 * ((n + i) / 2)];
    },
    hsl2hwb: function hsl2hwb(t) {
      return a(u(t));
    },
    hsl2cmyk: function hsl2cmyk(t) {
      return o(u(t));
    },
    hsl2keyword: function hsl2keyword(t) {
      return s(u(t));
    },
    hsv2rgb: h,
    hsv2hsl: function hsv2hsl(t) {
      var e,
          i,
          n = t[0],
          a = t[1] / 100,
          o = t[2] / 100;
      return e = a * o, [n, 100 * (e = (e /= (i = (2 - a) * o) <= 1 ? i : 2 - i) || 0), 100 * (i /= 2)];
    },
    hsv2hwb: function hsv2hwb(t) {
      return a(h(t));
    },
    hsv2cmyk: function hsv2cmyk(t) {
      return o(h(t));
    },
    hsv2keyword: function hsv2keyword(t) {
      return s(h(t));
    },
    hwb2rgb: c,
    hwb2hsl: function hwb2hsl(t) {
      return i(c(t));
    },
    hwb2hsv: function hwb2hsv(t) {
      return n(c(t));
    },
    hwb2cmyk: function hwb2cmyk(t) {
      return o(c(t));
    },
    hwb2keyword: function hwb2keyword(t) {
      return s(c(t));
    },
    cmyk2rgb: f,
    cmyk2hsl: function cmyk2hsl(t) {
      return i(f(t));
    },
    cmyk2hsv: function cmyk2hsv(t) {
      return n(f(t));
    },
    cmyk2hwb: function cmyk2hwb(t) {
      return a(f(t));
    },
    cmyk2keyword: function cmyk2keyword(t) {
      return s(f(t));
    },
    keyword2rgb: w,
    keyword2hsl: function keyword2hsl(t) {
      return i(w(t));
    },
    keyword2hsv: function keyword2hsv(t) {
      return n(w(t));
    },
    keyword2hwb: function keyword2hwb(t) {
      return a(w(t));
    },
    keyword2cmyk: function keyword2cmyk(t) {
      return o(w(t));
    },
    keyword2lab: function keyword2lab(t) {
      return d(w(t));
    },
    keyword2xyz: function keyword2xyz(t) {
      return l(w(t));
    },
    xyz2rgb: p,
    xyz2lab: m,
    xyz2lch: function xyz2lch(t) {
      return x(m(t));
    },
    lab2xyz: v,
    lab2rgb: y,
    lab2lch: x,
    lch2lab: k,
    lch2xyz: function lch2xyz(t) {
      return v(k(t));
    },
    lch2rgb: function lch2rgb(t) {
      return y(k(t));
    }
  };

  function i(t) {
    var e,
        i,
        n = t[0] / 255,
        a = t[1] / 255,
        o = t[2] / 255,
        r = Math.min(n, a, o),
        s = Math.max(n, a, o),
        l = s - r;
    return s == r ? e = 0 : n == s ? e = (a - o) / l : a == s ? e = 2 + (o - n) / l : o == s && (e = 4 + (n - a) / l), (e = Math.min(60 * e, 360)) < 0 && (e += 360), i = (r + s) / 2, [e, 100 * (s == r ? 0 : i <= .5 ? l / (s + r) : l / (2 - s - r)), 100 * i];
  }

  function n(t) {
    var e,
        i,
        n = t[0],
        a = t[1],
        o = t[2],
        r = Math.min(n, a, o),
        s = Math.max(n, a, o),
        l = s - r;
    return i = 0 == s ? 0 : l / s * 1e3 / 10, s == r ? e = 0 : n == s ? e = (a - o) / l : a == s ? e = 2 + (o - n) / l : o == s && (e = 4 + (n - a) / l), (e = Math.min(60 * e, 360)) < 0 && (e += 360), [e, i, s / 255 * 1e3 / 10];
  }

  function a(t) {
    var e = t[0],
        n = t[1],
        a = t[2];
    return [i(t)[0], 100 * (1 / 255 * Math.min(e, Math.min(n, a))), 100 * (a = 1 - 1 / 255 * Math.max(e, Math.max(n, a)))];
  }

  function o(t) {
    var e,
        i = t[0] / 255,
        n = t[1] / 255,
        a = t[2] / 255;
    return [100 * ((1 - i - (e = Math.min(1 - i, 1 - n, 1 - a))) / (1 - e) || 0), 100 * ((1 - n - e) / (1 - e) || 0), 100 * ((1 - a - e) / (1 - e) || 0), 100 * e];
  }

  function s(t) {
    return _[JSON.stringify(t)];
  }

  function l(t) {
    var e = t[0] / 255,
        i = t[1] / 255,
        n = t[2] / 255;
    return [100 * (.4124 * (e = e > .04045 ? Math.pow((e + .055) / 1.055, 2.4) : e / 12.92) + .3576 * (i = i > .04045 ? Math.pow((i + .055) / 1.055, 2.4) : i / 12.92) + .1805 * (n = n > .04045 ? Math.pow((n + .055) / 1.055, 2.4) : n / 12.92)), 100 * (.2126 * e + .7152 * i + .0722 * n), 100 * (.0193 * e + .1192 * i + .9505 * n)];
  }

  function d(t) {
    var e = l(t),
        i = e[0],
        n = e[1],
        a = e[2];
    return n /= 100, a /= 108.883, i = (i /= 95.047) > .008856 ? Math.pow(i, 1 / 3) : 7.787 * i + 16 / 116, [116 * (n = n > .008856 ? Math.pow(n, 1 / 3) : 7.787 * n + 16 / 116) - 16, 500 * (i - n), 200 * (n - (a = a > .008856 ? Math.pow(a, 1 / 3) : 7.787 * a + 16 / 116))];
  }

  function u(t) {
    var e,
        i,
        n,
        a,
        o,
        r = t[0] / 360,
        s = t[1] / 100,
        l = t[2] / 100;
    if (0 == s) return [o = 255 * l, o, o];
    e = 2 * l - (i = l < .5 ? l * (1 + s) : l + s - l * s), a = [0, 0, 0];

    for (var d = 0; d < 3; d++) {
      (n = r + 1 / 3 * -(d - 1)) < 0 && n++, n > 1 && n--, o = 6 * n < 1 ? e + 6 * (i - e) * n : 2 * n < 1 ? i : 3 * n < 2 ? e + (i - e) * (2 / 3 - n) * 6 : e, a[d] = 255 * o;
    }

    return a;
  }

  function h(t) {
    var e = t[0] / 60,
        i = t[1] / 100,
        n = t[2] / 100,
        a = Math.floor(e) % 6,
        o = e - Math.floor(e),
        r = 255 * n * (1 - i),
        s = 255 * n * (1 - i * o),
        l = 255 * n * (1 - i * (1 - o));
    n *= 255;

    switch (a) {
      case 0:
        return [n, l, r];

      case 1:
        return [s, n, r];

      case 2:
        return [r, n, l];

      case 3:
        return [r, s, n];

      case 4:
        return [l, r, n];

      case 5:
        return [n, r, s];
    }
  }

  function c(t) {
    var e,
        i,
        n,
        a,
        o = t[0] / 360,
        s = t[1] / 100,
        l = t[2] / 100,
        d = s + l;

    switch (d > 1 && (s /= d, l /= d), n = 6 * o - (e = Math.floor(6 * o)), 0 != (1 & e) && (n = 1 - n), a = s + n * ((i = 1 - l) - s), e) {
      default:
      case 6:
      case 0:
        r = i, g = a, b = s;
        break;

      case 1:
        r = a, g = i, b = s;
        break;

      case 2:
        r = s, g = i, b = a;
        break;

      case 3:
        r = s, g = a, b = i;
        break;

      case 4:
        r = a, g = s, b = i;
        break;

      case 5:
        r = i, g = s, b = a;
    }

    return [255 * r, 255 * g, 255 * b];
  }

  function f(t) {
    var e = t[0] / 100,
        i = t[1] / 100,
        n = t[2] / 100,
        a = t[3] / 100;
    return [255 * (1 - Math.min(1, e * (1 - a) + a)), 255 * (1 - Math.min(1, i * (1 - a) + a)), 255 * (1 - Math.min(1, n * (1 - a) + a))];
  }

  function p(t) {
    var e,
        i,
        n,
        a = t[0] / 100,
        o = t[1] / 100,
        r = t[2] / 100;
    return i = -.9689 * a + 1.8758 * o + .0415 * r, n = .0557 * a + -.204 * o + 1.057 * r, e = (e = 3.2406 * a + -1.5372 * o + -.4986 * r) > .0031308 ? 1.055 * Math.pow(e, 1 / 2.4) - .055 : e *= 12.92, i = i > .0031308 ? 1.055 * Math.pow(i, 1 / 2.4) - .055 : i *= 12.92, n = n > .0031308 ? 1.055 * Math.pow(n, 1 / 2.4) - .055 : n *= 12.92, [255 * (e = Math.min(Math.max(0, e), 1)), 255 * (i = Math.min(Math.max(0, i), 1)), 255 * (n = Math.min(Math.max(0, n), 1))];
  }

  function m(t) {
    var e = t[0],
        i = t[1],
        n = t[2];
    return i /= 100, n /= 108.883, e = (e /= 95.047) > .008856 ? Math.pow(e, 1 / 3) : 7.787 * e + 16 / 116, [116 * (i = i > .008856 ? Math.pow(i, 1 / 3) : 7.787 * i + 16 / 116) - 16, 500 * (e - i), 200 * (i - (n = n > .008856 ? Math.pow(n, 1 / 3) : 7.787 * n + 16 / 116))];
  }

  function v(t) {
    var e,
        i,
        n,
        a,
        o = t[0],
        r = t[1],
        s = t[2];
    return o <= 8 ? a = (i = 100 * o / 903.3) / 100 * 7.787 + 16 / 116 : (i = 100 * Math.pow((o + 16) / 116, 3), a = Math.pow(i / 100, 1 / 3)), [e = e / 95.047 <= .008856 ? e = 95.047 * (r / 500 + a - 16 / 116) / 7.787 : 95.047 * Math.pow(r / 500 + a, 3), i, n = n / 108.883 <= .008859 ? n = 108.883 * (a - s / 200 - 16 / 116) / 7.787 : 108.883 * Math.pow(a - s / 200, 3)];
  }

  function x(t) {
    var e,
        i = t[0],
        n = t[1],
        a = t[2];
    return (e = 360 * Math.atan2(a, n) / 2 / Math.PI) < 0 && (e += 360), [i, Math.sqrt(n * n + a * a), e];
  }

  function y(t) {
    return p(v(t));
  }

  function k(t) {
    var e,
        i = t[0],
        n = t[1];
    return e = t[2] / 360 * 2 * Math.PI, [i, n * Math.cos(e), n * Math.sin(e)];
  }

  function w(t) {
    return M[t];
  }

  var M = {
    aliceblue: [240, 248, 255],
    antiquewhite: [250, 235, 215],
    aqua: [0, 255, 255],
    aquamarine: [127, 255, 212],
    azure: [240, 255, 255],
    beige: [245, 245, 220],
    bisque: [255, 228, 196],
    black: [0, 0, 0],
    blanchedalmond: [255, 235, 205],
    blue: [0, 0, 255],
    blueviolet: [138, 43, 226],
    brown: [165, 42, 42],
    burlywood: [222, 184, 135],
    cadetblue: [95, 158, 160],
    chartreuse: [127, 255, 0],
    chocolate: [210, 105, 30],
    coral: [255, 127, 80],
    cornflowerblue: [100, 149, 237],
    cornsilk: [255, 248, 220],
    crimson: [220, 20, 60],
    cyan: [0, 255, 255],
    darkblue: [0, 0, 139],
    darkcyan: [0, 139, 139],
    darkgoldenrod: [184, 134, 11],
    darkgray: [169, 169, 169],
    darkgreen: [0, 100, 0],
    darkgrey: [169, 169, 169],
    darkkhaki: [189, 183, 107],
    darkmagenta: [139, 0, 139],
    darkolivegreen: [85, 107, 47],
    darkorange: [255, 140, 0],
    darkorchid: [153, 50, 204],
    darkred: [139, 0, 0],
    darksalmon: [233, 150, 122],
    darkseagreen: [143, 188, 143],
    darkslateblue: [72, 61, 139],
    darkslategray: [47, 79, 79],
    darkslategrey: [47, 79, 79],
    darkturquoise: [0, 206, 209],
    darkviolet: [148, 0, 211],
    deeppink: [255, 20, 147],
    deepskyblue: [0, 191, 255],
    dimgray: [105, 105, 105],
    dimgrey: [105, 105, 105],
    dodgerblue: [30, 144, 255],
    firebrick: [178, 34, 34],
    floralwhite: [255, 250, 240],
    forestgreen: [34, 139, 34],
    fuchsia: [255, 0, 255],
    gainsboro: [220, 220, 220],
    ghostwhite: [248, 248, 255],
    gold: [255, 215, 0],
    goldenrod: [218, 165, 32],
    gray: [128, 128, 128],
    green: [0, 128, 0],
    greenyellow: [173, 255, 47],
    grey: [128, 128, 128],
    honeydew: [240, 255, 240],
    hotpink: [255, 105, 180],
    indianred: [205, 92, 92],
    indigo: [75, 0, 130],
    ivory: [255, 255, 240],
    khaki: [240, 230, 140],
    lavender: [230, 230, 250],
    lavenderblush: [255, 240, 245],
    lawngreen: [124, 252, 0],
    lemonchiffon: [255, 250, 205],
    lightblue: [173, 216, 230],
    lightcoral: [240, 128, 128],
    lightcyan: [224, 255, 255],
    lightgoldenrodyellow: [250, 250, 210],
    lightgray: [211, 211, 211],
    lightgreen: [144, 238, 144],
    lightgrey: [211, 211, 211],
    lightpink: [255, 182, 193],
    lightsalmon: [255, 160, 122],
    lightseagreen: [32, 178, 170],
    lightskyblue: [135, 206, 250],
    lightslategray: [119, 136, 153],
    lightslategrey: [119, 136, 153],
    lightsteelblue: [176, 196, 222],
    lightyellow: [255, 255, 224],
    lime: [0, 255, 0],
    limegreen: [50, 205, 50],
    linen: [250, 240, 230],
    magenta: [255, 0, 255],
    maroon: [128, 0, 0],
    mediumaquamarine: [102, 205, 170],
    mediumblue: [0, 0, 205],
    mediumorchid: [186, 85, 211],
    mediumpurple: [147, 112, 219],
    mediumseagreen: [60, 179, 113],
    mediumslateblue: [123, 104, 238],
    mediumspringgreen: [0, 250, 154],
    mediumturquoise: [72, 209, 204],
    mediumvioletred: [199, 21, 133],
    midnightblue: [25, 25, 112],
    mintcream: [245, 255, 250],
    mistyrose: [255, 228, 225],
    moccasin: [255, 228, 181],
    navajowhite: [255, 222, 173],
    navy: [0, 0, 128],
    oldlace: [253, 245, 230],
    olive: [128, 128, 0],
    olivedrab: [107, 142, 35],
    orange: [255, 165, 0],
    orangered: [255, 69, 0],
    orchid: [218, 112, 214],
    palegoldenrod: [238, 232, 170],
    palegreen: [152, 251, 152],
    paleturquoise: [175, 238, 238],
    palevioletred: [219, 112, 147],
    papayawhip: [255, 239, 213],
    peachpuff: [255, 218, 185],
    peru: [205, 133, 63],
    pink: [255, 192, 203],
    plum: [221, 160, 221],
    powderblue: [176, 224, 230],
    purple: [128, 0, 128],
    rebeccapurple: [102, 51, 153],
    red: [255, 0, 0],
    rosybrown: [188, 143, 143],
    royalblue: [65, 105, 225],
    saddlebrown: [139, 69, 19],
    salmon: [250, 128, 114],
    sandybrown: [244, 164, 96],
    seagreen: [46, 139, 87],
    seashell: [255, 245, 238],
    sienna: [160, 82, 45],
    silver: [192, 192, 192],
    skyblue: [135, 206, 235],
    slateblue: [106, 90, 205],
    slategray: [112, 128, 144],
    slategrey: [112, 128, 144],
    snow: [255, 250, 250],
    springgreen: [0, 255, 127],
    steelblue: [70, 130, 180],
    tan: [210, 180, 140],
    teal: [0, 128, 128],
    thistle: [216, 191, 216],
    tomato: [255, 99, 71],
    turquoise: [64, 224, 208],
    violet: [238, 130, 238],
    wheat: [245, 222, 179],
    white: [255, 255, 255],
    whitesmoke: [245, 245, 245],
    yellow: [255, 255, 0],
    yellowgreen: [154, 205, 50]
  },
      _ = {};

  for (var C in M) {
    _[JSON.stringify(M[C])] = C;
  }

  var S = function S() {
    return new T();
  };

  for (var P in e) {
    S[P + "Raw"] = function (t) {
      return function (i) {
        return "number" == typeof i && (i = Array.prototype.slice.call(arguments)), e[t](i);
      };
    }(P);

    var I = /(\w+)2(\w+)/.exec(P),
        A = I[1],
        D = I[2];

    (S[A] = S[A] || {})[D] = S[P] = function (t) {
      return function (i) {
        "number" == typeof i && (i = Array.prototype.slice.call(arguments));
        var n = e[t](i);
        if ("string" == typeof n || void 0 === n) return n;

        for (var a = 0; a < n.length; a++) {
          n[a] = Math.round(n[a]);
        }

        return n;
      };
    }(P);
  }

  var T = function T() {
    this.convs = {};
  };

  T.prototype.routeSpace = function (t, e) {
    var i = e[0];
    return void 0 === i ? this.getValues(t) : ("number" == typeof i && (i = Array.prototype.slice.call(e)), this.setValues(t, i));
  }, T.prototype.setValues = function (t, e) {
    return this.space = t, this.convs = {}, this.convs[t] = e, this;
  }, T.prototype.getValues = function (t) {
    var e = this.convs[t];

    if (!e) {
      var i = this.space,
          n = this.convs[i];
      e = S[i][t](n), this.convs[t] = e;
    }

    return e;
  }, ["rgb", "hsl", "hsv", "cmyk", "keyword"].forEach(function (t) {
    T.prototype[t] = function (e) {
      return this.routeSpace(t, arguments);
    };
  });
  var F = S,
      L = {
    aliceblue: [240, 248, 255],
    antiquewhite: [250, 235, 215],
    aqua: [0, 255, 255],
    aquamarine: [127, 255, 212],
    azure: [240, 255, 255],
    beige: [245, 245, 220],
    bisque: [255, 228, 196],
    black: [0, 0, 0],
    blanchedalmond: [255, 235, 205],
    blue: [0, 0, 255],
    blueviolet: [138, 43, 226],
    brown: [165, 42, 42],
    burlywood: [222, 184, 135],
    cadetblue: [95, 158, 160],
    chartreuse: [127, 255, 0],
    chocolate: [210, 105, 30],
    coral: [255, 127, 80],
    cornflowerblue: [100, 149, 237],
    cornsilk: [255, 248, 220],
    crimson: [220, 20, 60],
    cyan: [0, 255, 255],
    darkblue: [0, 0, 139],
    darkcyan: [0, 139, 139],
    darkgoldenrod: [184, 134, 11],
    darkgray: [169, 169, 169],
    darkgreen: [0, 100, 0],
    darkgrey: [169, 169, 169],
    darkkhaki: [189, 183, 107],
    darkmagenta: [139, 0, 139],
    darkolivegreen: [85, 107, 47],
    darkorange: [255, 140, 0],
    darkorchid: [153, 50, 204],
    darkred: [139, 0, 0],
    darksalmon: [233, 150, 122],
    darkseagreen: [143, 188, 143],
    darkslateblue: [72, 61, 139],
    darkslategray: [47, 79, 79],
    darkslategrey: [47, 79, 79],
    darkturquoise: [0, 206, 209],
    darkviolet: [148, 0, 211],
    deeppink: [255, 20, 147],
    deepskyblue: [0, 191, 255],
    dimgray: [105, 105, 105],
    dimgrey: [105, 105, 105],
    dodgerblue: [30, 144, 255],
    firebrick: [178, 34, 34],
    floralwhite: [255, 250, 240],
    forestgreen: [34, 139, 34],
    fuchsia: [255, 0, 255],
    gainsboro: [220, 220, 220],
    ghostwhite: [248, 248, 255],
    gold: [255, 215, 0],
    goldenrod: [218, 165, 32],
    gray: [128, 128, 128],
    green: [0, 128, 0],
    greenyellow: [173, 255, 47],
    grey: [128, 128, 128],
    honeydew: [240, 255, 240],
    hotpink: [255, 105, 180],
    indianred: [205, 92, 92],
    indigo: [75, 0, 130],
    ivory: [255, 255, 240],
    khaki: [240, 230, 140],
    lavender: [230, 230, 250],
    lavenderblush: [255, 240, 245],
    lawngreen: [124, 252, 0],
    lemonchiffon: [255, 250, 205],
    lightblue: [173, 216, 230],
    lightcoral: [240, 128, 128],
    lightcyan: [224, 255, 255],
    lightgoldenrodyellow: [250, 250, 210],
    lightgray: [211, 211, 211],
    lightgreen: [144, 238, 144],
    lightgrey: [211, 211, 211],
    lightpink: [255, 182, 193],
    lightsalmon: [255, 160, 122],
    lightseagreen: [32, 178, 170],
    lightskyblue: [135, 206, 250],
    lightslategray: [119, 136, 153],
    lightslategrey: [119, 136, 153],
    lightsteelblue: [176, 196, 222],
    lightyellow: [255, 255, 224],
    lime: [0, 255, 0],
    limegreen: [50, 205, 50],
    linen: [250, 240, 230],
    magenta: [255, 0, 255],
    maroon: [128, 0, 0],
    mediumaquamarine: [102, 205, 170],
    mediumblue: [0, 0, 205],
    mediumorchid: [186, 85, 211],
    mediumpurple: [147, 112, 219],
    mediumseagreen: [60, 179, 113],
    mediumslateblue: [123, 104, 238],
    mediumspringgreen: [0, 250, 154],
    mediumturquoise: [72, 209, 204],
    mediumvioletred: [199, 21, 133],
    midnightblue: [25, 25, 112],
    mintcream: [245, 255, 250],
    mistyrose: [255, 228, 225],
    moccasin: [255, 228, 181],
    navajowhite: [255, 222, 173],
    navy: [0, 0, 128],
    oldlace: [253, 245, 230],
    olive: [128, 128, 0],
    olivedrab: [107, 142, 35],
    orange: [255, 165, 0],
    orangered: [255, 69, 0],
    orchid: [218, 112, 214],
    palegoldenrod: [238, 232, 170],
    palegreen: [152, 251, 152],
    paleturquoise: [175, 238, 238],
    palevioletred: [219, 112, 147],
    papayawhip: [255, 239, 213],
    peachpuff: [255, 218, 185],
    peru: [205, 133, 63],
    pink: [255, 192, 203],
    plum: [221, 160, 221],
    powderblue: [176, 224, 230],
    purple: [128, 0, 128],
    rebeccapurple: [102, 51, 153],
    red: [255, 0, 0],
    rosybrown: [188, 143, 143],
    royalblue: [65, 105, 225],
    saddlebrown: [139, 69, 19],
    salmon: [250, 128, 114],
    sandybrown: [244, 164, 96],
    seagreen: [46, 139, 87],
    seashell: [255, 245, 238],
    sienna: [160, 82, 45],
    silver: [192, 192, 192],
    skyblue: [135, 206, 235],
    slateblue: [106, 90, 205],
    slategray: [112, 128, 144],
    slategrey: [112, 128, 144],
    snow: [255, 250, 250],
    springgreen: [0, 255, 127],
    steelblue: [70, 130, 180],
    tan: [210, 180, 140],
    teal: [0, 128, 128],
    thistle: [216, 191, 216],
    tomato: [255, 99, 71],
    turquoise: [64, 224, 208],
    violet: [238, 130, 238],
    wheat: [245, 222, 179],
    white: [255, 255, 255],
    whitesmoke: [245, 245, 245],
    yellow: [255, 255, 0],
    yellowgreen: [154, 205, 50]
  },
      R = {
    getRgba: O,
    getHsla: z,
    getRgb: function getRgb(t) {
      var e = O(t);
      return e && e.slice(0, 3);
    },
    getHsl: function getHsl(t) {
      var e = z(t);
      return e && e.slice(0, 3);
    },
    getHwb: B,
    getAlpha: function getAlpha(t) {
      var e = O(t);
      if (e) return e[3];
      if (e = z(t)) return e[3];
      if (e = B(t)) return e[3];
    },
    hexString: function hexString(t, e) {
      var e = void 0 !== e && 3 === t.length ? e : t[3];
      return "#" + H(t[0]) + H(t[1]) + H(t[2]) + (e >= 0 && e < 1 ? H(Math.round(255 * e)) : "");
    },
    rgbString: function rgbString(t, e) {
      if (e < 1 || t[3] && t[3] < 1) return N(t, e);
      return "rgb(" + t[0] + ", " + t[1] + ", " + t[2] + ")";
    },
    rgbaString: N,
    percentString: function percentString(t, e) {
      if (e < 1 || t[3] && t[3] < 1) return W(t, e);
      var i = Math.round(t[0] / 255 * 100),
          n = Math.round(t[1] / 255 * 100),
          a = Math.round(t[2] / 255 * 100);
      return "rgb(" + i + "%, " + n + "%, " + a + "%)";
    },
    percentaString: W,
    hslString: function hslString(t, e) {
      if (e < 1 || t[3] && t[3] < 1) return V(t, e);
      return "hsl(" + t[0] + ", " + t[1] + "%, " + t[2] + "%)";
    },
    hslaString: V,
    hwbString: function hwbString(t, e) {
      void 0 === e && (e = void 0 !== t[3] ? t[3] : 1);
      return "hwb(" + t[0] + ", " + t[1] + "%, " + t[2] + "%" + (void 0 !== e && 1 !== e ? ", " + e : "") + ")";
    },
    keyword: function keyword(t) {
      return j[t.slice(0, 3)];
    }
  };

  function O(t) {
    if (t) {
      var e = [0, 0, 0],
          i = 1,
          n = t.match(/^#([a-fA-F0-9]{3,4})$/i),
          a = "";

      if (n) {
        a = (n = n[1])[3];

        for (var o = 0; o < e.length; o++) {
          e[o] = parseInt(n[o] + n[o], 16);
        }

        a && (i = Math.round(parseInt(a + a, 16) / 255 * 100) / 100);
      } else if (n = t.match(/^#([a-fA-F0-9]{6}([a-fA-F0-9]{2})?)$/i)) {
        a = n[2], n = n[1];

        for (o = 0; o < e.length; o++) {
          e[o] = parseInt(n.slice(2 * o, 2 * o + 2), 16);
        }

        a && (i = Math.round(parseInt(a, 16) / 255 * 100) / 100);
      } else if (n = t.match(/^rgba?\(\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/i)) {
        for (o = 0; o < e.length; o++) {
          e[o] = parseInt(n[o + 1]);
        }

        i = parseFloat(n[4]);
      } else if (n = t.match(/^rgba?\(\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/i)) {
        for (o = 0; o < e.length; o++) {
          e[o] = Math.round(2.55 * parseFloat(n[o + 1]));
        }

        i = parseFloat(n[4]);
      } else if (n = t.match(/(\w+)/)) {
        if ("transparent" == n[1]) return [0, 0, 0, 0];
        if (!(e = L[n[1]])) return;
      }

      for (o = 0; o < e.length; o++) {
        e[o] = E(e[o], 0, 255);
      }

      return i = i || 0 == i ? E(i, 0, 1) : 1, e[3] = i, e;
    }
  }

  function z(t) {
    if (t) {
      var e = t.match(/^hsla?\(\s*([+-]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)/);

      if (e) {
        var i = parseFloat(e[4]);
        return [E(parseInt(e[1]), 0, 360), E(parseFloat(e[2]), 0, 100), E(parseFloat(e[3]), 0, 100), E(isNaN(i) ? 1 : i, 0, 1)];
      }
    }
  }

  function B(t) {
    if (t) {
      var e = t.match(/^hwb\(\s*([+-]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)/);

      if (e) {
        var i = parseFloat(e[4]);
        return [E(parseInt(e[1]), 0, 360), E(parseFloat(e[2]), 0, 100), E(parseFloat(e[3]), 0, 100), E(isNaN(i) ? 1 : i, 0, 1)];
      }
    }
  }

  function N(t, e) {
    return void 0 === e && (e = void 0 !== t[3] ? t[3] : 1), "rgba(" + t[0] + ", " + t[1] + ", " + t[2] + ", " + e + ")";
  }

  function W(t, e) {
    return "rgba(" + Math.round(t[0] / 255 * 100) + "%, " + Math.round(t[1] / 255 * 100) + "%, " + Math.round(t[2] / 255 * 100) + "%, " + (e || t[3] || 1) + ")";
  }

  function V(t, e) {
    return void 0 === e && (e = void 0 !== t[3] ? t[3] : 1), "hsla(" + t[0] + ", " + t[1] + "%, " + t[2] + "%, " + e + ")";
  }

  function E(t, e, i) {
    return Math.min(Math.max(e, t), i);
  }

  function H(t) {
    var e = t.toString(16).toUpperCase();
    return e.length < 2 ? "0" + e : e;
  }

  var j = {};

  for (var q in L) {
    j[L[q]] = q;
  }

  var Y = function Y(t) {
    return t instanceof Y ? t : this instanceof Y ? (this.valid = !1, this.values = {
      rgb: [0, 0, 0],
      hsl: [0, 0, 0],
      hsv: [0, 0, 0],
      hwb: [0, 0, 0],
      cmyk: [0, 0, 0, 0],
      alpha: 1
    }, void ("string" == typeof t ? (e = R.getRgba(t)) ? this.setValues("rgb", e) : (e = R.getHsla(t)) ? this.setValues("hsl", e) : (e = R.getHwb(t)) && this.setValues("hwb", e) : "object" == _typeof(t) && (void 0 !== (e = t).r || void 0 !== e.red ? this.setValues("rgb", e) : void 0 !== e.l || void 0 !== e.lightness ? this.setValues("hsl", e) : void 0 !== e.v || void 0 !== e.value ? this.setValues("hsv", e) : void 0 !== e.w || void 0 !== e.whiteness ? this.setValues("hwb", e) : void 0 === e.c && void 0 === e.cyan || this.setValues("cmyk", e)))) : new Y(t);
    var e;
  };

  Y.prototype = {
    isValid: function isValid() {
      return this.valid;
    },
    rgb: function rgb() {
      return this.setSpace("rgb", arguments);
    },
    hsl: function hsl() {
      return this.setSpace("hsl", arguments);
    },
    hsv: function hsv() {
      return this.setSpace("hsv", arguments);
    },
    hwb: function hwb() {
      return this.setSpace("hwb", arguments);
    },
    cmyk: function cmyk() {
      return this.setSpace("cmyk", arguments);
    },
    rgbArray: function rgbArray() {
      return this.values.rgb;
    },
    hslArray: function hslArray() {
      return this.values.hsl;
    },
    hsvArray: function hsvArray() {
      return this.values.hsv;
    },
    hwbArray: function hwbArray() {
      var t = this.values;
      return 1 !== t.alpha ? t.hwb.concat([t.alpha]) : t.hwb;
    },
    cmykArray: function cmykArray() {
      return this.values.cmyk;
    },
    rgbaArray: function rgbaArray() {
      var t = this.values;
      return t.rgb.concat([t.alpha]);
    },
    hslaArray: function hslaArray() {
      var t = this.values;
      return t.hsl.concat([t.alpha]);
    },
    alpha: function alpha(t) {
      return void 0 === t ? this.values.alpha : (this.setValues("alpha", t), this);
    },
    red: function red(t) {
      return this.setChannel("rgb", 0, t);
    },
    green: function green(t) {
      return this.setChannel("rgb", 1, t);
    },
    blue: function blue(t) {
      return this.setChannel("rgb", 2, t);
    },
    hue: function hue(t) {
      return t && (t = (t %= 360) < 0 ? 360 + t : t), this.setChannel("hsl", 0, t);
    },
    saturation: function saturation(t) {
      return this.setChannel("hsl", 1, t);
    },
    lightness: function lightness(t) {
      return this.setChannel("hsl", 2, t);
    },
    saturationv: function saturationv(t) {
      return this.setChannel("hsv", 1, t);
    },
    whiteness: function whiteness(t) {
      return this.setChannel("hwb", 1, t);
    },
    blackness: function blackness(t) {
      return this.setChannel("hwb", 2, t);
    },
    value: function value(t) {
      return this.setChannel("hsv", 2, t);
    },
    cyan: function cyan(t) {
      return this.setChannel("cmyk", 0, t);
    },
    magenta: function magenta(t) {
      return this.setChannel("cmyk", 1, t);
    },
    yellow: function yellow(t) {
      return this.setChannel("cmyk", 2, t);
    },
    black: function black(t) {
      return this.setChannel("cmyk", 3, t);
    },
    hexString: function hexString() {
      return R.hexString(this.values.rgb);
    },
    rgbString: function rgbString() {
      return R.rgbString(this.values.rgb, this.values.alpha);
    },
    rgbaString: function rgbaString() {
      return R.rgbaString(this.values.rgb, this.values.alpha);
    },
    percentString: function percentString() {
      return R.percentString(this.values.rgb, this.values.alpha);
    },
    hslString: function hslString() {
      return R.hslString(this.values.hsl, this.values.alpha);
    },
    hslaString: function hslaString() {
      return R.hslaString(this.values.hsl, this.values.alpha);
    },
    hwbString: function hwbString() {
      return R.hwbString(this.values.hwb, this.values.alpha);
    },
    keyword: function keyword() {
      return R.keyword(this.values.rgb, this.values.alpha);
    },
    rgbNumber: function rgbNumber() {
      var t = this.values.rgb;
      return t[0] << 16 | t[1] << 8 | t[2];
    },
    luminosity: function luminosity() {
      for (var t = this.values.rgb, e = [], i = 0; i < t.length; i++) {
        var n = t[i] / 255;
        e[i] = n <= .03928 ? n / 12.92 : Math.pow((n + .055) / 1.055, 2.4);
      }

      return .2126 * e[0] + .7152 * e[1] + .0722 * e[2];
    },
    contrast: function contrast(t) {
      var e = this.luminosity(),
          i = t.luminosity();
      return e > i ? (e + .05) / (i + .05) : (i + .05) / (e + .05);
    },
    level: function level(t) {
      var e = this.contrast(t);
      return e >= 7.1 ? "AAA" : e >= 4.5 ? "AA" : "";
    },
    dark: function dark() {
      var t = this.values.rgb;
      return (299 * t[0] + 587 * t[1] + 114 * t[2]) / 1e3 < 128;
    },
    light: function light() {
      return !this.dark();
    },
    negate: function negate() {
      for (var t = [], e = 0; e < 3; e++) {
        t[e] = 255 - this.values.rgb[e];
      }

      return this.setValues("rgb", t), this;
    },
    lighten: function lighten(t) {
      var e = this.values.hsl;
      return e[2] += e[2] * t, this.setValues("hsl", e), this;
    },
    darken: function darken(t) {
      var e = this.values.hsl;
      return e[2] -= e[2] * t, this.setValues("hsl", e), this;
    },
    saturate: function saturate(t) {
      var e = this.values.hsl;
      return e[1] += e[1] * t, this.setValues("hsl", e), this;
    },
    desaturate: function desaturate(t) {
      var e = this.values.hsl;
      return e[1] -= e[1] * t, this.setValues("hsl", e), this;
    },
    whiten: function whiten(t) {
      var e = this.values.hwb;
      return e[1] += e[1] * t, this.setValues("hwb", e), this;
    },
    blacken: function blacken(t) {
      var e = this.values.hwb;
      return e[2] += e[2] * t, this.setValues("hwb", e), this;
    },
    greyscale: function greyscale() {
      var t = this.values.rgb,
          e = .3 * t[0] + .59 * t[1] + .11 * t[2];
      return this.setValues("rgb", [e, e, e]), this;
    },
    clearer: function clearer(t) {
      var e = this.values.alpha;
      return this.setValues("alpha", e - e * t), this;
    },
    opaquer: function opaquer(t) {
      var e = this.values.alpha;
      return this.setValues("alpha", e + e * t), this;
    },
    rotate: function rotate(t) {
      var e = this.values.hsl,
          i = (e[0] + t) % 360;
      return e[0] = i < 0 ? 360 + i : i, this.setValues("hsl", e), this;
    },
    mix: function mix(t, e) {
      var i = t,
          n = void 0 === e ? .5 : e,
          a = 2 * n - 1,
          o = this.alpha() - i.alpha(),
          r = ((a * o == -1 ? a : (a + o) / (1 + a * o)) + 1) / 2,
          s = 1 - r;
      return this.rgb(r * this.red() + s * i.red(), r * this.green() + s * i.green(), r * this.blue() + s * i.blue()).alpha(this.alpha() * n + i.alpha() * (1 - n));
    },
    toJSON: function toJSON() {
      return this.rgb();
    },
    clone: function clone() {
      var t,
          e,
          i = new Y(),
          n = this.values,
          a = i.values;

      for (var o in n) {
        n.hasOwnProperty(o) && (t = n[o], "[object Array]" === (e = {}.toString.call(t)) ? a[o] = t.slice(0) : "[object Number]" === e ? a[o] = t : console.error("unexpected color value:", t));
      }

      return i;
    }
  }, Y.prototype.spaces = {
    rgb: ["red", "green", "blue"],
    hsl: ["hue", "saturation", "lightness"],
    hsv: ["hue", "saturation", "value"],
    hwb: ["hue", "whiteness", "blackness"],
    cmyk: ["cyan", "magenta", "yellow", "black"]
  }, Y.prototype.maxes = {
    rgb: [255, 255, 255],
    hsl: [360, 100, 100],
    hsv: [360, 100, 100],
    hwb: [360, 100, 100],
    cmyk: [100, 100, 100, 100]
  }, Y.prototype.getValues = function (t) {
    for (var e = this.values, i = {}, n = 0; n < t.length; n++) {
      i[t.charAt(n)] = e[t][n];
    }

    return 1 !== e.alpha && (i.a = e.alpha), i;
  }, Y.prototype.setValues = function (t, e) {
    var i,
        n,
        a = this.values,
        o = this.spaces,
        r = this.maxes,
        s = 1;
    if (this.valid = !0, "alpha" === t) s = e;else if (e.length) a[t] = e.slice(0, t.length), s = e[t.length];else if (void 0 !== e[t.charAt(0)]) {
      for (i = 0; i < t.length; i++) {
        a[t][i] = e[t.charAt(i)];
      }

      s = e.a;
    } else if (void 0 !== e[o[t][0]]) {
      var l = o[t];

      for (i = 0; i < t.length; i++) {
        a[t][i] = e[l[i]];
      }

      s = e.alpha;
    }
    if (a.alpha = Math.max(0, Math.min(1, void 0 === s ? a.alpha : s)), "alpha" === t) return !1;

    for (i = 0; i < t.length; i++) {
      n = Math.max(0, Math.min(r[t][i], a[t][i])), a[t][i] = Math.round(n);
    }

    for (var d in o) {
      d !== t && (a[d] = F[t][d](a[t]));
    }

    return !0;
  }, Y.prototype.setSpace = function (t, e) {
    var i = e[0];
    return void 0 === i ? this.getValues(t) : ("number" == typeof i && (i = Array.prototype.slice.call(e)), this.setValues(t, i), this);
  }, Y.prototype.setChannel = function (t, e, i) {
    var n = this.values[t];
    return void 0 === i ? n[e] : i === n[e] ? this : (n[e] = i, this.setValues(t, n), this);
  }, "undefined" != typeof window && (window.Color = Y);
  var U,
      X = Y,
      K = {
    noop: function noop() {},
    uid: (U = 0, function () {
      return U++;
    }),
    isNullOrUndef: function isNullOrUndef(t) {
      return null == t;
    },
    isArray: function isArray(t) {
      if (Array.isArray && Array.isArray(t)) return !0;
      var e = Object.prototype.toString.call(t);
      return "[object" === e.substr(0, 7) && "Array]" === e.substr(-6);
    },
    isObject: function isObject(t) {
      return null !== t && "[object Object]" === Object.prototype.toString.call(t);
    },
    isFinite: function (_isFinite) {
      function isFinite(_x) {
        return _isFinite.apply(this, arguments);
      }

      isFinite.toString = function () {
        return _isFinite.toString();
      };

      return isFinite;
    }(function (t) {
      return ("number" == typeof t || t instanceof Number) && isFinite(t);
    }),
    valueOrDefault: function valueOrDefault(t, e) {
      return void 0 === t ? e : t;
    },
    valueAtIndexOrDefault: function valueAtIndexOrDefault(t, e, i) {
      return K.valueOrDefault(K.isArray(t) ? t[e] : t, i);
    },
    callback: function callback(t, e, i) {
      if (t && "function" == typeof t.call) return t.apply(i, e);
    },
    each: function each(t, e, i, n) {
      var a, o, r;
      if (K.isArray(t)) {
        if (o = t.length, n) for (a = o - 1; a >= 0; a--) {
          e.call(i, t[a], a);
        } else for (a = 0; a < o; a++) {
          e.call(i, t[a], a);
        }
      } else if (K.isObject(t)) for (o = (r = Object.keys(t)).length, a = 0; a < o; a++) {
        e.call(i, t[r[a]], r[a]);
      }
    },
    arrayEquals: function arrayEquals(t, e) {
      var i, n, a, o;
      if (!t || !e || t.length !== e.length) return !1;

      for (i = 0, n = t.length; i < n; ++i) {
        if (a = t[i], o = e[i], a instanceof Array && o instanceof Array) {
          if (!K.arrayEquals(a, o)) return !1;
        } else if (a !== o) return !1;
      }

      return !0;
    },
    clone: function clone(t) {
      if (K.isArray(t)) return t.map(K.clone);

      if (K.isObject(t)) {
        for (var e = {}, i = Object.keys(t), n = i.length, a = 0; a < n; ++a) {
          e[i[a]] = K.clone(t[i[a]]);
        }

        return e;
      }

      return t;
    },
    _merger: function _merger(t, e, i, n) {
      var a = e[t],
          o = i[t];
      K.isObject(a) && K.isObject(o) ? K.merge(a, o, n) : e[t] = K.clone(o);
    },
    _mergerIf: function _mergerIf(t, e, i) {
      var n = e[t],
          a = i[t];
      K.isObject(n) && K.isObject(a) ? K.mergeIf(n, a) : e.hasOwnProperty(t) || (e[t] = K.clone(a));
    },
    merge: function merge(t, e, i) {
      var n,
          a,
          o,
          r,
          s,
          l = K.isArray(e) ? e : [e],
          d = l.length;
      if (!K.isObject(t)) return t;

      for (n = (i = i || {}).merger || K._merger, a = 0; a < d; ++a) {
        if (e = l[a], K.isObject(e)) for (s = 0, r = (o = Object.keys(e)).length; s < r; ++s) {
          n(o[s], t, e, i);
        }
      }

      return t;
    },
    mergeIf: function mergeIf(t, e) {
      return K.merge(t, e, {
        merger: K._mergerIf
      });
    },
    extend: function extend(t) {
      for (var e = function e(_e2, i) {
        t[i] = _e2;
      }, i = 1, n = arguments.length; i < n; ++i) {
        K.each(arguments[i], e);
      }

      return t;
    },
    inherits: function inherits(t) {
      var e = this,
          i = t && t.hasOwnProperty("constructor") ? t.constructor : function () {
        return e.apply(this, arguments);
      },
          n = function n() {
        this.constructor = i;
      };

      return n.prototype = e.prototype, i.prototype = new n(), i.extend = K.inherits, t && K.extend(i.prototype, t), i.__super__ = e.prototype, i;
    }
  },
      G = K;
  K.callCallback = K.callback, K.indexOf = function (t, e, i) {
    return Array.prototype.indexOf.call(t, e, i);
  }, K.getValueOrDefault = K.valueOrDefault, K.getValueAtIndexOrDefault = K.valueAtIndexOrDefault;
  var Z = {
    linear: function linear(t) {
      return t;
    },
    easeInQuad: function easeInQuad(t) {
      return t * t;
    },
    easeOutQuad: function easeOutQuad(t) {
      return -t * (t - 2);
    },
    easeInOutQuad: function easeInOutQuad(t) {
      return (t /= .5) < 1 ? .5 * t * t : -.5 * (--t * (t - 2) - 1);
    },
    easeInCubic: function easeInCubic(t) {
      return t * t * t;
    },
    easeOutCubic: function easeOutCubic(t) {
      return (t -= 1) * t * t + 1;
    },
    easeInOutCubic: function easeInOutCubic(t) {
      return (t /= .5) < 1 ? .5 * t * t * t : .5 * ((t -= 2) * t * t + 2);
    },
    easeInQuart: function easeInQuart(t) {
      return t * t * t * t;
    },
    easeOutQuart: function easeOutQuart(t) {
      return -((t -= 1) * t * t * t - 1);
    },
    easeInOutQuart: function easeInOutQuart(t) {
      return (t /= .5) < 1 ? .5 * t * t * t * t : -.5 * ((t -= 2) * t * t * t - 2);
    },
    easeInQuint: function easeInQuint(t) {
      return t * t * t * t * t;
    },
    easeOutQuint: function easeOutQuint(t) {
      return (t -= 1) * t * t * t * t + 1;
    },
    easeInOutQuint: function easeInOutQuint(t) {
      return (t /= .5) < 1 ? .5 * t * t * t * t * t : .5 * ((t -= 2) * t * t * t * t + 2);
    },
    easeInSine: function easeInSine(t) {
      return 1 - Math.cos(t * (Math.PI / 2));
    },
    easeOutSine: function easeOutSine(t) {
      return Math.sin(t * (Math.PI / 2));
    },
    easeInOutSine: function easeInOutSine(t) {
      return -.5 * (Math.cos(Math.PI * t) - 1);
    },
    easeInExpo: function easeInExpo(t) {
      return 0 === t ? 0 : Math.pow(2, 10 * (t - 1));
    },
    easeOutExpo: function easeOutExpo(t) {
      return 1 === t ? 1 : 1 - Math.pow(2, -10 * t);
    },
    easeInOutExpo: function easeInOutExpo(t) {
      return 0 === t ? 0 : 1 === t ? 1 : (t /= .5) < 1 ? .5 * Math.pow(2, 10 * (t - 1)) : .5 * (2 - Math.pow(2, -10 * --t));
    },
    easeInCirc: function easeInCirc(t) {
      return t >= 1 ? t : -(Math.sqrt(1 - t * t) - 1);
    },
    easeOutCirc: function easeOutCirc(t) {
      return Math.sqrt(1 - (t -= 1) * t);
    },
    easeInOutCirc: function easeInOutCirc(t) {
      return (t /= .5) < 1 ? -.5 * (Math.sqrt(1 - t * t) - 1) : .5 * (Math.sqrt(1 - (t -= 2) * t) + 1);
    },
    easeInElastic: function easeInElastic(t) {
      var e = 1.70158,
          i = 0,
          n = 1;
      return 0 === t ? 0 : 1 === t ? 1 : (i || (i = .3), n < 1 ? (n = 1, e = i / 4) : e = i / (2 * Math.PI) * Math.asin(1 / n), -n * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - e) * (2 * Math.PI) / i));
    },
    easeOutElastic: function easeOutElastic(t) {
      var e = 1.70158,
          i = 0,
          n = 1;
      return 0 === t ? 0 : 1 === t ? 1 : (i || (i = .3), n < 1 ? (n = 1, e = i / 4) : e = i / (2 * Math.PI) * Math.asin(1 / n), n * Math.pow(2, -10 * t) * Math.sin((t - e) * (2 * Math.PI) / i) + 1);
    },
    easeInOutElastic: function easeInOutElastic(t) {
      var e = 1.70158,
          i = 0,
          n = 1;
      return 0 === t ? 0 : 2 == (t /= .5) ? 1 : (i || (i = .45), n < 1 ? (n = 1, e = i / 4) : e = i / (2 * Math.PI) * Math.asin(1 / n), t < 1 ? n * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - e) * (2 * Math.PI) / i) * -.5 : n * Math.pow(2, -10 * (t -= 1)) * Math.sin((t - e) * (2 * Math.PI) / i) * .5 + 1);
    },
    easeInBack: function easeInBack(t) {
      var e = 1.70158;
      return t * t * ((e + 1) * t - e);
    },
    easeOutBack: function easeOutBack(t) {
      var e = 1.70158;
      return (t -= 1) * t * ((e + 1) * t + e) + 1;
    },
    easeInOutBack: function easeInOutBack(t) {
      var e = 1.70158;
      return (t /= .5) < 1 ? t * t * ((1 + (e *= 1.525)) * t - e) * .5 : .5 * ((t -= 2) * t * ((1 + (e *= 1.525)) * t + e) + 2);
    },
    easeInBounce: function easeInBounce(t) {
      return 1 - Z.easeOutBounce(1 - t);
    },
    easeOutBounce: function easeOutBounce(t) {
      return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375;
    },
    easeInOutBounce: function easeInOutBounce(t) {
      return t < .5 ? .5 * Z.easeInBounce(2 * t) : .5 * Z.easeOutBounce(2 * t - 1) + .5;
    }
  },
      $ = {
    effects: Z
  };
  G.easingEffects = Z;
  var J = Math.PI,
      Q = J / 180,
      tt = 2 * J,
      et = J / 2,
      it = J / 4,
      nt = 2 * J / 3,
      at = {
    clear: function clear(t) {
      t.ctx.clearRect(0, 0, t.width, t.height);
    },
    roundedRect: function roundedRect(t, e, i, n, a, o) {
      if (o) {
        var r = Math.min(o, a / 2, n / 2),
            s = e + r,
            l = i + r,
            d = e + n - r,
            u = i + a - r;
        t.moveTo(e, l), s < d && l < u ? (t.arc(s, l, r, -J, -et), t.arc(d, l, r, -et, 0), t.arc(d, u, r, 0, et), t.arc(s, u, r, et, J)) : s < d ? (t.moveTo(s, i), t.arc(d, l, r, -et, et), t.arc(s, l, r, et, J + et)) : l < u ? (t.arc(s, l, r, -J, 0), t.arc(s, u, r, 0, J)) : t.arc(s, l, r, -J, J), t.closePath(), t.moveTo(e, i);
      } else t.rect(e, i, n, a);
    },
    drawPoint: function drawPoint(t, e, i, n, a, o) {
      var r,
          s,
          l,
          d,
          u,
          h = (o || 0) * Q;

      if (!e || "object" != _typeof(e) || "[object HTMLImageElement]" !== (r = e.toString()) && "[object HTMLCanvasElement]" !== r) {
        if (!(isNaN(i) || i <= 0)) {
          switch (t.beginPath(), e) {
            default:
              t.arc(n, a, i, 0, tt), t.closePath();
              break;

            case "triangle":
              t.moveTo(n + Math.sin(h) * i, a - Math.cos(h) * i), h += nt, t.lineTo(n + Math.sin(h) * i, a - Math.cos(h) * i), h += nt, t.lineTo(n + Math.sin(h) * i, a - Math.cos(h) * i), t.closePath();
              break;

            case "rectRounded":
              d = i - (u = .516 * i), s = Math.cos(h + it) * d, l = Math.sin(h + it) * d, t.arc(n - s, a - l, u, h - J, h - et), t.arc(n + l, a - s, u, h - et, h), t.arc(n + s, a + l, u, h, h + et), t.arc(n - l, a + s, u, h + et, h + J), t.closePath();
              break;

            case "rect":
              if (!o) {
                d = Math.SQRT1_2 * i, t.rect(n - d, a - d, 2 * d, 2 * d);
                break;
              }

              h += it;

            case "rectRot":
              s = Math.cos(h) * i, l = Math.sin(h) * i, t.moveTo(n - s, a - l), t.lineTo(n + l, a - s), t.lineTo(n + s, a + l), t.lineTo(n - l, a + s), t.closePath();
              break;

            case "crossRot":
              h += it;

            case "cross":
              s = Math.cos(h) * i, l = Math.sin(h) * i, t.moveTo(n - s, a - l), t.lineTo(n + s, a + l), t.moveTo(n + l, a - s), t.lineTo(n - l, a + s);
              break;

            case "star":
              s = Math.cos(h) * i, l = Math.sin(h) * i, t.moveTo(n - s, a - l), t.lineTo(n + s, a + l), t.moveTo(n + l, a - s), t.lineTo(n - l, a + s), h += it, s = Math.cos(h) * i, l = Math.sin(h) * i, t.moveTo(n - s, a - l), t.lineTo(n + s, a + l), t.moveTo(n + l, a - s), t.lineTo(n - l, a + s);
              break;

            case "line":
              s = Math.cos(h) * i, l = Math.sin(h) * i, t.moveTo(n - s, a - l), t.lineTo(n + s, a + l);
              break;

            case "dash":
              t.moveTo(n, a), t.lineTo(n + Math.cos(h) * i, a + Math.sin(h) * i);
          }

          t.fill(), t.stroke();
        }
      } else t.drawImage(e, n - e.width / 2, a - e.height / 2, e.width, e.height);
    },
    _isPointInArea: function _isPointInArea(t, e) {
      return t.x > e.left - 1e-6 && t.x < e.right + 1e-6 && t.y > e.top - 1e-6 && t.y < e.bottom + 1e-6;
    },
    clipArea: function clipArea(t, e) {
      t.save(), t.beginPath(), t.rect(e.left, e.top, e.right - e.left, e.bottom - e.top), t.clip();
    },
    unclipArea: function unclipArea(t) {
      t.restore();
    },
    lineTo: function lineTo(t, e, i, n) {
      var a = i.steppedLine;

      if (a) {
        if ("middle" === a) {
          var o = (e.x + i.x) / 2;
          t.lineTo(o, n ? i.y : e.y), t.lineTo(o, n ? e.y : i.y);
        } else "after" === a && !n || "after" !== a && n ? t.lineTo(e.x, i.y) : t.lineTo(i.x, e.y);

        t.lineTo(i.x, i.y);
      } else i.tension ? t.bezierCurveTo(n ? e.controlPointPreviousX : e.controlPointNextX, n ? e.controlPointPreviousY : e.controlPointNextY, n ? i.controlPointNextX : i.controlPointPreviousX, n ? i.controlPointNextY : i.controlPointPreviousY, i.x, i.y) : t.lineTo(i.x, i.y);
    }
  },
      ot = at;
  G.clear = at.clear, G.drawRoundedRectangle = function (t) {
    t.beginPath(), at.roundedRect.apply(at, arguments);
  };
  var rt = {
    _set: function _set(t, e) {
      return G.merge(this[t] || (this[t] = {}), e);
    }
  };

  rt._set("global", {
    defaultColor: "rgba(0,0,0,0.1)",
    defaultFontColor: "#666",
    defaultFontFamily: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
    defaultFontSize: 12,
    defaultFontStyle: "normal",
    defaultLineHeight: 1.2,
    showLines: !0
  });

  var st = rt,
      lt = G.valueOrDefault;
  var dt = {
    toLineHeight: function toLineHeight(t, e) {
      var i = ("" + t).match(/^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/);
      if (!i || "normal" === i[1]) return 1.2 * e;

      switch (t = +i[2], i[3]) {
        case "px":
          return t;

        case "%":
          t /= 100;
      }

      return e * t;
    },
    toPadding: function toPadding(t) {
      var e, i, n, a;
      return G.isObject(t) ? (e = +t.top || 0, i = +t.right || 0, n = +t.bottom || 0, a = +t.left || 0) : e = i = n = a = +t || 0, {
        top: e,
        right: i,
        bottom: n,
        left: a,
        height: e + n,
        width: a + i
      };
    },
    _parseFont: function _parseFont(t) {
      var e = st.global,
          i = lt(t.fontSize, e.defaultFontSize),
          n = {
        family: lt(t.fontFamily, e.defaultFontFamily),
        lineHeight: G.options.toLineHeight(lt(t.lineHeight, e.defaultLineHeight), i),
        size: i,
        style: lt(t.fontStyle, e.defaultFontStyle),
        weight: null,
        string: ""
      };
      return n.string = function (t) {
        return !t || G.isNullOrUndef(t.size) || G.isNullOrUndef(t.family) ? null : (t.style ? t.style + " " : "") + (t.weight ? t.weight + " " : "") + t.size + "px " + t.family;
      }(n), n;
    },
    resolve: function resolve(t, e, i) {
      var n, a, o;

      for (n = 0, a = t.length; n < a; ++n) {
        if (void 0 !== (o = t[n]) && (void 0 !== e && "function" == typeof o && (o = o(e)), void 0 !== i && G.isArray(o) && (o = o[i]), void 0 !== o)) return o;
      }
    }
  },
      ut = G,
      ht = $,
      ct = ot,
      ft = dt;
  ut.easing = ht, ut.canvas = ct, ut.options = ft;

  var gt = function gt(t) {
    ut.extend(this, t), this.initialize.apply(this, arguments);
  };

  ut.extend(gt.prototype, {
    initialize: function initialize() {
      this.hidden = !1;
    },
    pivot: function pivot() {
      var t = this;
      return t._view || (t._view = ut.clone(t._model)), t._start = {}, t;
    },
    transition: function transition(t) {
      var e = this,
          i = e._model,
          n = e._start,
          a = e._view;
      return i && 1 !== t ? (a || (a = e._view = {}), n || (n = e._start = {}), function (t, e, i, n) {
        var a,
            o,
            r,
            s,
            l,
            d,
            u,
            h,
            c,
            f = Object.keys(i);

        for (a = 0, o = f.length; a < o; ++a) {
          if (d = i[r = f[a]], e.hasOwnProperty(r) || (e[r] = d), (s = e[r]) !== d && "_" !== r[0]) {
            if (t.hasOwnProperty(r) || (t[r] = s), (u = _typeof(d)) == _typeof(l = t[r])) if ("string" === u) {
              if ((h = X(l)).valid && (c = X(d)).valid) {
                e[r] = c.mix(h, n).rgbString();
                continue;
              }
            } else if (ut.isFinite(l) && ut.isFinite(d)) {
              e[r] = l + (d - l) * n;
              continue;
            }
            e[r] = d;
          }
        }
      }(n, a, i, t), e) : (e._view = i, e._start = null, e);
    },
    tooltipPosition: function tooltipPosition() {
      return {
        x: this._model.x,
        y: this._model.y
      };
    },
    hasValue: function hasValue() {
      return ut.isNumber(this._model.x) && ut.isNumber(this._model.y);
    }
  }), gt.extend = ut.inherits;
  var pt = gt,
      mt = pt.extend({
    chart: null,
    currentStep: 0,
    numSteps: 60,
    easing: "",
    render: null,
    onAnimationProgress: null,
    onAnimationComplete: null
  }),
      vt = mt;
  Object.defineProperty(mt.prototype, "animationObject", {
    get: function get() {
      return this;
    }
  }), Object.defineProperty(mt.prototype, "chartInstance", {
    get: function get() {
      return this.chart;
    },
    set: function set(t) {
      this.chart = t;
    }
  }), st._set("global", {
    animation: {
      duration: 1e3,
      easing: "easeOutQuart",
      onProgress: ut.noop,
      onComplete: ut.noop
    }
  });
  var bt = {
    animations: [],
    request: null,
    addAnimation: function addAnimation(t, e, i, n) {
      var a,
          o,
          r = this.animations;

      for (e.chart = t, e.startTime = Date.now(), e.duration = i, n || (t.animating = !0), a = 0, o = r.length; a < o; ++a) {
        if (r[a].chart === t) return void (r[a] = e);
      }

      r.push(e), 1 === r.length && this.requestAnimationFrame();
    },
    cancelAnimation: function cancelAnimation(t) {
      var e = ut.findIndex(this.animations, function (e) {
        return e.chart === t;
      });
      -1 !== e && (this.animations.splice(e, 1), t.animating = !1);
    },
    requestAnimationFrame: function requestAnimationFrame() {
      var t = this;
      null === t.request && (t.request = ut.requestAnimFrame.call(window, function () {
        t.request = null, t.startDigest();
      }));
    },
    startDigest: function startDigest() {
      this.advance(), this.animations.length > 0 && this.requestAnimationFrame();
    },
    advance: function advance() {
      for (var t, e, i, n, a = this.animations, o = 0; o < a.length;) {
        e = (t = a[o]).chart, i = t.numSteps, n = Math.floor((Date.now() - t.startTime) / t.duration * i) + 1, t.currentStep = Math.min(n, i), ut.callback(t.render, [e, t], e), ut.callback(t.onAnimationProgress, [t], e), t.currentStep >= i ? (ut.callback(t.onAnimationComplete, [t], e), e.animating = !1, a.splice(o, 1)) : ++o;
      }
    }
  },
      xt = ut.options.resolve,
      yt = ["push", "pop", "shift", "splice", "unshift"];

  function kt(t, e) {
    var i = t._chartjs;

    if (i) {
      var n = i.listeners,
          a = n.indexOf(e);
      -1 !== a && n.splice(a, 1), n.length > 0 || (yt.forEach(function (e) {
        delete t[e];
      }), delete t._chartjs);
    }
  }

  var wt = function wt(t, e) {
    this.initialize(t, e);
  };

  ut.extend(wt.prototype, {
    datasetElementType: null,
    dataElementType: null,
    initialize: function initialize(t, e) {
      this.chart = t, this.index = e, this.linkScales(), this.addElements();
    },
    updateIndex: function updateIndex(t) {
      this.index = t;
    },
    linkScales: function linkScales() {
      var t = this,
          e = t.getMeta(),
          i = t.getDataset();
      null !== e.xAxisID && e.xAxisID in t.chart.scales || (e.xAxisID = i.xAxisID || t.chart.options.scales.xAxes[0].id), null !== e.yAxisID && e.yAxisID in t.chart.scales || (e.yAxisID = i.yAxisID || t.chart.options.scales.yAxes[0].id);
    },
    getDataset: function getDataset() {
      return this.chart.data.datasets[this.index];
    },
    getMeta: function getMeta() {
      return this.chart.getDatasetMeta(this.index);
    },
    getScaleForId: function getScaleForId(t) {
      return this.chart.scales[t];
    },
    _getValueScaleId: function _getValueScaleId() {
      return this.getMeta().yAxisID;
    },
    _getIndexScaleId: function _getIndexScaleId() {
      return this.getMeta().xAxisID;
    },
    _getValueScale: function _getValueScale() {
      return this.getScaleForId(this._getValueScaleId());
    },
    _getIndexScale: function _getIndexScale() {
      return this.getScaleForId(this._getIndexScaleId());
    },
    reset: function reset() {
      this.update(!0);
    },
    destroy: function destroy() {
      this._data && kt(this._data, this);
    },
    createMetaDataset: function createMetaDataset() {
      var t = this.datasetElementType;
      return t && new t({
        _chart: this.chart,
        _datasetIndex: this.index
      });
    },
    createMetaData: function createMetaData(t) {
      var e = this.dataElementType;
      return e && new e({
        _chart: this.chart,
        _datasetIndex: this.index,
        _index: t
      });
    },
    addElements: function addElements() {
      var t,
          e,
          i = this.getMeta(),
          n = this.getDataset().data || [],
          a = i.data;

      for (t = 0, e = n.length; t < e; ++t) {
        a[t] = a[t] || this.createMetaData(t);
      }

      i.dataset = i.dataset || this.createMetaDataset();
    },
    addElementAndReset: function addElementAndReset(t) {
      var e = this.createMetaData(t);
      this.getMeta().data.splice(t, 0, e), this.updateElement(e, t, !0);
    },
    buildOrUpdateElements: function buildOrUpdateElements() {
      var t,
          e,
          i = this,
          n = i.getDataset(),
          a = n.data || (n.data = []);
      i._data !== a && (i._data && kt(i._data, i), a && Object.isExtensible(a) && (e = i, (t = a)._chartjs ? t._chartjs.listeners.push(e) : (Object.defineProperty(t, "_chartjs", {
        configurable: !0,
        enumerable: !1,
        value: {
          listeners: [e]
        }
      }), yt.forEach(function (e) {
        var i = "onData" + e.charAt(0).toUpperCase() + e.slice(1),
            n = t[e];
        Object.defineProperty(t, e, {
          configurable: !0,
          enumerable: !1,
          value: function value() {
            var e = Array.prototype.slice.call(arguments),
                a = n.apply(this, e);
            return ut.each(t._chartjs.listeners, function (t) {
              "function" == typeof t[i] && t[i].apply(t, e);
            }), a;
          }
        });
      }))), i._data = a), i.resyncElements();
    },
    update: ut.noop,
    transition: function transition(t) {
      for (var e = this.getMeta(), i = e.data || [], n = i.length, a = 0; a < n; ++a) {
        i[a].transition(t);
      }

      e.dataset && e.dataset.transition(t);
    },
    draw: function draw() {
      var t = this.getMeta(),
          e = t.data || [],
          i = e.length,
          n = 0;

      for (t.dataset && t.dataset.draw(); n < i; ++n) {
        e[n].draw();
      }
    },
    removeHoverStyle: function removeHoverStyle(t) {
      ut.merge(t._model, t.$previousStyle || {}), delete t.$previousStyle;
    },
    setHoverStyle: function setHoverStyle(t) {
      var e = this.chart.data.datasets[t._datasetIndex],
          i = t._index,
          n = t.custom || {},
          a = t._model,
          o = ut.getHoverColor;
      t.$previousStyle = {
        backgroundColor: a.backgroundColor,
        borderColor: a.borderColor,
        borderWidth: a.borderWidth
      }, a.backgroundColor = xt([n.hoverBackgroundColor, e.hoverBackgroundColor, o(a.backgroundColor)], void 0, i), a.borderColor = xt([n.hoverBorderColor, e.hoverBorderColor, o(a.borderColor)], void 0, i), a.borderWidth = xt([n.hoverBorderWidth, e.hoverBorderWidth, a.borderWidth], void 0, i);
    },
    resyncElements: function resyncElements() {
      var t = this.getMeta(),
          e = this.getDataset().data,
          i = t.data.length,
          n = e.length;
      n < i ? t.data.splice(n, i - n) : n > i && this.insertElements(i, n - i);
    },
    insertElements: function insertElements(t, e) {
      for (var i = 0; i < e; ++i) {
        this.addElementAndReset(t + i);
      }
    },
    onDataPush: function onDataPush() {
      var t = arguments.length;
      this.insertElements(this.getDataset().data.length - t, t);
    },
    onDataPop: function onDataPop() {
      this.getMeta().data.pop();
    },
    onDataShift: function onDataShift() {
      this.getMeta().data.shift();
    },
    onDataSplice: function onDataSplice(t, e) {
      this.getMeta().data.splice(t, e), this.insertElements(t, arguments.length - 2);
    },
    onDataUnshift: function onDataUnshift() {
      this.insertElements(0, arguments.length);
    }
  }), wt.extend = ut.inherits;
  var Mt = wt;

  st._set("global", {
    elements: {
      arc: {
        backgroundColor: st.global.defaultColor,
        borderColor: "#fff",
        borderWidth: 2,
        borderAlign: "center"
      }
    }
  });

  var _t = pt.extend({
    inLabelRange: function inLabelRange(t) {
      var e = this._view;
      return !!e && Math.pow(t - e.x, 2) < Math.pow(e.radius + e.hoverRadius, 2);
    },
    inRange: function inRange(t, e) {
      var i = this._view;

      if (i) {
        for (var n = ut.getAngleFromPoint(i, {
          x: t,
          y: e
        }), a = n.angle, o = n.distance, r = i.startAngle, s = i.endAngle; s < r;) {
          s += 2 * Math.PI;
        }

        for (; a > s;) {
          a -= 2 * Math.PI;
        }

        for (; a < r;) {
          a += 2 * Math.PI;
        }

        var l = a >= r && a <= s,
            d = o >= i.innerRadius && o <= i.outerRadius;
        return l && d;
      }

      return !1;
    },
    getCenterPoint: function getCenterPoint() {
      var t = this._view,
          e = (t.startAngle + t.endAngle) / 2,
          i = (t.innerRadius + t.outerRadius) / 2;
      return {
        x: t.x + Math.cos(e) * i,
        y: t.y + Math.sin(e) * i
      };
    },
    getArea: function getArea() {
      var t = this._view;
      return Math.PI * ((t.endAngle - t.startAngle) / (2 * Math.PI)) * (Math.pow(t.outerRadius, 2) - Math.pow(t.innerRadius, 2));
    },
    tooltipPosition: function tooltipPosition() {
      var t = this._view,
          e = t.startAngle + (t.endAngle - t.startAngle) / 2,
          i = (t.outerRadius - t.innerRadius) / 2 + t.innerRadius;
      return {
        x: t.x + Math.cos(e) * i,
        y: t.y + Math.sin(e) * i
      };
    },
    draw: function draw() {
      var t,
          e = this._chart.ctx,
          i = this._view,
          n = i.startAngle,
          a = i.endAngle,
          o = "inner" === i.borderAlign ? .33 : 0;
      e.save(), e.beginPath(), e.arc(i.x, i.y, Math.max(i.outerRadius - o, 0), n, a), e.arc(i.x, i.y, i.innerRadius, a, n, !0), e.closePath(), e.fillStyle = i.backgroundColor, e.fill(), i.borderWidth && ("inner" === i.borderAlign ? (e.beginPath(), t = o / i.outerRadius, e.arc(i.x, i.y, i.outerRadius, n - t, a + t), i.innerRadius > o ? (t = o / i.innerRadius, e.arc(i.x, i.y, i.innerRadius - o, a + t, n - t, !0)) : e.arc(i.x, i.y, o, a + Math.PI / 2, n - Math.PI / 2), e.closePath(), e.clip(), e.beginPath(), e.arc(i.x, i.y, i.outerRadius, n, a), e.arc(i.x, i.y, i.innerRadius, a, n, !0), e.closePath(), e.lineWidth = 2 * i.borderWidth, e.lineJoin = "round") : (e.lineWidth = i.borderWidth, e.lineJoin = "bevel"), e.strokeStyle = i.borderColor, e.stroke()), e.restore();
    }
  }),
      Ct = ut.valueOrDefault,
      St = st.global.defaultColor;

  st._set("global", {
    elements: {
      line: {
        tension: .4,
        backgroundColor: St,
        borderWidth: 3,
        borderColor: St,
        borderCapStyle: "butt",
        borderDash: [],
        borderDashOffset: 0,
        borderJoinStyle: "miter",
        capBezierPoints: !0,
        fill: !0
      }
    }
  });

  var Pt = pt.extend({
    draw: function draw() {
      var t,
          e,
          i,
          n,
          a = this._view,
          o = this._chart.ctx,
          r = a.spanGaps,
          s = this._children.slice(),
          l = st.global,
          d = l.elements.line,
          u = -1;

      for (this._loop && s.length && s.push(s[0]), o.save(), o.lineCap = a.borderCapStyle || d.borderCapStyle, o.setLineDash && o.setLineDash(a.borderDash || d.borderDash), o.lineDashOffset = Ct(a.borderDashOffset, d.borderDashOffset), o.lineJoin = a.borderJoinStyle || d.borderJoinStyle, o.lineWidth = Ct(a.borderWidth, d.borderWidth), o.strokeStyle = a.borderColor || l.defaultColor, o.beginPath(), u = -1, t = 0; t < s.length; ++t) {
        e = s[t], i = ut.previousItem(s, t), n = e._view, 0 === t ? n.skip || (o.moveTo(n.x, n.y), u = t) : (i = -1 === u ? i : s[u], n.skip || (u !== t - 1 && !r || -1 === u ? o.moveTo(n.x, n.y) : ut.canvas.lineTo(o, i._view, e._view), u = t));
      }

      o.stroke(), o.restore();
    }
  }),
      It = ut.valueOrDefault,
      At = st.global.defaultColor;

  function Dt(t) {
    var e = this._view;
    return !!e && Math.abs(t - e.x) < e.radius + e.hitRadius;
  }

  st._set("global", {
    elements: {
      point: {
        radius: 3,
        pointStyle: "circle",
        backgroundColor: At,
        borderColor: At,
        borderWidth: 1,
        hitRadius: 1,
        hoverRadius: 4,
        hoverBorderWidth: 1
      }
    }
  });

  var Tt = pt.extend({
    inRange: function inRange(t, e) {
      var i = this._view;
      return !!i && Math.pow(t - i.x, 2) + Math.pow(e - i.y, 2) < Math.pow(i.hitRadius + i.radius, 2);
    },
    inLabelRange: Dt,
    inXRange: Dt,
    inYRange: function inYRange(t) {
      var e = this._view;
      return !!e && Math.abs(t - e.y) < e.radius + e.hitRadius;
    },
    getCenterPoint: function getCenterPoint() {
      var t = this._view;
      return {
        x: t.x,
        y: t.y
      };
    },
    getArea: function getArea() {
      return Math.PI * Math.pow(this._view.radius, 2);
    },
    tooltipPosition: function tooltipPosition() {
      var t = this._view;
      return {
        x: t.x,
        y: t.y,
        padding: t.radius + t.borderWidth
      };
    },
    draw: function draw(t) {
      var e = this._view,
          i = this._chart.ctx,
          n = e.pointStyle,
          a = e.rotation,
          o = e.radius,
          r = e.x,
          s = e.y,
          l = st.global,
          d = l.defaultColor;
      e.skip || (void 0 === t || ut.canvas._isPointInArea(e, t)) && (i.strokeStyle = e.borderColor || d, i.lineWidth = It(e.borderWidth, l.elements.point.borderWidth), i.fillStyle = e.backgroundColor || d, ut.canvas.drawPoint(i, n, o, r, s, a));
    }
  }),
      Ft = st.global.defaultColor;

  function Lt(t) {
    return t && void 0 !== t.width;
  }

  function Rt(t) {
    var e, i, n, a, o;
    return Lt(t) ? (o = t.width / 2, e = t.x - o, i = t.x + o, n = Math.min(t.y, t.base), a = Math.max(t.y, t.base)) : (o = t.height / 2, e = Math.min(t.x, t.base), i = Math.max(t.x, t.base), n = t.y - o, a = t.y + o), {
      left: e,
      top: n,
      right: i,
      bottom: a
    };
  }

  function Ot(t, e, i) {
    return t === e ? i : t === i ? e : t;
  }

  function zt(t, e, i) {
    var n,
        a,
        o,
        r,
        s = t.borderWidth,
        l = function (t) {
      var e = t.borderSkipped,
          i = {};
      return e ? (t.horizontal ? t.base > t.x && (e = Ot(e, "left", "right")) : t.base < t.y && (e = Ot(e, "bottom", "top")), i[e] = !0, i) : i;
    }(t);

    return ut.isObject(s) ? (n = +s.top || 0, a = +s.right || 0, o = +s.bottom || 0, r = +s.left || 0) : n = a = o = r = +s || 0, {
      t: l.top || n < 0 ? 0 : n > i ? i : n,
      r: l.right || a < 0 ? 0 : a > e ? e : a,
      b: l.bottom || o < 0 ? 0 : o > i ? i : o,
      l: l.left || r < 0 ? 0 : r > e ? e : r
    };
  }

  function Bt(t, e, i) {
    var n = null === e,
        a = null === i,
        o = !(!t || n && a) && Rt(t);
    return o && (n || e >= o.left && e <= o.right) && (a || i >= o.top && i <= o.bottom);
  }

  st._set("global", {
    elements: {
      rectangle: {
        backgroundColor: Ft,
        borderColor: Ft,
        borderSkipped: "bottom",
        borderWidth: 0
      }
    }
  });

  var Nt = pt.extend({
    draw: function draw() {
      var t = this._chart.ctx,
          e = this._view,
          i = function (t) {
        var e = Rt(t),
            i = e.right - e.left,
            n = e.bottom - e.top,
            a = zt(t, i / 2, n / 2);
        return {
          outer: {
            x: e.left,
            y: e.top,
            w: i,
            h: n
          },
          inner: {
            x: e.left + a.l,
            y: e.top + a.t,
            w: i - a.l - a.r,
            h: n - a.t - a.b
          }
        };
      }(e),
          n = i.outer,
          a = i.inner;

      t.fillStyle = e.backgroundColor, t.fillRect(n.x, n.y, n.w, n.h), n.w === a.w && n.h === a.h || (t.save(), t.beginPath(), t.rect(n.x, n.y, n.w, n.h), t.clip(), t.fillStyle = e.borderColor, t.rect(a.x, a.y, a.w, a.h), t.fill("evenodd"), t.restore());
    },
    height: function height() {
      var t = this._view;
      return t.base - t.y;
    },
    inRange: function inRange(t, e) {
      return Bt(this._view, t, e);
    },
    inLabelRange: function inLabelRange(t, e) {
      var i = this._view;
      return Lt(i) ? Bt(i, t, null) : Bt(i, null, e);
    },
    inXRange: function inXRange(t) {
      return Bt(this._view, t, null);
    },
    inYRange: function inYRange(t) {
      return Bt(this._view, null, t);
    },
    getCenterPoint: function getCenterPoint() {
      var t,
          e,
          i = this._view;
      return Lt(i) ? (t = i.x, e = (i.y + i.base) / 2) : (t = (i.x + i.base) / 2, e = i.y), {
        x: t,
        y: e
      };
    },
    getArea: function getArea() {
      var t = this._view;
      return Lt(t) ? t.width * Math.abs(t.y - t.base) : t.height * Math.abs(t.x - t.base);
    },
    tooltipPosition: function tooltipPosition() {
      var t = this._view;
      return {
        x: t.x,
        y: t.y
      };
    }
  }),
      Wt = {},
      Vt = _t,
      Et = Pt,
      Ht = Tt,
      jt = Nt;
  Wt.Arc = Vt, Wt.Line = Et, Wt.Point = Ht, Wt.Rectangle = jt;
  var qt = ut.options.resolve;

  st._set("bar", {
    hover: {
      mode: "label"
    },
    scales: {
      xAxes: [{
        type: "category",
        categoryPercentage: .8,
        barPercentage: .9,
        offset: !0,
        gridLines: {
          offsetGridLines: !0
        }
      }],
      yAxes: [{
        type: "linear"
      }]
    }
  });

  var Yt = Mt.extend({
    dataElementType: Wt.Rectangle,
    initialize: function initialize() {
      var t;
      Mt.prototype.initialize.apply(this, arguments), (t = this.getMeta()).stack = this.getDataset().stack, t.bar = !0;
    },
    update: function update(t) {
      var e,
          i,
          n = this.getMeta().data;

      for (this._ruler = this.getRuler(), e = 0, i = n.length; e < i; ++e) {
        this.updateElement(n[e], e, t);
      }
    },
    updateElement: function updateElement(t, e, i) {
      var n = this,
          a = n.getMeta(),
          o = n.getDataset(),
          r = n._resolveElementOptions(t, e);

      t._xScale = n.getScaleForId(a.xAxisID), t._yScale = n.getScaleForId(a.yAxisID), t._datasetIndex = n.index, t._index = e, t._model = {
        backgroundColor: r.backgroundColor,
        borderColor: r.borderColor,
        borderSkipped: r.borderSkipped,
        borderWidth: r.borderWidth,
        datasetLabel: o.label,
        label: n.chart.data.labels[e]
      }, n._updateElementGeometry(t, e, i), t.pivot();
    },
    _updateElementGeometry: function _updateElementGeometry(t, e, i) {
      var n = this,
          a = t._model,
          o = n._getValueScale(),
          r = o.getBasePixel(),
          s = o.isHorizontal(),
          l = n._ruler || n.getRuler(),
          d = n.calculateBarValuePixels(n.index, e),
          u = n.calculateBarIndexPixels(n.index, e, l);

      a.horizontal = s, a.base = i ? r : d.base, a.x = s ? i ? r : d.head : u.center, a.y = s ? u.center : i ? r : d.head, a.height = s ? u.size : void 0, a.width = s ? void 0 : u.size;
    },
    _getStacks: function _getStacks(t) {
      var e,
          i,
          n = this.chart,
          a = this._getIndexScale().options.stacked,
          o = void 0 === t ? n.data.datasets.length : t + 1,
          r = [];

      for (e = 0; e < o; ++e) {
        (i = n.getDatasetMeta(e)).bar && n.isDatasetVisible(e) && (!1 === a || !0 === a && -1 === r.indexOf(i.stack) || void 0 === a && (void 0 === i.stack || -1 === r.indexOf(i.stack))) && r.push(i.stack);
      }

      return r;
    },
    getStackCount: function getStackCount() {
      return this._getStacks().length;
    },
    getStackIndex: function getStackIndex(t, e) {
      var i = this._getStacks(t),
          n = void 0 !== e ? i.indexOf(e) : -1;

      return -1 === n ? i.length - 1 : n;
    },
    getRuler: function getRuler() {
      var t,
          e,
          i = this._getIndexScale(),
          n = this.getStackCount(),
          a = this.index,
          o = i.isHorizontal(),
          r = o ? i.left : i.top,
          s = r + (o ? i.width : i.height),
          l = [];

      for (t = 0, e = this.getMeta().data.length; t < e; ++t) {
        l.push(i.getPixelForValue(null, t, a));
      }

      return {
        min: ut.isNullOrUndef(i.options.barThickness) ? function (t, e) {
          var i,
              n,
              a,
              o,
              r = t.isHorizontal() ? t.width : t.height,
              s = t.getTicks();

          for (a = 1, o = e.length; a < o; ++a) {
            r = Math.min(r, Math.abs(e[a] - e[a - 1]));
          }

          for (a = 0, o = s.length; a < o; ++a) {
            n = t.getPixelForTick(a), r = a > 0 ? Math.min(r, n - i) : r, i = n;
          }

          return r;
        }(i, l) : -1,
        pixels: l,
        start: r,
        end: s,
        stackCount: n,
        scale: i
      };
    },
    calculateBarValuePixels: function calculateBarValuePixels(t, e) {
      var i,
          n,
          a,
          o,
          r,
          s,
          l = this.chart,
          d = this.getMeta(),
          u = this._getValueScale(),
          h = u.isHorizontal(),
          c = l.data.datasets,
          f = +u.getRightValue(c[t].data[e]),
          g = u.options.minBarLength,
          p = u.options.stacked,
          m = d.stack,
          v = 0;

      if (p || void 0 === p && void 0 !== m) for (i = 0; i < t; ++i) {
        (n = l.getDatasetMeta(i)).bar && n.stack === m && n.controller._getValueScaleId() === u.id && l.isDatasetVisible(i) && (a = +u.getRightValue(c[i].data[e]), (f < 0 && a < 0 || f >= 0 && a > 0) && (v += a));
      }
      return o = u.getPixelForValue(v), s = (r = u.getPixelForValue(v + f)) - o, void 0 !== g && Math.abs(s) < g && (s = g, r = f >= 0 && !h || f < 0 && h ? o - g : o + g), {
        size: s,
        base: o,
        head: r,
        center: r + s / 2
      };
    },
    calculateBarIndexPixels: function calculateBarIndexPixels(t, e, i) {
      var n = i.scale.options,
          a = "flex" === n.barThickness ? function (t, e, i) {
        var n,
            a = e.pixels,
            o = a[t],
            r = t > 0 ? a[t - 1] : null,
            s = t < a.length - 1 ? a[t + 1] : null,
            l = i.categoryPercentage;
        return null === r && (r = o - (null === s ? e.end - e.start : s - o)), null === s && (s = o + o - r), n = o - (o - Math.min(r, s)) / 2 * l, {
          chunk: Math.abs(s - r) / 2 * l / e.stackCount,
          ratio: i.barPercentage,
          start: n
        };
      }(e, i, n) : function (t, e, i) {
        var n,
            a,
            o = i.barThickness,
            r = e.stackCount,
            s = e.pixels[t];
        return ut.isNullOrUndef(o) ? (n = e.min * i.categoryPercentage, a = i.barPercentage) : (n = o * r, a = 1), {
          chunk: n / r,
          ratio: a,
          start: s - n / 2
        };
      }(e, i, n),
          o = this.getStackIndex(t, this.getMeta().stack),
          r = a.start + a.chunk * o + a.chunk / 2,
          s = Math.min(ut.valueOrDefault(n.maxBarThickness, 1 / 0), a.chunk * a.ratio);
      return {
        base: r - s / 2,
        head: r + s / 2,
        center: r,
        size: s
      };
    },
    draw: function draw() {
      var t = this.chart,
          e = this._getValueScale(),
          i = this.getMeta().data,
          n = this.getDataset(),
          a = i.length,
          o = 0;

      for (ut.canvas.clipArea(t.ctx, t.chartArea); o < a; ++o) {
        isNaN(e.getRightValue(n.data[o])) || i[o].draw();
      }

      ut.canvas.unclipArea(t.ctx);
    },
    _resolveElementOptions: function _resolveElementOptions(t, e) {
      var i,
          n,
          a,
          o = this.chart,
          r = o.data.datasets[this.index],
          s = t.custom || {},
          l = o.options.elements.rectangle,
          d = {},
          u = {
        chart: o,
        dataIndex: e,
        dataset: r,
        datasetIndex: this.index
      },
          h = ["backgroundColor", "borderColor", "borderSkipped", "borderWidth"];

      for (i = 0, n = h.length; i < n; ++i) {
        d[a = h[i]] = qt([s[a], r[a], l[a]], u, e);
      }

      return d;
    }
  }),
      Ut = ut.valueOrDefault,
      Xt = ut.options.resolve;

  st._set("bubble", {
    hover: {
      mode: "single"
    },
    scales: {
      xAxes: [{
        type: "linear",
        position: "bottom",
        id: "x-axis-0"
      }],
      yAxes: [{
        type: "linear",
        position: "left",
        id: "y-axis-0"
      }]
    },
    tooltips: {
      callbacks: {
        title: function title() {
          return "";
        },
        label: function label(t, e) {
          var i = e.datasets[t.datasetIndex].label || "",
              n = e.datasets[t.datasetIndex].data[t.index];
          return i + ": (" + t.xLabel + ", " + t.yLabel + ", " + n.r + ")";
        }
      }
    }
  });

  var Kt = Mt.extend({
    dataElementType: Wt.Point,
    update: function update(t) {
      var e = this,
          i = e.getMeta().data;
      ut.each(i, function (i, n) {
        e.updateElement(i, n, t);
      });
    },
    updateElement: function updateElement(t, e, i) {
      var n = this,
          a = n.getMeta(),
          o = t.custom || {},
          r = n.getScaleForId(a.xAxisID),
          s = n.getScaleForId(a.yAxisID),
          l = n._resolveElementOptions(t, e),
          d = n.getDataset().data[e],
          u = n.index,
          h = i ? r.getPixelForDecimal(.5) : r.getPixelForValue("object" == _typeof(d) ? d : NaN, e, u),
          c = i ? s.getBasePixel() : s.getPixelForValue(d, e, u);

      t._xScale = r, t._yScale = s, t._options = l, t._datasetIndex = u, t._index = e, t._model = {
        backgroundColor: l.backgroundColor,
        borderColor: l.borderColor,
        borderWidth: l.borderWidth,
        hitRadius: l.hitRadius,
        pointStyle: l.pointStyle,
        rotation: l.rotation,
        radius: i ? 0 : l.radius,
        skip: o.skip || isNaN(h) || isNaN(c),
        x: h,
        y: c
      }, t.pivot();
    },
    setHoverStyle: function setHoverStyle(t) {
      var e = t._model,
          i = t._options,
          n = ut.getHoverColor;
      t.$previousStyle = {
        backgroundColor: e.backgroundColor,
        borderColor: e.borderColor,
        borderWidth: e.borderWidth,
        radius: e.radius
      }, e.backgroundColor = Ut(i.hoverBackgroundColor, n(i.backgroundColor)), e.borderColor = Ut(i.hoverBorderColor, n(i.borderColor)), e.borderWidth = Ut(i.hoverBorderWidth, i.borderWidth), e.radius = i.radius + i.hoverRadius;
    },
    _resolveElementOptions: function _resolveElementOptions(t, e) {
      var i,
          n,
          a,
          o = this.chart,
          r = o.data.datasets[this.index],
          s = t.custom || {},
          l = o.options.elements.point,
          d = r.data[e],
          u = {},
          h = {
        chart: o,
        dataIndex: e,
        dataset: r,
        datasetIndex: this.index
      },
          c = ["backgroundColor", "borderColor", "borderWidth", "hoverBackgroundColor", "hoverBorderColor", "hoverBorderWidth", "hoverRadius", "hitRadius", "pointStyle", "rotation"];

      for (i = 0, n = c.length; i < n; ++i) {
        u[a = c[i]] = Xt([s[a], r[a], l[a]], h, e);
      }

      return u.radius = Xt([s.radius, d ? d.r : void 0, r.radius, l.radius], h, e), u;
    }
  }),
      Gt = ut.options.resolve,
      Zt = ut.valueOrDefault;

  st._set("doughnut", {
    animation: {
      animateRotate: !0,
      animateScale: !1
    },
    hover: {
      mode: "single"
    },
    legendCallback: function legendCallback(t) {
      var e = [];
      e.push('<ul class="' + t.id + '-legend">');
      var i = t.data,
          n = i.datasets,
          a = i.labels;
      if (n.length) for (var o = 0; o < n[0].data.length; ++o) {
        e.push('<li><span style="background-color:' + n[0].backgroundColor[o] + '"></span>'), a[o] && e.push(a[o]), e.push("</li>");
      }
      return e.push("</ul>"), e.join("");
    },
    legend: {
      labels: {
        generateLabels: function generateLabels(t) {
          var e = t.data;
          return e.labels.length && e.datasets.length ? e.labels.map(function (i, n) {
            var a = t.getDatasetMeta(0),
                o = e.datasets[0],
                r = a.data[n],
                s = r && r.custom || {},
                l = t.options.elements.arc;
            return {
              text: i,
              fillStyle: Gt([s.backgroundColor, o.backgroundColor, l.backgroundColor], void 0, n),
              strokeStyle: Gt([s.borderColor, o.borderColor, l.borderColor], void 0, n),
              lineWidth: Gt([s.borderWidth, o.borderWidth, l.borderWidth], void 0, n),
              hidden: isNaN(o.data[n]) || a.data[n].hidden,
              index: n
            };
          }) : [];
        }
      },
      onClick: function onClick(t, e) {
        var i,
            n,
            a,
            o = e.index,
            r = this.chart;

        for (i = 0, n = (r.data.datasets || []).length; i < n; ++i) {
          (a = r.getDatasetMeta(i)).data[o] && (a.data[o].hidden = !a.data[o].hidden);
        }

        r.update();
      }
    },
    cutoutPercentage: 50,
    rotation: -.5 * Math.PI,
    circumference: 2 * Math.PI,
    tooltips: {
      callbacks: {
        title: function title() {
          return "";
        },
        label: function label(t, e) {
          var i = e.labels[t.index],
              n = ": " + e.datasets[t.datasetIndex].data[t.index];
          return ut.isArray(i) ? (i = i.slice())[0] += n : i += n, i;
        }
      }
    }
  });

  var $t = Mt.extend({
    dataElementType: Wt.Arc,
    linkScales: ut.noop,
    getRingIndex: function getRingIndex(t) {
      for (var e = 0, i = 0; i < t; ++i) {
        this.chart.isDatasetVisible(i) && ++e;
      }

      return e;
    },
    update: function update(t) {
      var e,
          i,
          n = this,
          a = n.chart,
          o = a.chartArea,
          r = a.options,
          s = o.right - o.left,
          l = o.bottom - o.top,
          d = Math.min(s, l),
          u = {
        x: 0,
        y: 0
      },
          h = n.getMeta(),
          c = h.data,
          f = r.cutoutPercentage,
          g = r.circumference,
          p = n._getRingWeight(n.index);

      if (g < 2 * Math.PI) {
        var m = r.rotation % (2 * Math.PI),
            v = (m += 2 * Math.PI * (m >= Math.PI ? -1 : m < -Math.PI ? 1 : 0)) + g,
            b = {
          x: Math.cos(m),
          y: Math.sin(m)
        },
            x = {
          x: Math.cos(v),
          y: Math.sin(v)
        },
            y = m <= 0 && v >= 0 || m <= 2 * Math.PI && 2 * Math.PI <= v,
            k = m <= .5 * Math.PI && .5 * Math.PI <= v || m <= 2.5 * Math.PI && 2.5 * Math.PI <= v,
            w = m <= -Math.PI && -Math.PI <= v || m <= Math.PI && Math.PI <= v,
            M = m <= .5 * -Math.PI && .5 * -Math.PI <= v || m <= 1.5 * Math.PI && 1.5 * Math.PI <= v,
            _ = f / 100,
            C = {
          x: w ? -1 : Math.min(b.x * (b.x < 0 ? 1 : _), x.x * (x.x < 0 ? 1 : _)),
          y: M ? -1 : Math.min(b.y * (b.y < 0 ? 1 : _), x.y * (x.y < 0 ? 1 : _))
        },
            S = {
          x: y ? 1 : Math.max(b.x * (b.x > 0 ? 1 : _), x.x * (x.x > 0 ? 1 : _)),
          y: k ? 1 : Math.max(b.y * (b.y > 0 ? 1 : _), x.y * (x.y > 0 ? 1 : _))
        },
            P = {
          width: .5 * (S.x - C.x),
          height: .5 * (S.y - C.y)
        };

        d = Math.min(s / P.width, l / P.height), u = {
          x: -.5 * (S.x + C.x),
          y: -.5 * (S.y + C.y)
        };
      }

      for (e = 0, i = c.length; e < i; ++e) {
        c[e]._options = n._resolveElementOptions(c[e], e);
      }

      for (a.borderWidth = n.getMaxBorderWidth(), a.outerRadius = Math.max((d - a.borderWidth) / 2, 0), a.innerRadius = Math.max(f ? a.outerRadius / 100 * f : 0, 0), a.radiusLength = (a.outerRadius - a.innerRadius) / (n._getVisibleDatasetWeightTotal() || 1), a.offsetX = u.x * a.outerRadius, a.offsetY = u.y * a.outerRadius, h.total = n.calculateTotal(), n.outerRadius = a.outerRadius - a.radiusLength * n._getRingWeightOffset(n.index), n.innerRadius = Math.max(n.outerRadius - a.radiusLength * p, 0), e = 0, i = c.length; e < i; ++e) {
        n.updateElement(c[e], e, t);
      }
    },
    updateElement: function updateElement(t, e, i) {
      var n = this,
          a = n.chart,
          o = a.chartArea,
          r = a.options,
          s = r.animation,
          l = (o.left + o.right) / 2,
          d = (o.top + o.bottom) / 2,
          u = r.rotation,
          h = r.rotation,
          c = n.getDataset(),
          f = i && s.animateRotate ? 0 : t.hidden ? 0 : n.calculateCircumference(c.data[e]) * (r.circumference / (2 * Math.PI)),
          g = i && s.animateScale ? 0 : n.innerRadius,
          p = i && s.animateScale ? 0 : n.outerRadius,
          m = t._options || {};
      ut.extend(t, {
        _datasetIndex: n.index,
        _index: e,
        _model: {
          backgroundColor: m.backgroundColor,
          borderColor: m.borderColor,
          borderWidth: m.borderWidth,
          borderAlign: m.borderAlign,
          x: l + a.offsetX,
          y: d + a.offsetY,
          startAngle: u,
          endAngle: h,
          circumference: f,
          outerRadius: p,
          innerRadius: g,
          label: ut.valueAtIndexOrDefault(c.label, e, a.data.labels[e])
        }
      });
      var v = t._model;
      i && s.animateRotate || (v.startAngle = 0 === e ? r.rotation : n.getMeta().data[e - 1]._model.endAngle, v.endAngle = v.startAngle + v.circumference), t.pivot();
    },
    calculateTotal: function calculateTotal() {
      var t,
          e = this.getDataset(),
          i = this.getMeta(),
          n = 0;
      return ut.each(i.data, function (i, a) {
        t = e.data[a], isNaN(t) || i.hidden || (n += Math.abs(t));
      }), n;
    },
    calculateCircumference: function calculateCircumference(t) {
      var e = this.getMeta().total;
      return e > 0 && !isNaN(t) ? 2 * Math.PI * (Math.abs(t) / e) : 0;
    },
    getMaxBorderWidth: function getMaxBorderWidth(t) {
      var e,
          i,
          n,
          a,
          o,
          r,
          s,
          l,
          d = 0,
          u = this.chart;
      if (!t) for (e = 0, i = u.data.datasets.length; e < i; ++e) {
        if (u.isDatasetVisible(e)) {
          t = (n = u.getDatasetMeta(e)).data, e !== this.index && (o = n.controller);
          break;
        }
      }
      if (!t) return 0;

      for (e = 0, i = t.length; e < i; ++e) {
        a = t[e], "inner" !== (r = o ? o._resolveElementOptions(a, e) : a._options).borderAlign && (s = r.borderWidth, d = (l = r.hoverBorderWidth) > (d = s > d ? s : d) ? l : d);
      }

      return d;
    },
    setHoverStyle: function setHoverStyle(t) {
      var e = t._model,
          i = t._options,
          n = ut.getHoverColor;
      t.$previousStyle = {
        backgroundColor: e.backgroundColor,
        borderColor: e.borderColor,
        borderWidth: e.borderWidth
      }, e.backgroundColor = Zt(i.hoverBackgroundColor, n(i.backgroundColor)), e.borderColor = Zt(i.hoverBorderColor, n(i.borderColor)), e.borderWidth = Zt(i.hoverBorderWidth, i.borderWidth);
    },
    _resolveElementOptions: function _resolveElementOptions(t, e) {
      var i,
          n,
          a,
          o = this.chart,
          r = this.getDataset(),
          s = t.custom || {},
          l = o.options.elements.arc,
          d = {},
          u = {
        chart: o,
        dataIndex: e,
        dataset: r,
        datasetIndex: this.index
      },
          h = ["backgroundColor", "borderColor", "borderWidth", "borderAlign", "hoverBackgroundColor", "hoverBorderColor", "hoverBorderWidth"];

      for (i = 0, n = h.length; i < n; ++i) {
        d[a = h[i]] = Gt([s[a], r[a], l[a]], u, e);
      }

      return d;
    },
    _getRingWeightOffset: function _getRingWeightOffset(t) {
      for (var e = 0, i = 0; i < t; ++i) {
        this.chart.isDatasetVisible(i) && (e += this._getRingWeight(i));
      }

      return e;
    },
    _getRingWeight: function _getRingWeight(t) {
      return Math.max(Zt(this.chart.data.datasets[t].weight, 1), 0);
    },
    _getVisibleDatasetWeightTotal: function _getVisibleDatasetWeightTotal() {
      return this._getRingWeightOffset(this.chart.data.datasets.length);
    }
  });

  st._set("horizontalBar", {
    hover: {
      mode: "index",
      axis: "y"
    },
    scales: {
      xAxes: [{
        type: "linear",
        position: "bottom"
      }],
      yAxes: [{
        type: "category",
        position: "left",
        categoryPercentage: .8,
        barPercentage: .9,
        offset: !0,
        gridLines: {
          offsetGridLines: !0
        }
      }]
    },
    elements: {
      rectangle: {
        borderSkipped: "left"
      }
    },
    tooltips: {
      mode: "index",
      axis: "y"
    }
  });

  var Jt = Yt.extend({
    _getValueScaleId: function _getValueScaleId() {
      return this.getMeta().xAxisID;
    },
    _getIndexScaleId: function _getIndexScaleId() {
      return this.getMeta().yAxisID;
    }
  }),
      Qt = ut.valueOrDefault,
      te = ut.options.resolve,
      ee = ut.canvas._isPointInArea;

  function ie(t, e) {
    return Qt(t.showLine, e.showLines);
  }

  st._set("line", {
    showLines: !0,
    spanGaps: !1,
    hover: {
      mode: "label"
    },
    scales: {
      xAxes: [{
        type: "category",
        id: "x-axis-0"
      }],
      yAxes: [{
        type: "linear",
        id: "y-axis-0"
      }]
    }
  });

  var ne = Mt.extend({
    datasetElementType: Wt.Line,
    dataElementType: Wt.Point,
    update: function update(t) {
      var e,
          i,
          n = this,
          a = n.getMeta(),
          o = a.dataset,
          r = a.data || [],
          s = n.getScaleForId(a.yAxisID),
          l = n.getDataset(),
          d = ie(l, n.chart.options);

      for (d && (void 0 !== l.tension && void 0 === l.lineTension && (l.lineTension = l.tension), o._scale = s, o._datasetIndex = n.index, o._children = r, o._model = n._resolveLineOptions(o), o.pivot()), e = 0, i = r.length; e < i; ++e) {
        n.updateElement(r[e], e, t);
      }

      for (d && 0 !== o._model.tension && n.updateBezierControlPoints(), e = 0, i = r.length; e < i; ++e) {
        r[e].pivot();
      }
    },
    updateElement: function updateElement(t, e, i) {
      var n,
          a,
          o = this,
          r = o.getMeta(),
          s = t.custom || {},
          l = o.getDataset(),
          d = o.index,
          u = l.data[e],
          h = o.getScaleForId(r.yAxisID),
          c = o.getScaleForId(r.xAxisID),
          f = r.dataset._model,
          g = o._resolvePointOptions(t, e);

      n = c.getPixelForValue("object" == _typeof(u) ? u : NaN, e, d), a = i ? h.getBasePixel() : o.calculatePointY(u, e, d), t._xScale = c, t._yScale = h, t._options = g, t._datasetIndex = d, t._index = e, t._model = {
        x: n,
        y: a,
        skip: s.skip || isNaN(n) || isNaN(a),
        radius: g.radius,
        pointStyle: g.pointStyle,
        rotation: g.rotation,
        backgroundColor: g.backgroundColor,
        borderColor: g.borderColor,
        borderWidth: g.borderWidth,
        tension: Qt(s.tension, f ? f.tension : 0),
        steppedLine: !!f && f.steppedLine,
        hitRadius: g.hitRadius
      };
    },
    _resolvePointOptions: function _resolvePointOptions(t, e) {
      var i,
          n,
          a,
          o = this.chart,
          r = o.data.datasets[this.index],
          s = t.custom || {},
          l = o.options.elements.point,
          d = {},
          u = {
        chart: o,
        dataIndex: e,
        dataset: r,
        datasetIndex: this.index
      },
          h = {
        backgroundColor: "pointBackgroundColor",
        borderColor: "pointBorderColor",
        borderWidth: "pointBorderWidth",
        hitRadius: "pointHitRadius",
        hoverBackgroundColor: "pointHoverBackgroundColor",
        hoverBorderColor: "pointHoverBorderColor",
        hoverBorderWidth: "pointHoverBorderWidth",
        hoverRadius: "pointHoverRadius",
        pointStyle: "pointStyle",
        radius: "pointRadius",
        rotation: "pointRotation"
      },
          c = Object.keys(h);

      for (i = 0, n = c.length; i < n; ++i) {
        d[a = c[i]] = te([s[a], r[h[a]], r[a], l[a]], u, e);
      }

      return d;
    },
    _resolveLineOptions: function _resolveLineOptions(t) {
      var e,
          i,
          n,
          a = this.chart,
          o = a.data.datasets[this.index],
          r = t.custom || {},
          s = a.options,
          l = s.elements.line,
          d = {},
          u = ["backgroundColor", "borderWidth", "borderColor", "borderCapStyle", "borderDash", "borderDashOffset", "borderJoinStyle", "fill", "cubicInterpolationMode"];

      for (e = 0, i = u.length; e < i; ++e) {
        d[n = u[e]] = te([r[n], o[n], l[n]]);
      }

      return d.spanGaps = Qt(o.spanGaps, s.spanGaps), d.tension = Qt(o.lineTension, l.tension), d.steppedLine = te([r.steppedLine, o.steppedLine, l.stepped]), d;
    },
    calculatePointY: function calculatePointY(t, e, i) {
      var n,
          a,
          o,
          r = this.chart,
          s = this.getMeta(),
          l = this.getScaleForId(s.yAxisID),
          d = 0,
          u = 0;

      if (l.options.stacked) {
        for (n = 0; n < i; n++) {
          if (a = r.data.datasets[n], "line" === (o = r.getDatasetMeta(n)).type && o.yAxisID === l.id && r.isDatasetVisible(n)) {
            var h = Number(l.getRightValue(a.data[e]));
            h < 0 ? u += h || 0 : d += h || 0;
          }
        }

        var c = Number(l.getRightValue(t));
        return c < 0 ? l.getPixelForValue(u + c) : l.getPixelForValue(d + c);
      }

      return l.getPixelForValue(t);
    },
    updateBezierControlPoints: function updateBezierControlPoints() {
      var t,
          e,
          i,
          n,
          a = this.chart,
          o = this.getMeta(),
          r = o.dataset._model,
          s = a.chartArea,
          l = o.data || [];

      function d(t, e, i) {
        return Math.max(Math.min(t, i), e);
      }

      if (r.spanGaps && (l = l.filter(function (t) {
        return !t._model.skip;
      })), "monotone" === r.cubicInterpolationMode) ut.splineCurveMonotone(l);else for (t = 0, e = l.length; t < e; ++t) {
        i = l[t]._model, n = ut.splineCurve(ut.previousItem(l, t)._model, i, ut.nextItem(l, t)._model, r.tension), i.controlPointPreviousX = n.previous.x, i.controlPointPreviousY = n.previous.y, i.controlPointNextX = n.next.x, i.controlPointNextY = n.next.y;
      }
      if (a.options.elements.line.capBezierPoints) for (t = 0, e = l.length; t < e; ++t) {
        i = l[t]._model, ee(i, s) && (t > 0 && ee(l[t - 1]._model, s) && (i.controlPointPreviousX = d(i.controlPointPreviousX, s.left, s.right), i.controlPointPreviousY = d(i.controlPointPreviousY, s.top, s.bottom)), t < l.length - 1 && ee(l[t + 1]._model, s) && (i.controlPointNextX = d(i.controlPointNextX, s.left, s.right), i.controlPointNextY = d(i.controlPointNextY, s.top, s.bottom)));
      }
    },
    draw: function draw() {
      var t,
          e = this.chart,
          i = this.getMeta(),
          n = i.data || [],
          a = e.chartArea,
          o = n.length,
          r = 0;

      for (ie(this.getDataset(), e.options) && (t = (i.dataset._model.borderWidth || 0) / 2, ut.canvas.clipArea(e.ctx, {
        left: a.left,
        right: a.right,
        top: a.top - t,
        bottom: a.bottom + t
      }), i.dataset.draw(), ut.canvas.unclipArea(e.ctx)); r < o; ++r) {
        n[r].draw(a);
      }
    },
    setHoverStyle: function setHoverStyle(t) {
      var e = t._model,
          i = t._options,
          n = ut.getHoverColor;
      t.$previousStyle = {
        backgroundColor: e.backgroundColor,
        borderColor: e.borderColor,
        borderWidth: e.borderWidth,
        radius: e.radius
      }, e.backgroundColor = Qt(i.hoverBackgroundColor, n(i.backgroundColor)), e.borderColor = Qt(i.hoverBorderColor, n(i.borderColor)), e.borderWidth = Qt(i.hoverBorderWidth, i.borderWidth), e.radius = Qt(i.hoverRadius, i.radius);
    }
  }),
      ae = ut.options.resolve;

  st._set("polarArea", {
    scale: {
      type: "radialLinear",
      angleLines: {
        display: !1
      },
      gridLines: {
        circular: !0
      },
      pointLabels: {
        display: !1
      },
      ticks: {
        beginAtZero: !0
      }
    },
    animation: {
      animateRotate: !0,
      animateScale: !0
    },
    startAngle: -.5 * Math.PI,
    legendCallback: function legendCallback(t) {
      var e = [];
      e.push('<ul class="' + t.id + '-legend">');
      var i = t.data,
          n = i.datasets,
          a = i.labels;
      if (n.length) for (var o = 0; o < n[0].data.length; ++o) {
        e.push('<li><span style="background-color:' + n[0].backgroundColor[o] + '"></span>'), a[o] && e.push(a[o]), e.push("</li>");
      }
      return e.push("</ul>"), e.join("");
    },
    legend: {
      labels: {
        generateLabels: function generateLabels(t) {
          var e = t.data;
          return e.labels.length && e.datasets.length ? e.labels.map(function (i, n) {
            var a = t.getDatasetMeta(0),
                o = e.datasets[0],
                r = a.data[n].custom || {},
                s = t.options.elements.arc;
            return {
              text: i,
              fillStyle: ae([r.backgroundColor, o.backgroundColor, s.backgroundColor], void 0, n),
              strokeStyle: ae([r.borderColor, o.borderColor, s.borderColor], void 0, n),
              lineWidth: ae([r.borderWidth, o.borderWidth, s.borderWidth], void 0, n),
              hidden: isNaN(o.data[n]) || a.data[n].hidden,
              index: n
            };
          }) : [];
        }
      },
      onClick: function onClick(t, e) {
        var i,
            n,
            a,
            o = e.index,
            r = this.chart;

        for (i = 0, n = (r.data.datasets || []).length; i < n; ++i) {
          (a = r.getDatasetMeta(i)).data[o].hidden = !a.data[o].hidden;
        }

        r.update();
      }
    },
    tooltips: {
      callbacks: {
        title: function title() {
          return "";
        },
        label: function label(t, e) {
          return e.labels[t.index] + ": " + t.yLabel;
        }
      }
    }
  });

  var oe = Mt.extend({
    dataElementType: Wt.Arc,
    linkScales: ut.noop,
    update: function update(t) {
      var e,
          i,
          n,
          a = this,
          o = a.getDataset(),
          r = a.getMeta(),
          s = a.chart.options.startAngle || 0,
          l = a._starts = [],
          d = a._angles = [],
          u = r.data;

      for (a._updateRadius(), r.count = a.countVisibleElements(), e = 0, i = o.data.length; e < i; e++) {
        l[e] = s, n = a._computeAngle(e), d[e] = n, s += n;
      }

      for (e = 0, i = u.length; e < i; ++e) {
        u[e]._options = a._resolveElementOptions(u[e], e), a.updateElement(u[e], e, t);
      }
    },
    _updateRadius: function _updateRadius() {
      var t = this,
          e = t.chart,
          i = e.chartArea,
          n = e.options,
          a = Math.min(i.right - i.left, i.bottom - i.top);
      e.outerRadius = Math.max(a / 2, 0), e.innerRadius = Math.max(n.cutoutPercentage ? e.outerRadius / 100 * n.cutoutPercentage : 1, 0), e.radiusLength = (e.outerRadius - e.innerRadius) / e.getVisibleDatasetCount(), t.outerRadius = e.outerRadius - e.radiusLength * t.index, t.innerRadius = t.outerRadius - e.radiusLength;
    },
    updateElement: function updateElement(t, e, i) {
      var n = this,
          a = n.chart,
          o = n.getDataset(),
          r = a.options,
          s = r.animation,
          l = a.scale,
          d = a.data.labels,
          u = l.xCenter,
          h = l.yCenter,
          c = r.startAngle,
          f = t.hidden ? 0 : l.getDistanceFromCenterForValue(o.data[e]),
          g = n._starts[e],
          p = g + (t.hidden ? 0 : n._angles[e]),
          m = s.animateScale ? 0 : l.getDistanceFromCenterForValue(o.data[e]),
          v = t._options || {};
      ut.extend(t, {
        _datasetIndex: n.index,
        _index: e,
        _scale: l,
        _model: {
          backgroundColor: v.backgroundColor,
          borderColor: v.borderColor,
          borderWidth: v.borderWidth,
          borderAlign: v.borderAlign,
          x: u,
          y: h,
          innerRadius: 0,
          outerRadius: i ? m : f,
          startAngle: i && s.animateRotate ? c : g,
          endAngle: i && s.animateRotate ? c : p,
          label: ut.valueAtIndexOrDefault(d, e, d[e])
        }
      }), t.pivot();
    },
    countVisibleElements: function countVisibleElements() {
      var t = this.getDataset(),
          e = this.getMeta(),
          i = 0;
      return ut.each(e.data, function (e, n) {
        isNaN(t.data[n]) || e.hidden || i++;
      }), i;
    },
    setHoverStyle: function setHoverStyle(t) {
      var e = t._model,
          i = t._options,
          n = ut.getHoverColor,
          a = ut.valueOrDefault;
      t.$previousStyle = {
        backgroundColor: e.backgroundColor,
        borderColor: e.borderColor,
        borderWidth: e.borderWidth
      }, e.backgroundColor = a(i.hoverBackgroundColor, n(i.backgroundColor)), e.borderColor = a(i.hoverBorderColor, n(i.borderColor)), e.borderWidth = a(i.hoverBorderWidth, i.borderWidth);
    },
    _resolveElementOptions: function _resolveElementOptions(t, e) {
      var i,
          n,
          a,
          o = this.chart,
          r = this.getDataset(),
          s = t.custom || {},
          l = o.options.elements.arc,
          d = {},
          u = {
        chart: o,
        dataIndex: e,
        dataset: r,
        datasetIndex: this.index
      },
          h = ["backgroundColor", "borderColor", "borderWidth", "borderAlign", "hoverBackgroundColor", "hoverBorderColor", "hoverBorderWidth"];

      for (i = 0, n = h.length; i < n; ++i) {
        d[a = h[i]] = ae([s[a], r[a], l[a]], u, e);
      }

      return d;
    },
    _computeAngle: function _computeAngle(t) {
      var e = this,
          i = this.getMeta().count,
          n = e.getDataset(),
          a = e.getMeta();
      if (isNaN(n.data[t]) || a.data[t].hidden) return 0;
      var o = {
        chart: e.chart,
        dataIndex: t,
        dataset: n,
        datasetIndex: e.index
      };
      return ae([e.chart.options.elements.arc.angle, 2 * Math.PI / i], o, t);
    }
  });
  st._set("pie", ut.clone(st.doughnut)), st._set("pie", {
    cutoutPercentage: 0
  });
  var re = $t,
      se = ut.valueOrDefault,
      le = ut.options.resolve;

  st._set("radar", {
    scale: {
      type: "radialLinear"
    },
    elements: {
      line: {
        tension: 0
      }
    }
  });

  var de = Mt.extend({
    datasetElementType: Wt.Line,
    dataElementType: Wt.Point,
    linkScales: ut.noop,
    update: function update(t) {
      var e,
          i,
          n = this,
          a = n.getMeta(),
          o = a.dataset,
          r = a.data || [],
          s = n.chart.scale,
          l = n.getDataset();

      for (void 0 !== l.tension && void 0 === l.lineTension && (l.lineTension = l.tension), o._scale = s, o._datasetIndex = n.index, o._children = r, o._loop = !0, o._model = n._resolveLineOptions(o), o.pivot(), e = 0, i = r.length; e < i; ++e) {
        n.updateElement(r[e], e, t);
      }

      for (n.updateBezierControlPoints(), e = 0, i = r.length; e < i; ++e) {
        r[e].pivot();
      }
    },
    updateElement: function updateElement(t, e, i) {
      var n = this,
          a = t.custom || {},
          o = n.getDataset(),
          r = n.chart.scale,
          s = r.getPointPositionForValue(e, o.data[e]),
          l = n._resolvePointOptions(t, e),
          d = n.getMeta().dataset._model,
          u = i ? r.xCenter : s.x,
          h = i ? r.yCenter : s.y;

      t._scale = r, t._options = l, t._datasetIndex = n.index, t._index = e, t._model = {
        x: u,
        y: h,
        skip: a.skip || isNaN(u) || isNaN(h),
        radius: l.radius,
        pointStyle: l.pointStyle,
        rotation: l.rotation,
        backgroundColor: l.backgroundColor,
        borderColor: l.borderColor,
        borderWidth: l.borderWidth,
        tension: se(a.tension, d ? d.tension : 0),
        hitRadius: l.hitRadius
      };
    },
    _resolvePointOptions: function _resolvePointOptions(t, e) {
      var i,
          n,
          a,
          o = this.chart,
          r = o.data.datasets[this.index],
          s = t.custom || {},
          l = o.options.elements.point,
          d = {},
          u = {
        chart: o,
        dataIndex: e,
        dataset: r,
        datasetIndex: this.index
      },
          h = {
        backgroundColor: "pointBackgroundColor",
        borderColor: "pointBorderColor",
        borderWidth: "pointBorderWidth",
        hitRadius: "pointHitRadius",
        hoverBackgroundColor: "pointHoverBackgroundColor",
        hoverBorderColor: "pointHoverBorderColor",
        hoverBorderWidth: "pointHoverBorderWidth",
        hoverRadius: "pointHoverRadius",
        pointStyle: "pointStyle",
        radius: "pointRadius",
        rotation: "pointRotation"
      },
          c = Object.keys(h);

      for (i = 0, n = c.length; i < n; ++i) {
        d[a = c[i]] = le([s[a], r[h[a]], r[a], l[a]], u, e);
      }

      return d;
    },
    _resolveLineOptions: function _resolveLineOptions(t) {
      var e,
          i,
          n,
          a = this.chart,
          o = a.data.datasets[this.index],
          r = t.custom || {},
          s = a.options.elements.line,
          l = {},
          d = ["backgroundColor", "borderWidth", "borderColor", "borderCapStyle", "borderDash", "borderDashOffset", "borderJoinStyle", "fill"];

      for (e = 0, i = d.length; e < i; ++e) {
        l[n = d[e]] = le([r[n], o[n], s[n]]);
      }

      return l.tension = se(o.lineTension, s.tension), l;
    },
    updateBezierControlPoints: function updateBezierControlPoints() {
      var t,
          e,
          i,
          n,
          a = this.getMeta(),
          o = this.chart.chartArea,
          r = a.data || [];

      function s(t, e, i) {
        return Math.max(Math.min(t, i), e);
      }

      for (t = 0, e = r.length; t < e; ++t) {
        i = r[t]._model, n = ut.splineCurve(ut.previousItem(r, t, !0)._model, i, ut.nextItem(r, t, !0)._model, i.tension), i.controlPointPreviousX = s(n.previous.x, o.left, o.right), i.controlPointPreviousY = s(n.previous.y, o.top, o.bottom), i.controlPointNextX = s(n.next.x, o.left, o.right), i.controlPointNextY = s(n.next.y, o.top, o.bottom);
      }
    },
    setHoverStyle: function setHoverStyle(t) {
      var e = t._model,
          i = t._options,
          n = ut.getHoverColor;
      t.$previousStyle = {
        backgroundColor: e.backgroundColor,
        borderColor: e.borderColor,
        borderWidth: e.borderWidth,
        radius: e.radius
      }, e.backgroundColor = se(i.hoverBackgroundColor, n(i.backgroundColor)), e.borderColor = se(i.hoverBorderColor, n(i.borderColor)), e.borderWidth = se(i.hoverBorderWidth, i.borderWidth), e.radius = se(i.hoverRadius, i.radius);
    }
  });

  st._set("scatter", {
    hover: {
      mode: "single"
    },
    scales: {
      xAxes: [{
        id: "x-axis-1",
        type: "linear",
        position: "bottom"
      }],
      yAxes: [{
        id: "y-axis-1",
        type: "linear",
        position: "left"
      }]
    },
    showLines: !1,
    tooltips: {
      callbacks: {
        title: function title() {
          return "";
        },
        label: function label(t) {
          return "(" + t.xLabel + ", " + t.yLabel + ")";
        }
      }
    }
  });

  var ue = {
    bar: Yt,
    bubble: Kt,
    doughnut: $t,
    horizontalBar: Jt,
    line: ne,
    polarArea: oe,
    pie: re,
    radar: de,
    scatter: ne
  };

  function he(t, e) {
    return t.native ? {
      x: t.x,
      y: t.y
    } : ut.getRelativePosition(t, e);
  }

  function ce(t, e) {
    var i, n, a, o, r;

    for (n = 0, o = t.data.datasets.length; n < o; ++n) {
      if (t.isDatasetVisible(n)) for (a = 0, r = (i = t.getDatasetMeta(n)).data.length; a < r; ++a) {
        var s = i.data[a];
        s._view.skip || e(s);
      }
    }
  }

  function fe(t, e) {
    var i = [];
    return ce(t, function (t) {
      t.inRange(e.x, e.y) && i.push(t);
    }), i;
  }

  function ge(t, e, i, n) {
    var a = Number.POSITIVE_INFINITY,
        o = [];
    return ce(t, function (t) {
      if (!i || t.inRange(e.x, e.y)) {
        var r = t.getCenterPoint(),
            s = n(e, r);
        s < a ? (o = [t], a = s) : s === a && o.push(t);
      }
    }), o;
  }

  function pe(t) {
    var e = -1 !== t.indexOf("x"),
        i = -1 !== t.indexOf("y");
    return function (t, n) {
      var a = e ? Math.abs(t.x - n.x) : 0,
          o = i ? Math.abs(t.y - n.y) : 0;
      return Math.sqrt(Math.pow(a, 2) + Math.pow(o, 2));
    };
  }

  function me(t, e, i) {
    var n = he(e, t);
    i.axis = i.axis || "x";
    var a = pe(i.axis),
        o = i.intersect ? fe(t, n) : ge(t, n, !1, a),
        r = [];
    return o.length ? (t.data.datasets.forEach(function (e, i) {
      if (t.isDatasetVisible(i)) {
        var n = t.getDatasetMeta(i).data[o[0]._index];

        n && !n._view.skip && r.push(n);
      }
    }), r) : [];
  }

  var ve = {
    modes: {
      single: function single(t, e) {
        var i = he(e, t),
            n = [];
        return ce(t, function (t) {
          if (t.inRange(i.x, i.y)) return n.push(t), n;
        }), n.slice(0, 1);
      },
      label: me,
      index: me,
      dataset: function dataset(t, e, i) {
        var n = he(e, t);
        i.axis = i.axis || "xy";
        var a = pe(i.axis),
            o = i.intersect ? fe(t, n) : ge(t, n, !1, a);
        return o.length > 0 && (o = t.getDatasetMeta(o[0]._datasetIndex).data), o;
      },
      "x-axis": function xAxis(t, e) {
        return me(t, e, {
          intersect: !1
        });
      },
      point: function point(t, e) {
        return fe(t, he(e, t));
      },
      nearest: function nearest(t, e, i) {
        var n = he(e, t);
        i.axis = i.axis || "xy";
        var a = pe(i.axis);
        return ge(t, n, i.intersect, a);
      },
      x: function x(t, e, i) {
        var n = he(e, t),
            a = [],
            o = !1;
        return ce(t, function (t) {
          t.inXRange(n.x) && a.push(t), t.inRange(n.x, n.y) && (o = !0);
        }), i.intersect && !o && (a = []), a;
      },
      y: function y(t, e, i) {
        var n = he(e, t),
            a = [],
            o = !1;
        return ce(t, function (t) {
          t.inYRange(n.y) && a.push(t), t.inRange(n.x, n.y) && (o = !0);
        }), i.intersect && !o && (a = []), a;
      }
    }
  };

  function be(t, e) {
    return ut.where(t, function (t) {
      return t.position === e;
    });
  }

  function xe(t, e) {
    t.forEach(function (t, e) {
      return t._tmpIndex_ = e, t;
    }), t.sort(function (t, i) {
      var n = e ? i : t,
          a = e ? t : i;
      return n.weight === a.weight ? n._tmpIndex_ - a._tmpIndex_ : n.weight - a.weight;
    }), t.forEach(function (t) {
      delete t._tmpIndex_;
    });
  }

  function ye(t, e) {
    ut.each(t, function (t) {
      e[t.position] += t.isHorizontal() ? t.height : t.width;
    });
  }

  st._set("global", {
    layout: {
      padding: {
        top: 0,
        right: 0,
        bottom: 0,
        left: 0
      }
    }
  });

  var ke = {
    defaults: {},
    addBox: function addBox(t, e) {
      t.boxes || (t.boxes = []), e.fullWidth = e.fullWidth || !1, e.position = e.position || "top", e.weight = e.weight || 0, t.boxes.push(e);
    },
    removeBox: function removeBox(t, e) {
      var i = t.boxes ? t.boxes.indexOf(e) : -1;
      -1 !== i && t.boxes.splice(i, 1);
    },
    configure: function configure(t, e, i) {
      for (var n, a = ["fullWidth", "position", "weight"], o = a.length, r = 0; r < o; ++r) {
        n = a[r], i.hasOwnProperty(n) && (e[n] = i[n]);
      }
    },
    update: function update(t, e, i) {
      if (t) {
        var n = t.options.layout || {},
            a = ut.options.toPadding(n.padding),
            o = a.left,
            r = a.right,
            s = a.top,
            l = a.bottom,
            d = be(t.boxes, "left"),
            u = be(t.boxes, "right"),
            h = be(t.boxes, "top"),
            c = be(t.boxes, "bottom"),
            f = be(t.boxes, "chartArea");
        xe(d, !0), xe(u, !1), xe(h, !0), xe(c, !1);
        var g,
            p = d.concat(u),
            m = h.concat(c),
            v = p.concat(m),
            b = e - o - r,
            x = i - s - l,
            y = (e - b / 2) / p.length,
            k = b,
            w = x,
            M = {
          top: s,
          left: o,
          bottom: l,
          right: r
        },
            _ = [];
        ut.each(v, function (t) {
          var e,
              i = t.isHorizontal();
          i ? (e = t.update(t.fullWidth ? b : k, x / 2), w -= e.height) : (e = t.update(y, w), k -= e.width), _.push({
            horizontal: i,
            width: e.width,
            box: t
          });
        }), g = function (t) {
          var e = 0,
              i = 0,
              n = 0,
              a = 0;
          return ut.each(t, function (t) {
            if (t.getPadding) {
              var o = t.getPadding();
              e = Math.max(e, o.top), i = Math.max(i, o.left), n = Math.max(n, o.bottom), a = Math.max(a, o.right);
            }
          }), {
            top: e,
            left: i,
            bottom: n,
            right: a
          };
        }(v), ut.each(p, T), ye(p, M), ut.each(m, T), ye(m, M), ut.each(p, function (t) {
          var e = ut.findNextWhere(_, function (e) {
            return e.box === t;
          }),
              i = {
            left: 0,
            right: 0,
            top: M.top,
            bottom: M.bottom
          };
          e && t.update(e.width, w, i);
        }), ye(v, M = {
          top: s,
          left: o,
          bottom: l,
          right: r
        });
        var C = Math.max(g.left - M.left, 0);
        M.left += C, M.right += Math.max(g.right - M.right, 0);
        var S = Math.max(g.top - M.top, 0);
        M.top += S, M.bottom += Math.max(g.bottom - M.bottom, 0);
        var P = i - M.top - M.bottom,
            I = e - M.left - M.right;
        I === k && P === w || (ut.each(p, function (t) {
          t.height = P;
        }), ut.each(m, function (t) {
          t.fullWidth || (t.width = I);
        }), w = P, k = I);
        var A = o + C,
            D = s + S;
        ut.each(d.concat(h), F), A += k, D += w, ut.each(u, F), ut.each(c, F), t.chartArea = {
          left: M.left,
          top: M.top,
          right: M.left + k,
          bottom: M.top + w
        }, ut.each(f, function (e) {
          e.left = t.chartArea.left, e.top = t.chartArea.top, e.right = t.chartArea.right, e.bottom = t.chartArea.bottom, e.update(k, w);
        });
      }

      function T(t) {
        var e = ut.findNextWhere(_, function (e) {
          return e.box === t;
        });
        if (e) if (e.horizontal) {
          var i = {
            left: Math.max(M.left, g.left),
            right: Math.max(M.right, g.right),
            top: 0,
            bottom: 0
          };
          t.update(t.fullWidth ? b : k, x / 2, i);
        } else t.update(e.width, w);
      }

      function F(t) {
        t.isHorizontal() ? (t.left = t.fullWidth ? o : M.left, t.right = t.fullWidth ? e - r : M.left + k, t.top = D, t.bottom = D + t.height, D = t.bottom) : (t.left = A, t.right = A + t.width, t.top = M.top, t.bottom = M.top + w, A = t.right);
      }
    }
  };
  var we,
      Me = (we = Object.freeze({
    default: "@keyframes chartjs-render-animation{from{opacity:.99}to{opacity:1}}.chartjs-render-monitor{animation:chartjs-render-animation 1ms}.chartjs-size-monitor,.chartjs-size-monitor-expand,.chartjs-size-monitor-shrink{position:absolute;direction:ltr;left:0;top:0;right:0;bottom:0;overflow:hidden;pointer-events:none;visibility:hidden;z-index:-1}.chartjs-size-monitor-expand>div{position:absolute;width:1000000px;height:1000000px;left:0;top:0}.chartjs-size-monitor-shrink>div{position:absolute;width:200%;height:200%;left:0;top:0}"
  })) && we.default || we,
      _e = "$chartjs",
      Ce = "chartjs-size-monitor",
      Se = "chartjs-render-monitor",
      Pe = "chartjs-render-animation",
      Ie = ["animationstart", "webkitAnimationStart"],
      Ae = {
    touchstart: "mousedown",
    touchmove: "mousemove",
    touchend: "mouseup",
    pointerenter: "mouseenter",
    pointerdown: "mousedown",
    pointermove: "mousemove",
    pointerup: "mouseup",
    pointerleave: "mouseout",
    pointerout: "mouseout"
  };

  function De(t, e) {
    var i = ut.getStyle(t, e),
        n = i && i.match(/^(\d+)(\.\d+)?px$/);
    return n ? Number(n[1]) : void 0;
  }

  var Te = !!function () {
    var t = !1;

    try {
      var e = Object.defineProperty({}, "passive", {
        get: function get() {
          t = !0;
        }
      });
      window.addEventListener("e", null, e);
    } catch (t) {}

    return t;
  }() && {
    passive: !0
  };

  function Fe(t, e, i) {
    t.addEventListener(e, i, Te);
  }

  function Le(t, e, i) {
    t.removeEventListener(e, i, Te);
  }

  function Re(t, e, i, n, a) {
    return {
      type: t,
      chart: e,
      native: a || null,
      x: void 0 !== i ? i : null,
      y: void 0 !== n ? n : null
    };
  }

  function Oe(t) {
    var e = document.createElement("div");
    return e.className = t || "", e;
  }

  function ze(t, e, i) {
    var n,
        a,
        o,
        r,
        s = t[_e] || (t[_e] = {}),
        l = s.resizer = function (t) {
      var e = Oe(Ce),
          i = Oe(Ce + "-expand"),
          n = Oe(Ce + "-shrink");
      i.appendChild(Oe()), n.appendChild(Oe()), e.appendChild(i), e.appendChild(n), e._reset = function () {
        i.scrollLeft = 1e6, i.scrollTop = 1e6, n.scrollLeft = 1e6, n.scrollTop = 1e6;
      };

      var a = function a() {
        e._reset(), t();
      };

      return Fe(i, "scroll", a.bind(i, "expand")), Fe(n, "scroll", a.bind(n, "shrink")), e;
    }((n = function n() {
      if (s.resizer) {
        var n = i.options.maintainAspectRatio && t.parentNode,
            a = n ? n.clientWidth : 0;
        e(Re("resize", i)), n && n.clientWidth < a && i.canvas && e(Re("resize", i));
      }
    }, o = !1, r = [], function () {
      r = Array.prototype.slice.call(arguments), a = a || this, o || (o = !0, ut.requestAnimFrame.call(window, function () {
        o = !1, n.apply(a, r);
      }));
    }));

    !function (t, e) {
      var i = t[_e] || (t[_e] = {}),
          n = i.renderProxy = function (t) {
        t.animationName === Pe && e();
      };

      ut.each(Ie, function (e) {
        Fe(t, e, n);
      }), i.reflow = !!t.offsetParent, t.classList.add(Se);
    }(t, function () {
      if (s.resizer) {
        var e = t.parentNode;
        e && e !== l.parentNode && e.insertBefore(l, e.firstChild), l._reset();
      }
    });
  }

  function Be(t) {
    var e = t[_e] || {},
        i = e.resizer;
    delete e.resizer, function (t) {
      var e = t[_e] || {},
          i = e.renderProxy;
      i && (ut.each(Ie, function (e) {
        Le(t, e, i);
      }), delete e.renderProxy), t.classList.remove(Se);
    }(t), i && i.parentNode && i.parentNode.removeChild(i);
  }

  var Ne = {
    disableCSSInjection: !1,
    _enabled: "undefined" != typeof window && "undefined" != typeof document,
    _ensureLoaded: function _ensureLoaded() {
      var t, e, i;
      this._loaded || (this._loaded = !0, this.disableCSSInjection || (e = Me, i = (t = this)._style || document.createElement("style"), t._style || (t._style = i, e = "/* Chart.js */\n" + e, i.setAttribute("type", "text/css"), document.getElementsByTagName("head")[0].appendChild(i)), i.appendChild(document.createTextNode(e))));
    },
    acquireContext: function acquireContext(t, e) {
      "string" == typeof t ? t = document.getElementById(t) : t.length && (t = t[0]), t && t.canvas && (t = t.canvas);
      var i = t && t.getContext && t.getContext("2d");
      return this._ensureLoaded(), i && i.canvas === t ? (function (t, e) {
        var i = t.style,
            n = t.getAttribute("height"),
            a = t.getAttribute("width");

        if (t[_e] = {
          initial: {
            height: n,
            width: a,
            style: {
              display: i.display,
              height: i.height,
              width: i.width
            }
          }
        }, i.display = i.display || "block", null === a || "" === a) {
          var o = De(t, "width");
          void 0 !== o && (t.width = o);
        }

        if (null === n || "" === n) if ("" === t.style.height) t.height = t.width / (e.options.aspectRatio || 2);else {
          var r = De(t, "height");
          void 0 !== o && (t.height = r);
        }
      }(t, e), i) : null;
    },
    releaseContext: function releaseContext(t) {
      var e = t.canvas;

      if (e[_e]) {
        var i = e[_e].initial;
        ["height", "width"].forEach(function (t) {
          var n = i[t];
          ut.isNullOrUndef(n) ? e.removeAttribute(t) : e.setAttribute(t, n);
        }), ut.each(i.style || {}, function (t, i) {
          e.style[i] = t;
        }), e.width = e.width, delete e[_e];
      }
    },
    addEventListener: function addEventListener(t, e, i) {
      var n = t.canvas;

      if ("resize" !== e) {
        var a = i[_e] || (i[_e] = {});
        Fe(n, e, (a.proxies || (a.proxies = {}))[t.id + "_" + e] = function (e) {
          i(function (t, e) {
            var i = Ae[t.type] || t.type,
                n = ut.getRelativePosition(t, e);
            return Re(i, e, n.x, n.y, t);
          }(e, t));
        });
      } else ze(n, i, t);
    },
    removeEventListener: function removeEventListener(t, e, i) {
      var n = t.canvas;

      if ("resize" !== e) {
        var a = ((i[_e] || {}).proxies || {})[t.id + "_" + e];
        a && Le(n, e, a);
      } else Be(n);
    }
  };
  ut.addEvent = Fe, ut.removeEvent = Le;
  var We = Ne._enabled ? Ne : {
    acquireContext: function acquireContext(t) {
      return t && t.canvas && (t = t.canvas), t && t.getContext("2d") || null;
    }
  },
      Ve = ut.extend({
    initialize: function initialize() {},
    acquireContext: function acquireContext() {},
    releaseContext: function releaseContext() {},
    addEventListener: function addEventListener() {},
    removeEventListener: function removeEventListener() {}
  }, We);

  st._set("global", {
    plugins: {}
  });

  var Ee = {
    _plugins: [],
    _cacheId: 0,
    register: function register(t) {
      var e = this._plugins;
      [].concat(t).forEach(function (t) {
        -1 === e.indexOf(t) && e.push(t);
      }), this._cacheId++;
    },
    unregister: function unregister(t) {
      var e = this._plugins;
      [].concat(t).forEach(function (t) {
        var i = e.indexOf(t);
        -1 !== i && e.splice(i, 1);
      }), this._cacheId++;
    },
    clear: function clear() {
      this._plugins = [], this._cacheId++;
    },
    count: function count() {
      return this._plugins.length;
    },
    getAll: function getAll() {
      return this._plugins;
    },
    notify: function notify(t, e, i) {
      var n,
          a,
          o,
          r,
          s,
          l = this.descriptors(t),
          d = l.length;

      for (n = 0; n < d; ++n) {
        if ("function" == typeof (s = (o = (a = l[n]).plugin)[e]) && ((r = [t].concat(i || [])).push(a.options), !1 === s.apply(o, r))) return !1;
      }

      return !0;
    },
    descriptors: function descriptors(t) {
      var e = t.$plugins || (t.$plugins = {});
      if (e.id === this._cacheId) return e.descriptors;
      var i = [],
          n = [],
          a = t && t.config || {},
          o = a.options && a.options.plugins || {};
      return this._plugins.concat(a.plugins || []).forEach(function (t) {
        if (-1 === i.indexOf(t)) {
          var e = t.id,
              a = o[e];
          !1 !== a && (!0 === a && (a = ut.clone(st.global.plugins[e])), i.push(t), n.push({
            plugin: t,
            options: a || {}
          }));
        }
      }), e.descriptors = n, e.id = this._cacheId, n;
    },
    _invalidate: function _invalidate(t) {
      delete t.$plugins;
    }
  },
      He = {
    constructors: {},
    defaults: {},
    registerScaleType: function registerScaleType(t, e, i) {
      this.constructors[t] = e, this.defaults[t] = ut.clone(i);
    },
    getScaleConstructor: function getScaleConstructor(t) {
      return this.constructors.hasOwnProperty(t) ? this.constructors[t] : void 0;
    },
    getScaleDefaults: function getScaleDefaults(t) {
      return this.defaults.hasOwnProperty(t) ? ut.merge({}, [st.scale, this.defaults[t]]) : {};
    },
    updateScaleDefaults: function updateScaleDefaults(t, e) {
      this.defaults.hasOwnProperty(t) && (this.defaults[t] = ut.extend(this.defaults[t], e));
    },
    addScalesToLayout: function addScalesToLayout(t) {
      ut.each(t.scales, function (e) {
        e.fullWidth = e.options.fullWidth, e.position = e.options.position, e.weight = e.options.weight, ke.addBox(t, e);
      });
    }
  },
      je = ut.valueOrDefault;

  st._set("global", {
    tooltips: {
      enabled: !0,
      custom: null,
      mode: "nearest",
      position: "average",
      intersect: !0,
      backgroundColor: "rgba(0,0,0,0.8)",
      titleFontStyle: "bold",
      titleSpacing: 2,
      titleMarginBottom: 6,
      titleFontColor: "#fff",
      titleAlign: "left",
      bodySpacing: 2,
      bodyFontColor: "#fff",
      bodyAlign: "left",
      footerFontStyle: "bold",
      footerSpacing: 2,
      footerMarginTop: 6,
      footerFontColor: "#fff",
      footerAlign: "left",
      yPadding: 6,
      xPadding: 6,
      caretPadding: 2,
      caretSize: 5,
      cornerRadius: 6,
      multiKeyBackground: "#fff",
      displayColors: !0,
      borderColor: "rgba(0,0,0,0)",
      borderWidth: 0,
      callbacks: {
        beforeTitle: ut.noop,
        title: function title(t, e) {
          var i = "",
              n = e.labels,
              a = n ? n.length : 0;

          if (t.length > 0) {
            var o = t[0];
            o.label ? i = o.label : o.xLabel ? i = o.xLabel : a > 0 && o.index < a && (i = n[o.index]);
          }

          return i;
        },
        afterTitle: ut.noop,
        beforeBody: ut.noop,
        beforeLabel: ut.noop,
        label: function label(t, e) {
          var i = e.datasets[t.datasetIndex].label || "";
          return i && (i += ": "), ut.isNullOrUndef(t.value) ? i += t.yLabel : i += t.value, i;
        },
        labelColor: function labelColor(t, e) {
          var i = e.getDatasetMeta(t.datasetIndex).data[t.index]._view;

          return {
            borderColor: i.borderColor,
            backgroundColor: i.backgroundColor
          };
        },
        labelTextColor: function labelTextColor() {
          return this._options.bodyFontColor;
        },
        afterLabel: ut.noop,
        afterBody: ut.noop,
        beforeFooter: ut.noop,
        footer: ut.noop,
        afterFooter: ut.noop
      }
    }
  });

  var qe = {
    average: function average(t) {
      if (!t.length) return !1;
      var e,
          i,
          n = 0,
          a = 0,
          o = 0;

      for (e = 0, i = t.length; e < i; ++e) {
        var r = t[e];

        if (r && r.hasValue()) {
          var s = r.tooltipPosition();
          n += s.x, a += s.y, ++o;
        }
      }

      return {
        x: n / o,
        y: a / o
      };
    },
    nearest: function nearest(t, e) {
      var i,
          n,
          a,
          o = e.x,
          r = e.y,
          s = Number.POSITIVE_INFINITY;

      for (i = 0, n = t.length; i < n; ++i) {
        var l = t[i];

        if (l && l.hasValue()) {
          var d = l.getCenterPoint(),
              u = ut.distanceBetweenPoints(e, d);
          u < s && (s = u, a = l);
        }
      }

      if (a) {
        var h = a.tooltipPosition();
        o = h.x, r = h.y;
      }

      return {
        x: o,
        y: r
      };
    }
  };

  function Ye(t, e) {
    return e && (ut.isArray(e) ? Array.prototype.push.apply(t, e) : t.push(e)), t;
  }

  function Ue(t) {
    return ("string" == typeof t || t instanceof String) && t.indexOf("\n") > -1 ? t.split("\n") : t;
  }

  function Xe(t) {
    var e = st.global;
    return {
      xPadding: t.xPadding,
      yPadding: t.yPadding,
      xAlign: t.xAlign,
      yAlign: t.yAlign,
      bodyFontColor: t.bodyFontColor,
      _bodyFontFamily: je(t.bodyFontFamily, e.defaultFontFamily),
      _bodyFontStyle: je(t.bodyFontStyle, e.defaultFontStyle),
      _bodyAlign: t.bodyAlign,
      bodyFontSize: je(t.bodyFontSize, e.defaultFontSize),
      bodySpacing: t.bodySpacing,
      titleFontColor: t.titleFontColor,
      _titleFontFamily: je(t.titleFontFamily, e.defaultFontFamily),
      _titleFontStyle: je(t.titleFontStyle, e.defaultFontStyle),
      titleFontSize: je(t.titleFontSize, e.defaultFontSize),
      _titleAlign: t.titleAlign,
      titleSpacing: t.titleSpacing,
      titleMarginBottom: t.titleMarginBottom,
      footerFontColor: t.footerFontColor,
      _footerFontFamily: je(t.footerFontFamily, e.defaultFontFamily),
      _footerFontStyle: je(t.footerFontStyle, e.defaultFontStyle),
      footerFontSize: je(t.footerFontSize, e.defaultFontSize),
      _footerAlign: t.footerAlign,
      footerSpacing: t.footerSpacing,
      footerMarginTop: t.footerMarginTop,
      caretSize: t.caretSize,
      cornerRadius: t.cornerRadius,
      backgroundColor: t.backgroundColor,
      opacity: 0,
      legendColorBackground: t.multiKeyBackground,
      displayColors: t.displayColors,
      borderColor: t.borderColor,
      borderWidth: t.borderWidth
    };
  }

  function Ke(t, e) {
    return "center" === e ? t.x + t.width / 2 : "right" === e ? t.x + t.width - t.xPadding : t.x + t.xPadding;
  }

  function Ge(t) {
    return Ye([], Ue(t));
  }

  var Ze = pt.extend({
    initialize: function initialize() {
      this._model = Xe(this._options), this._lastActive = [];
    },
    getTitle: function getTitle() {
      var t = this._options.callbacks,
          e = t.beforeTitle.apply(this, arguments),
          i = t.title.apply(this, arguments),
          n = t.afterTitle.apply(this, arguments),
          a = [];
      return a = Ye(a, Ue(e)), a = Ye(a, Ue(i)), a = Ye(a, Ue(n));
    },
    getBeforeBody: function getBeforeBody() {
      return Ge(this._options.callbacks.beforeBody.apply(this, arguments));
    },
    getBody: function getBody(t, e) {
      var i = this,
          n = i._options.callbacks,
          a = [];
      return ut.each(t, function (t) {
        var o = {
          before: [],
          lines: [],
          after: []
        };
        Ye(o.before, Ue(n.beforeLabel.call(i, t, e))), Ye(o.lines, n.label.call(i, t, e)), Ye(o.after, Ue(n.afterLabel.call(i, t, e))), a.push(o);
      }), a;
    },
    getAfterBody: function getAfterBody() {
      return Ge(this._options.callbacks.afterBody.apply(this, arguments));
    },
    getFooter: function getFooter() {
      var t = this._options.callbacks,
          e = t.beforeFooter.apply(this, arguments),
          i = t.footer.apply(this, arguments),
          n = t.afterFooter.apply(this, arguments),
          a = [];
      return a = Ye(a, Ue(e)), a = Ye(a, Ue(i)), a = Ye(a, Ue(n));
    },
    update: function update(t) {
      var e,
          i,
          n,
          a,
          o,
          r,
          s,
          l,
          d,
          u,
          h = this,
          c = h._options,
          f = h._model,
          g = h._model = Xe(c),
          p = h._active,
          m = h._data,
          v = {
        xAlign: f.xAlign,
        yAlign: f.yAlign
      },
          b = {
        x: f.x,
        y: f.y
      },
          x = {
        width: f.width,
        height: f.height
      },
          y = {
        x: f.caretX,
        y: f.caretY
      };

      if (p.length) {
        g.opacity = 1;
        var k = [],
            w = [];
        y = qe[c.position].call(h, p, h._eventPosition);
        var M = [];

        for (e = 0, i = p.length; e < i; ++e) {
          M.push((n = p[e], a = void 0, o = void 0, r = void 0, s = void 0, l = void 0, d = void 0, u = void 0, a = n._xScale, o = n._yScale || n._scale, r = n._index, s = n._datasetIndex, l = n._chart.getDatasetMeta(s).controller, d = l._getIndexScale(), u = l._getValueScale(), {
            xLabel: a ? a.getLabelForIndex(r, s) : "",
            yLabel: o ? o.getLabelForIndex(r, s) : "",
            label: d ? "" + d.getLabelForIndex(r, s) : "",
            value: u ? "" + u.getLabelForIndex(r, s) : "",
            index: r,
            datasetIndex: s,
            x: n._model.x,
            y: n._model.y
          }));
        }

        c.filter && (M = M.filter(function (t) {
          return c.filter(t, m);
        })), c.itemSort && (M = M.sort(function (t, e) {
          return c.itemSort(t, e, m);
        })), ut.each(M, function (t) {
          k.push(c.callbacks.labelColor.call(h, t, h._chart)), w.push(c.callbacks.labelTextColor.call(h, t, h._chart));
        }), g.title = h.getTitle(M, m), g.beforeBody = h.getBeforeBody(M, m), g.body = h.getBody(M, m), g.afterBody = h.getAfterBody(M, m), g.footer = h.getFooter(M, m), g.x = y.x, g.y = y.y, g.caretPadding = c.caretPadding, g.labelColors = k, g.labelTextColors = w, g.dataPoints = M, x = function (t, e) {
          var i = t._chart.ctx,
              n = 2 * e.yPadding,
              a = 0,
              o = e.body,
              r = o.reduce(function (t, e) {
            return t + e.before.length + e.lines.length + e.after.length;
          }, 0);
          r += e.beforeBody.length + e.afterBody.length;
          var s = e.title.length,
              l = e.footer.length,
              d = e.titleFontSize,
              u = e.bodyFontSize,
              h = e.footerFontSize;
          n += s * d, n += s ? (s - 1) * e.titleSpacing : 0, n += s ? e.titleMarginBottom : 0, n += r * u, n += r ? (r - 1) * e.bodySpacing : 0, n += l ? e.footerMarginTop : 0, n += l * h, n += l ? (l - 1) * e.footerSpacing : 0;

          var c = 0,
              f = function f(t) {
            a = Math.max(a, i.measureText(t).width + c);
          };

          return i.font = ut.fontString(d, e._titleFontStyle, e._titleFontFamily), ut.each(e.title, f), i.font = ut.fontString(u, e._bodyFontStyle, e._bodyFontFamily), ut.each(e.beforeBody.concat(e.afterBody), f), c = e.displayColors ? u + 2 : 0, ut.each(o, function (t) {
            ut.each(t.before, f), ut.each(t.lines, f), ut.each(t.after, f);
          }), c = 0, i.font = ut.fontString(h, e._footerFontStyle, e._footerFontFamily), ut.each(e.footer, f), {
            width: a += 2 * e.xPadding,
            height: n
          };
        }(this, g), b = function (t, e, i, n) {
          var a = t.x,
              o = t.y,
              r = t.caretSize,
              s = t.caretPadding,
              l = t.cornerRadius,
              d = i.xAlign,
              u = i.yAlign,
              h = r + s,
              c = l + s;
          return "right" === d ? a -= e.width : "center" === d && ((a -= e.width / 2) + e.width > n.width && (a = n.width - e.width), a < 0 && (a = 0)), "top" === u ? o += h : o -= "bottom" === u ? e.height + h : e.height / 2, "center" === u ? "left" === d ? a += h : "right" === d && (a -= h) : "left" === d ? a -= c : "right" === d && (a += c), {
            x: a,
            y: o
          };
        }(g, x, v = function (t, e) {
          var i,
              n,
              a,
              o,
              r,
              s = t._model,
              l = t._chart,
              d = t._chart.chartArea,
              u = "center",
              h = "center";
          s.y < e.height ? h = "top" : s.y > l.height - e.height && (h = "bottom");
          var c = (d.left + d.right) / 2,
              f = (d.top + d.bottom) / 2;
          "center" === h ? (i = function i(t) {
            return t <= c;
          }, n = function n(t) {
            return t > c;
          }) : (i = function i(t) {
            return t <= e.width / 2;
          }, n = function n(t) {
            return t >= l.width - e.width / 2;
          }), a = function a(t) {
            return t + e.width + s.caretSize + s.caretPadding > l.width;
          }, o = function o(t) {
            return t - e.width - s.caretSize - s.caretPadding < 0;
          }, r = function r(t) {
            return t <= f ? "top" : "bottom";
          }, i(s.x) ? (u = "left", a(s.x) && (u = "center", h = r(s.y))) : n(s.x) && (u = "right", o(s.x) && (u = "center", h = r(s.y)));
          var g = t._options;
          return {
            xAlign: g.xAlign ? g.xAlign : u,
            yAlign: g.yAlign ? g.yAlign : h
          };
        }(this, x), h._chart);
      } else g.opacity = 0;

      return g.xAlign = v.xAlign, g.yAlign = v.yAlign, g.x = b.x, g.y = b.y, g.width = x.width, g.height = x.height, g.caretX = y.x, g.caretY = y.y, h._model = g, t && c.custom && c.custom.call(h, g), h;
    },
    drawCaret: function drawCaret(t, e) {
      var i = this._chart.ctx,
          n = this._view,
          a = this.getCaretPosition(t, e, n);
      i.lineTo(a.x1, a.y1), i.lineTo(a.x2, a.y2), i.lineTo(a.x3, a.y3);
    },
    getCaretPosition: function getCaretPosition(t, e, i) {
      var n,
          a,
          o,
          r,
          s,
          l,
          d = i.caretSize,
          u = i.cornerRadius,
          h = i.xAlign,
          c = i.yAlign,
          f = t.x,
          g = t.y,
          p = e.width,
          m = e.height;
      if ("center" === c) s = g + m / 2, "left" === h ? (a = (n = f) - d, o = n, r = s + d, l = s - d) : (a = (n = f + p) + d, o = n, r = s - d, l = s + d);else if ("left" === h ? (n = (a = f + u + d) - d, o = a + d) : "right" === h ? (n = (a = f + p - u - d) - d, o = a + d) : (n = (a = i.caretX) - d, o = a + d), "top" === c) s = (r = g) - d, l = r;else {
        s = (r = g + m) + d, l = r;
        var v = o;
        o = n, n = v;
      }
      return {
        x1: n,
        x2: a,
        x3: o,
        y1: r,
        y2: s,
        y3: l
      };
    },
    drawTitle: function drawTitle(t, e, i) {
      var n = e.title;

      if (n.length) {
        t.x = Ke(e, e._titleAlign), i.textAlign = e._titleAlign, i.textBaseline = "top";
        var a,
            o,
            r = e.titleFontSize,
            s = e.titleSpacing;

        for (i.fillStyle = e.titleFontColor, i.font = ut.fontString(r, e._titleFontStyle, e._titleFontFamily), a = 0, o = n.length; a < o; ++a) {
          i.fillText(n[a], t.x, t.y), t.y += r + s, a + 1 === n.length && (t.y += e.titleMarginBottom - s);
        }
      }
    },
    drawBody: function drawBody(t, e, i) {
      var n,
          a = e.bodyFontSize,
          o = e.bodySpacing,
          r = e._bodyAlign,
          s = e.body,
          l = e.displayColors,
          d = e.labelColors,
          u = 0,
          h = l ? Ke(e, "left") : 0;
      i.textAlign = r, i.textBaseline = "top", i.font = ut.fontString(a, e._bodyFontStyle, e._bodyFontFamily), t.x = Ke(e, r);

      var c = function c(e) {
        i.fillText(e, t.x + u, t.y), t.y += a + o;
      };

      i.fillStyle = e.bodyFontColor, ut.each(e.beforeBody, c), u = l && "right" !== r ? "center" === r ? a / 2 + 1 : a + 2 : 0, ut.each(s, function (o, r) {
        n = e.labelTextColors[r], i.fillStyle = n, ut.each(o.before, c), ut.each(o.lines, function (o) {
          l && (i.fillStyle = e.legendColorBackground, i.fillRect(h, t.y, a, a), i.lineWidth = 1, i.strokeStyle = d[r].borderColor, i.strokeRect(h, t.y, a, a), i.fillStyle = d[r].backgroundColor, i.fillRect(h + 1, t.y + 1, a - 2, a - 2), i.fillStyle = n), c(o);
        }), ut.each(o.after, c);
      }), u = 0, ut.each(e.afterBody, c), t.y -= o;
    },
    drawFooter: function drawFooter(t, e, i) {
      var n = e.footer;
      n.length && (t.x = Ke(e, e._footerAlign), t.y += e.footerMarginTop, i.textAlign = e._footerAlign, i.textBaseline = "top", i.fillStyle = e.footerFontColor, i.font = ut.fontString(e.footerFontSize, e._footerFontStyle, e._footerFontFamily), ut.each(n, function (n) {
        i.fillText(n, t.x, t.y), t.y += e.footerFontSize + e.footerSpacing;
      }));
    },
    drawBackground: function drawBackground(t, e, i, n) {
      i.fillStyle = e.backgroundColor, i.strokeStyle = e.borderColor, i.lineWidth = e.borderWidth;
      var a = e.xAlign,
          o = e.yAlign,
          r = t.x,
          s = t.y,
          l = n.width,
          d = n.height,
          u = e.cornerRadius;
      i.beginPath(), i.moveTo(r + u, s), "top" === o && this.drawCaret(t, n), i.lineTo(r + l - u, s), i.quadraticCurveTo(r + l, s, r + l, s + u), "center" === o && "right" === a && this.drawCaret(t, n), i.lineTo(r + l, s + d - u), i.quadraticCurveTo(r + l, s + d, r + l - u, s + d), "bottom" === o && this.drawCaret(t, n), i.lineTo(r + u, s + d), i.quadraticCurveTo(r, s + d, r, s + d - u), "center" === o && "left" === a && this.drawCaret(t, n), i.lineTo(r, s + u), i.quadraticCurveTo(r, s, r + u, s), i.closePath(), i.fill(), e.borderWidth > 0 && i.stroke();
    },
    draw: function draw() {
      var t = this._chart.ctx,
          e = this._view;

      if (0 !== e.opacity) {
        var i = {
          width: e.width,
          height: e.height
        },
            n = {
          x: e.x,
          y: e.y
        },
            a = Math.abs(e.opacity < .001) ? 0 : e.opacity,
            o = e.title.length || e.beforeBody.length || e.body.length || e.afterBody.length || e.footer.length;
        this._options.enabled && o && (t.save(), t.globalAlpha = a, this.drawBackground(n, e, t, i), n.y += e.yPadding, this.drawTitle(n, e, t), this.drawBody(n, e, t), this.drawFooter(n, e, t), t.restore());
      }
    },
    handleEvent: function handleEvent(t) {
      var e,
          i = this,
          n = i._options;
      return i._lastActive = i._lastActive || [], "mouseout" === t.type ? i._active = [] : i._active = i._chart.getElementsAtEventForMode(t, n.mode, n), (e = !ut.arrayEquals(i._active, i._lastActive)) && (i._lastActive = i._active, (n.enabled || n.custom) && (i._eventPosition = {
        x: t.x,
        y: t.y
      }, i.update(!0), i.pivot())), e;
    }
  }),
      $e = qe,
      Je = Ze;
  Je.positioners = $e;
  var Qe = ut.valueOrDefault;

  function ti() {
    return ut.merge({}, [].slice.call(arguments), {
      merger: function merger(t, e, i, n) {
        if ("xAxes" === t || "yAxes" === t) {
          var a,
              o,
              r,
              s = i[t].length;

          for (e[t] || (e[t] = []), a = 0; a < s; ++a) {
            r = i[t][a], o = Qe(r.type, "xAxes" === t ? "category" : "linear"), a >= e[t].length && e[t].push({}), !e[t][a].type || r.type && r.type !== e[t][a].type ? ut.merge(e[t][a], [He.getScaleDefaults(o), r]) : ut.merge(e[t][a], r);
          }
        } else ut._merger(t, e, i, n);
      }
    });
  }

  function ei() {
    return ut.merge({}, [].slice.call(arguments), {
      merger: function merger(t, e, i, n) {
        var a = e[t] || {},
            o = i[t];
        "scales" === t ? e[t] = ti(a, o) : "scale" === t ? e[t] = ut.merge(a, [He.getScaleDefaults(o.type), o]) : ut._merger(t, e, i, n);
      }
    });
  }

  function ii(t) {
    return "top" === t || "bottom" === t;
  }

  st._set("global", {
    elements: {},
    events: ["mousemove", "mouseout", "click", "touchstart", "touchmove"],
    hover: {
      onHover: null,
      mode: "nearest",
      intersect: !0,
      animationDuration: 400
    },
    onClick: null,
    maintainAspectRatio: !0,
    responsive: !0,
    responsiveAnimationDuration: 0
  });

  var ni = function ni(t, e) {
    return this.construct(t, e), this;
  };

  ut.extend(ni.prototype, {
    construct: function construct(t, e) {
      var i = this;

      e = function (t) {
        var e = (t = t || {}).data = t.data || {};
        return e.datasets = e.datasets || [], e.labels = e.labels || [], t.options = ei(st.global, st[t.type], t.options || {}), t;
      }(e);

      var n = Ve.acquireContext(t, e),
          a = n && n.canvas,
          o = a && a.height,
          r = a && a.width;
      i.id = ut.uid(), i.ctx = n, i.canvas = a, i.config = e, i.width = r, i.height = o, i.aspectRatio = o ? r / o : null, i.options = e.options, i._bufferedRender = !1, i.chart = i, i.controller = i, ni.instances[i.id] = i, Object.defineProperty(i, "data", {
        get: function get() {
          return i.config.data;
        },
        set: function set(t) {
          i.config.data = t;
        }
      }), n && a ? (i.initialize(), i.update()) : console.error("Failed to create chart: can't acquire context from the given item");
    },
    initialize: function initialize() {
      var t = this;
      return Ee.notify(t, "beforeInit"), ut.retinaScale(t, t.options.devicePixelRatio), t.bindEvents(), t.options.responsive && t.resize(!0), t.ensureScalesHaveIDs(), t.buildOrUpdateScales(), t.initToolTip(), Ee.notify(t, "afterInit"), t;
    },
    clear: function clear() {
      return ut.canvas.clear(this), this;
    },
    stop: function stop() {
      return bt.cancelAnimation(this), this;
    },
    resize: function resize(t) {
      var e = this,
          i = e.options,
          n = e.canvas,
          a = i.maintainAspectRatio && e.aspectRatio || null,
          o = Math.max(0, Math.floor(ut.getMaximumWidth(n))),
          r = Math.max(0, Math.floor(a ? o / a : ut.getMaximumHeight(n)));

      if ((e.width !== o || e.height !== r) && (n.width = e.width = o, n.height = e.height = r, n.style.width = o + "px", n.style.height = r + "px", ut.retinaScale(e, i.devicePixelRatio), !t)) {
        var s = {
          width: o,
          height: r
        };
        Ee.notify(e, "resize", [s]), i.onResize && i.onResize(e, s), e.stop(), e.update({
          duration: i.responsiveAnimationDuration
        });
      }
    },
    ensureScalesHaveIDs: function ensureScalesHaveIDs() {
      var t = this.options,
          e = t.scales || {},
          i = t.scale;
      ut.each(e.xAxes, function (t, e) {
        t.id = t.id || "x-axis-" + e;
      }), ut.each(e.yAxes, function (t, e) {
        t.id = t.id || "y-axis-" + e;
      }), i && (i.id = i.id || "scale");
    },
    buildOrUpdateScales: function buildOrUpdateScales() {
      var t = this,
          e = t.options,
          i = t.scales || {},
          n = [],
          a = Object.keys(i).reduce(function (t, e) {
        return t[e] = !1, t;
      }, {});
      e.scales && (n = n.concat((e.scales.xAxes || []).map(function (t) {
        return {
          options: t,
          dtype: "category",
          dposition: "bottom"
        };
      }), (e.scales.yAxes || []).map(function (t) {
        return {
          options: t,
          dtype: "linear",
          dposition: "left"
        };
      }))), e.scale && n.push({
        options: e.scale,
        dtype: "radialLinear",
        isDefault: !0,
        dposition: "chartArea"
      }), ut.each(n, function (e) {
        var n = e.options,
            o = n.id,
            r = Qe(n.type, e.dtype);
        ii(n.position) !== ii(e.dposition) && (n.position = e.dposition), a[o] = !0;
        var s = null;
        if (o in i && i[o].type === r) (s = i[o]).options = n, s.ctx = t.ctx, s.chart = t;else {
          var l = He.getScaleConstructor(r);
          if (!l) return;
          s = new l({
            id: o,
            type: r,
            options: n,
            ctx: t.ctx,
            chart: t
          }), i[s.id] = s;
        }
        s.mergeTicksOptions(), e.isDefault && (t.scale = s);
      }), ut.each(a, function (t, e) {
        t || delete i[e];
      }), t.scales = i, He.addScalesToLayout(this);
    },
    buildOrUpdateControllers: function buildOrUpdateControllers() {
      var t = this,
          e = [];
      return ut.each(t.data.datasets, function (i, n) {
        var a = t.getDatasetMeta(n),
            o = i.type || t.config.type;
        if (a.type && a.type !== o && (t.destroyDatasetMeta(n), a = t.getDatasetMeta(n)), a.type = o, a.controller) a.controller.updateIndex(n), a.controller.linkScales();else {
          var r = ue[a.type];
          if (void 0 === r) throw new Error('"' + a.type + '" is not a chart type.');
          a.controller = new r(t, n), e.push(a.controller);
        }
      }, t), e;
    },
    resetElements: function resetElements() {
      var t = this;
      ut.each(t.data.datasets, function (e, i) {
        t.getDatasetMeta(i).controller.reset();
      }, t);
    },
    reset: function reset() {
      this.resetElements(), this.tooltip.initialize();
    },
    update: function update(t) {
      var e,
          i,
          n = this;

      if (t && "object" == _typeof(t) || (t = {
        duration: t,
        lazy: arguments[1]
      }), i = (e = n).options, ut.each(e.scales, function (t) {
        ke.removeBox(e, t);
      }), i = ei(st.global, st[e.config.type], i), e.options = e.config.options = i, e.ensureScalesHaveIDs(), e.buildOrUpdateScales(), e.tooltip._options = i.tooltips, e.tooltip.initialize(), Ee._invalidate(n), !1 !== Ee.notify(n, "beforeUpdate")) {
        n.tooltip._data = n.data;
        var a = n.buildOrUpdateControllers();
        ut.each(n.data.datasets, function (t, e) {
          n.getDatasetMeta(e).controller.buildOrUpdateElements();
        }, n), n.updateLayout(), n.options.animation && n.options.animation.duration && ut.each(a, function (t) {
          t.reset();
        }), n.updateDatasets(), n.tooltip.initialize(), n.lastActive = [], Ee.notify(n, "afterUpdate"), n._bufferedRender ? n._bufferedRequest = {
          duration: t.duration,
          easing: t.easing,
          lazy: t.lazy
        } : n.render(t);
      }
    },
    updateLayout: function updateLayout() {
      !1 !== Ee.notify(this, "beforeLayout") && (ke.update(this, this.width, this.height), Ee.notify(this, "afterScaleUpdate"), Ee.notify(this, "afterLayout"));
    },
    updateDatasets: function updateDatasets() {
      if (!1 !== Ee.notify(this, "beforeDatasetsUpdate")) {
        for (var t = 0, e = this.data.datasets.length; t < e; ++t) {
          this.updateDataset(t);
        }

        Ee.notify(this, "afterDatasetsUpdate");
      }
    },
    updateDataset: function updateDataset(t) {
      var e = this.getDatasetMeta(t),
          i = {
        meta: e,
        index: t
      };
      !1 !== Ee.notify(this, "beforeDatasetUpdate", [i]) && (e.controller.update(), Ee.notify(this, "afterDatasetUpdate", [i]));
    },
    render: function render(t) {
      var e = this;
      t && "object" == _typeof(t) || (t = {
        duration: t,
        lazy: arguments[1]
      });
      var i = e.options.animation,
          n = Qe(t.duration, i && i.duration),
          a = t.lazy;

      if (!1 !== Ee.notify(e, "beforeRender")) {
        var o = function o(t) {
          Ee.notify(e, "afterRender"), ut.callback(i && i.onComplete, [t], e);
        };

        if (i && n) {
          var r = new vt({
            numSteps: n / 16.66,
            easing: t.easing || i.easing,
            render: function render(t, e) {
              var i = ut.easing.effects[e.easing],
                  n = e.currentStep,
                  a = n / e.numSteps;
              t.draw(i(a), a, n);
            },
            onAnimationProgress: i.onProgress,
            onAnimationComplete: o
          });
          bt.addAnimation(e, r, n, a);
        } else e.draw(), o(new vt({
          numSteps: 0,
          chart: e
        }));

        return e;
      }
    },
    draw: function draw(t) {
      var e = this;
      e.clear(), ut.isNullOrUndef(t) && (t = 1), e.transition(t), e.width <= 0 || e.height <= 0 || !1 !== Ee.notify(e, "beforeDraw", [t]) && (ut.each(e.boxes, function (t) {
        t.draw(e.chartArea);
      }, e), e.drawDatasets(t), e._drawTooltip(t), Ee.notify(e, "afterDraw", [t]));
    },
    transition: function transition(t) {
      for (var e = 0, i = (this.data.datasets || []).length; e < i; ++e) {
        this.isDatasetVisible(e) && this.getDatasetMeta(e).controller.transition(t);
      }

      this.tooltip.transition(t);
    },
    drawDatasets: function drawDatasets(t) {
      var e = this;

      if (!1 !== Ee.notify(e, "beforeDatasetsDraw", [t])) {
        for (var i = (e.data.datasets || []).length - 1; i >= 0; --i) {
          e.isDatasetVisible(i) && e.drawDataset(i, t);
        }

        Ee.notify(e, "afterDatasetsDraw", [t]);
      }
    },
    drawDataset: function drawDataset(t, e) {
      var i = this.getDatasetMeta(t),
          n = {
        meta: i,
        index: t,
        easingValue: e
      };
      !1 !== Ee.notify(this, "beforeDatasetDraw", [n]) && (i.controller.draw(e), Ee.notify(this, "afterDatasetDraw", [n]));
    },
    _drawTooltip: function _drawTooltip(t) {
      var e = this.tooltip,
          i = {
        tooltip: e,
        easingValue: t
      };
      !1 !== Ee.notify(this, "beforeTooltipDraw", [i]) && (e.draw(), Ee.notify(this, "afterTooltipDraw", [i]));
    },
    getElementAtEvent: function getElementAtEvent(t) {
      return ve.modes.single(this, t);
    },
    getElementsAtEvent: function getElementsAtEvent(t) {
      return ve.modes.label(this, t, {
        intersect: !0
      });
    },
    getElementsAtXAxis: function getElementsAtXAxis(t) {
      return ve.modes["x-axis"](this, t, {
        intersect: !0
      });
    },
    getElementsAtEventForMode: function getElementsAtEventForMode(t, e, i) {
      var n = ve.modes[e];
      return "function" == typeof n ? n(this, t, i) : [];
    },
    getDatasetAtEvent: function getDatasetAtEvent(t) {
      return ve.modes.dataset(this, t, {
        intersect: !0
      });
    },
    getDatasetMeta: function getDatasetMeta(t) {
      var e = this.data.datasets[t];
      e._meta || (e._meta = {});
      var i = e._meta[this.id];
      return i || (i = e._meta[this.id] = {
        type: null,
        data: [],
        dataset: null,
        controller: null,
        hidden: null,
        xAxisID: null,
        yAxisID: null
      }), i;
    },
    getVisibleDatasetCount: function getVisibleDatasetCount() {
      for (var t = 0, e = 0, i = this.data.datasets.length; e < i; ++e) {
        this.isDatasetVisible(e) && t++;
      }

      return t;
    },
    isDatasetVisible: function isDatasetVisible(t) {
      var e = this.getDatasetMeta(t);
      return "boolean" == typeof e.hidden ? !e.hidden : !this.data.datasets[t].hidden;
    },
    generateLegend: function generateLegend() {
      return this.options.legendCallback(this);
    },
    destroyDatasetMeta: function destroyDatasetMeta(t) {
      var e = this.id,
          i = this.data.datasets[t],
          n = i._meta && i._meta[e];
      n && (n.controller.destroy(), delete i._meta[e]);
    },
    destroy: function destroy() {
      var t,
          e,
          i = this,
          n = i.canvas;

      for (i.stop(), t = 0, e = i.data.datasets.length; t < e; ++t) {
        i.destroyDatasetMeta(t);
      }

      n && (i.unbindEvents(), ut.canvas.clear(i), Ve.releaseContext(i.ctx), i.canvas = null, i.ctx = null), Ee.notify(i, "destroy"), delete ni.instances[i.id];
    },
    toBase64Image: function toBase64Image() {
      return this.canvas.toDataURL.apply(this.canvas, arguments);
    },
    initToolTip: function initToolTip() {
      var t = this;
      t.tooltip = new Je({
        _chart: t,
        _chartInstance: t,
        _data: t.data,
        _options: t.options.tooltips
      }, t);
    },
    bindEvents: function bindEvents() {
      var t = this,
          e = t._listeners = {},
          i = function i() {
        t.eventHandler.apply(t, arguments);
      };

      ut.each(t.options.events, function (n) {
        Ve.addEventListener(t, n, i), e[n] = i;
      }), t.options.responsive && (i = function i() {
        t.resize();
      }, Ve.addEventListener(t, "resize", i), e.resize = i);
    },
    unbindEvents: function unbindEvents() {
      var t = this,
          e = t._listeners;
      e && (delete t._listeners, ut.each(e, function (e, i) {
        Ve.removeEventListener(t, i, e);
      }));
    },
    updateHoverStyle: function updateHoverStyle(t, e, i) {
      var n,
          a,
          o,
          r = i ? "setHoverStyle" : "removeHoverStyle";

      for (a = 0, o = t.length; a < o; ++a) {
        (n = t[a]) && this.getDatasetMeta(n._datasetIndex).controller[r](n);
      }
    },
    eventHandler: function eventHandler(t) {
      var e = this,
          i = e.tooltip;

      if (!1 !== Ee.notify(e, "beforeEvent", [t])) {
        e._bufferedRender = !0, e._bufferedRequest = null;
        var n = e.handleEvent(t);
        i && (n = i._start ? i.handleEvent(t) : n | i.handleEvent(t)), Ee.notify(e, "afterEvent", [t]);
        var a = e._bufferedRequest;
        return a ? e.render(a) : n && !e.animating && (e.stop(), e.render({
          duration: e.options.hover.animationDuration,
          lazy: !0
        })), e._bufferedRender = !1, e._bufferedRequest = null, e;
      }
    },
    handleEvent: function handleEvent(t) {
      var e,
          i = this,
          n = i.options || {},
          a = n.hover;
      return i.lastActive = i.lastActive || [], "mouseout" === t.type ? i.active = [] : i.active = i.getElementsAtEventForMode(t, a.mode, a), ut.callback(n.onHover || n.hover.onHover, [t.native, i.active], i), "mouseup" !== t.type && "click" !== t.type || n.onClick && n.onClick.call(i, t.native, i.active), i.lastActive.length && i.updateHoverStyle(i.lastActive, a.mode, !1), i.active.length && a.mode && i.updateHoverStyle(i.active, a.mode, !0), e = !ut.arrayEquals(i.active, i.lastActive), i.lastActive = i.active, e;
    }
  }), ni.instances = {};
  var ai = ni;
  ni.Controller = ni, ni.types = {}, ut.configMerge = ei, ut.scaleMerge = ti;

  function oi() {
    throw new Error("This method is not implemented: either no adapter can be found or an incomplete integration was provided.");
  }

  function ri(t) {
    this.options = t || {};
  }

  ut.extend(ri.prototype, {
    formats: oi,
    parse: oi,
    format: oi,
    add: oi,
    diff: oi,
    startOf: oi,
    endOf: oi,
    _create: function _create(t) {
      return t;
    }
  }), ri.override = function (t) {
    ut.extend(ri.prototype, t);
  };
  var si = {
    _date: ri
  },
      li = {
    formatters: {
      values: function values(t) {
        return ut.isArray(t) ? t : "" + t;
      },
      linear: function linear(t, e, i) {
        var n = i.length > 3 ? i[2] - i[1] : i[1] - i[0];
        Math.abs(n) > 1 && t !== Math.floor(t) && (n = t - Math.floor(t));
        var a = ut.log10(Math.abs(n)),
            o = "";
        if (0 !== t) {
          if (Math.max(Math.abs(i[0]), Math.abs(i[i.length - 1])) < 1e-4) {
            var r = ut.log10(Math.abs(t));
            o = t.toExponential(Math.floor(r) - Math.floor(a));
          } else {
            var s = -1 * Math.floor(a);
            s = Math.max(Math.min(s, 20), 0), o = t.toFixed(s);
          }
        } else o = "0";
        return o;
      },
      logarithmic: function logarithmic(t, e, i) {
        var n = t / Math.pow(10, Math.floor(ut.log10(t)));
        return 0 === t ? "0" : 1 === n || 2 === n || 5 === n || 0 === e || e === i.length - 1 ? t.toExponential() : "";
      }
    }
  },
      di = ut.valueOrDefault,
      ui = ut.valueAtIndexOrDefault;

  function hi(t) {
    var e,
        i,
        n = [];

    for (e = 0, i = t.length; e < i; ++e) {
      n.push(t[e].label);
    }

    return n;
  }

  function ci(t, e, i) {
    return ut.isArray(e) ? ut.longestText(t, i, e) : t.measureText(e).width;
  }

  st._set("scale", {
    display: !0,
    position: "left",
    offset: !1,
    gridLines: {
      display: !0,
      color: "rgba(0, 0, 0, 0.1)",
      lineWidth: 1,
      drawBorder: !0,
      drawOnChartArea: !0,
      drawTicks: !0,
      tickMarkLength: 10,
      zeroLineWidth: 1,
      zeroLineColor: "rgba(0,0,0,0.25)",
      zeroLineBorderDash: [],
      zeroLineBorderDashOffset: 0,
      offsetGridLines: !1,
      borderDash: [],
      borderDashOffset: 0
    },
    scaleLabel: {
      display: !1,
      labelString: "",
      padding: {
        top: 4,
        bottom: 4
      }
    },
    ticks: {
      beginAtZero: !1,
      minRotation: 0,
      maxRotation: 50,
      mirror: !1,
      padding: 0,
      reverse: !1,
      display: !0,
      autoSkip: !0,
      autoSkipPadding: 0,
      labelOffset: 0,
      callback: li.formatters.values,
      minor: {},
      major: {}
    }
  });

  var fi = pt.extend({
    getPadding: function getPadding() {
      return {
        left: this.paddingLeft || 0,
        top: this.paddingTop || 0,
        right: this.paddingRight || 0,
        bottom: this.paddingBottom || 0
      };
    },
    getTicks: function getTicks() {
      return this._ticks;
    },
    mergeTicksOptions: function mergeTicksOptions() {
      var t = this.options.ticks;

      for (var e in !1 === t.minor && (t.minor = {
        display: !1
      }), !1 === t.major && (t.major = {
        display: !1
      }), t) {
        "major" !== e && "minor" !== e && (void 0 === t.minor[e] && (t.minor[e] = t[e]), void 0 === t.major[e] && (t.major[e] = t[e]));
      }
    },
    beforeUpdate: function beforeUpdate() {
      ut.callback(this.options.beforeUpdate, [this]);
    },
    update: function update(t, e, i) {
      var n,
          a,
          o,
          r,
          s,
          l,
          d = this;

      for (d.beforeUpdate(), d.maxWidth = t, d.maxHeight = e, d.margins = ut.extend({
        left: 0,
        right: 0,
        top: 0,
        bottom: 0
      }, i), d._maxLabelLines = 0, d.longestLabelWidth = 0, d.longestTextCache = d.longestTextCache || {}, d.beforeSetDimensions(), d.setDimensions(), d.afterSetDimensions(), d.beforeDataLimits(), d.determineDataLimits(), d.afterDataLimits(), d.beforeBuildTicks(), s = d.buildTicks() || [], s = d.afterBuildTicks(s) || s, d.beforeTickToLabelConversion(), o = d.convertTicksToLabels(s) || d.ticks, d.afterTickToLabelConversion(), d.ticks = o, n = 0, a = o.length; n < a; ++n) {
        r = o[n], (l = s[n]) ? l.label = r : s.push(l = {
          label: r,
          major: !1
        });
      }

      return d._ticks = s, d.beforeCalculateTickRotation(), d.calculateTickRotation(), d.afterCalculateTickRotation(), d.beforeFit(), d.fit(), d.afterFit(), d.afterUpdate(), d.minSize;
    },
    afterUpdate: function afterUpdate() {
      ut.callback(this.options.afterUpdate, [this]);
    },
    beforeSetDimensions: function beforeSetDimensions() {
      ut.callback(this.options.beforeSetDimensions, [this]);
    },
    setDimensions: function setDimensions() {
      var t = this;
      t.isHorizontal() ? (t.width = t.maxWidth, t.left = 0, t.right = t.width) : (t.height = t.maxHeight, t.top = 0, t.bottom = t.height), t.paddingLeft = 0, t.paddingTop = 0, t.paddingRight = 0, t.paddingBottom = 0;
    },
    afterSetDimensions: function afterSetDimensions() {
      ut.callback(this.options.afterSetDimensions, [this]);
    },
    beforeDataLimits: function beforeDataLimits() {
      ut.callback(this.options.beforeDataLimits, [this]);
    },
    determineDataLimits: ut.noop,
    afterDataLimits: function afterDataLimits() {
      ut.callback(this.options.afterDataLimits, [this]);
    },
    beforeBuildTicks: function beforeBuildTicks() {
      ut.callback(this.options.beforeBuildTicks, [this]);
    },
    buildTicks: ut.noop,
    afterBuildTicks: function afterBuildTicks(t) {
      var e = this;
      return ut.isArray(t) && t.length ? ut.callback(e.options.afterBuildTicks, [e, t]) : (e.ticks = ut.callback(e.options.afterBuildTicks, [e, e.ticks]) || e.ticks, t);
    },
    beforeTickToLabelConversion: function beforeTickToLabelConversion() {
      ut.callback(this.options.beforeTickToLabelConversion, [this]);
    },
    convertTicksToLabels: function convertTicksToLabels() {
      var t = this.options.ticks;
      this.ticks = this.ticks.map(t.userCallback || t.callback, this);
    },
    afterTickToLabelConversion: function afterTickToLabelConversion() {
      ut.callback(this.options.afterTickToLabelConversion, [this]);
    },
    beforeCalculateTickRotation: function beforeCalculateTickRotation() {
      ut.callback(this.options.beforeCalculateTickRotation, [this]);
    },
    calculateTickRotation: function calculateTickRotation() {
      var t = this,
          e = t.ctx,
          i = t.options.ticks,
          n = hi(t._ticks),
          a = ut.options._parseFont(i);

      e.font = a.string;
      var o = i.minRotation || 0;
      if (n.length && t.options.display && t.isHorizontal()) for (var r, s = ut.longestText(e, a.string, n, t.longestTextCache), l = s, d = t.getPixelForTick(1) - t.getPixelForTick(0) - 6; l > d && o < i.maxRotation;) {
        var u = ut.toRadians(o);

        if (r = Math.cos(u), Math.sin(u) * s > t.maxHeight) {
          o--;
          break;
        }

        o++, l = r * s;
      }
      t.labelRotation = o;
    },
    afterCalculateTickRotation: function afterCalculateTickRotation() {
      ut.callback(this.options.afterCalculateTickRotation, [this]);
    },
    beforeFit: function beforeFit() {
      ut.callback(this.options.beforeFit, [this]);
    },
    fit: function fit() {
      var t = this,
          e = t.minSize = {
        width: 0,
        height: 0
      },
          i = hi(t._ticks),
          n = t.options,
          a = n.ticks,
          o = n.scaleLabel,
          r = n.gridLines,
          s = t._isVisible(),
          l = n.position,
          d = t.isHorizontal(),
          u = ut.options._parseFont,
          h = u(a),
          c = n.gridLines.tickMarkLength;

      if (e.width = d ? t.isFullWidth() ? t.maxWidth - t.margins.left - t.margins.right : t.maxWidth : s && r.drawTicks ? c : 0, e.height = d ? s && r.drawTicks ? c : 0 : t.maxHeight, o.display && s) {
        var f = u(o),
            g = ut.options.toPadding(o.padding),
            p = f.lineHeight + g.height;
        d ? e.height += p : e.width += p;
      }

      if (a.display && s) {
        var m = ut.longestText(t.ctx, h.string, i, t.longestTextCache),
            v = ut.numberOfLabelLines(i),
            b = .5 * h.size,
            x = t.options.ticks.padding;

        if (t._maxLabelLines = v, t.longestLabelWidth = m, d) {
          var y = ut.toRadians(t.labelRotation),
              k = Math.cos(y),
              w = Math.sin(y) * m + h.lineHeight * v + b;
          e.height = Math.min(t.maxHeight, e.height + w + x), t.ctx.font = h.string;

          var M,
              _,
              C = ci(t.ctx, i[0], h.string),
              S = ci(t.ctx, i[i.length - 1], h.string),
              P = t.getPixelForTick(0) - t.left,
              I = t.right - t.getPixelForTick(i.length - 1);

          0 !== t.labelRotation ? (M = "bottom" === l ? k * C : k * b, _ = "bottom" === l ? k * b : k * S) : (M = C / 2, _ = S / 2), t.paddingLeft = Math.max(M - P, 0) + 3, t.paddingRight = Math.max(_ - I, 0) + 3;
        } else a.mirror ? m = 0 : m += x + b, e.width = Math.min(t.maxWidth, e.width + m), t.paddingTop = h.size / 2, t.paddingBottom = h.size / 2;
      }

      t.handleMargins(), t.width = e.width, t.height = e.height;
    },
    handleMargins: function handleMargins() {
      var t = this;
      t.margins && (t.paddingLeft = Math.max(t.paddingLeft - t.margins.left, 0), t.paddingTop = Math.max(t.paddingTop - t.margins.top, 0), t.paddingRight = Math.max(t.paddingRight - t.margins.right, 0), t.paddingBottom = Math.max(t.paddingBottom - t.margins.bottom, 0));
    },
    afterFit: function afterFit() {
      ut.callback(this.options.afterFit, [this]);
    },
    isHorizontal: function isHorizontal() {
      return "top" === this.options.position || "bottom" === this.options.position;
    },
    isFullWidth: function isFullWidth() {
      return this.options.fullWidth;
    },
    getRightValue: function getRightValue(t) {
      if (ut.isNullOrUndef(t)) return NaN;
      if (("number" == typeof t || t instanceof Number) && !isFinite(t)) return NaN;
      if (t) if (this.isHorizontal()) {
        if (void 0 !== t.x) return this.getRightValue(t.x);
      } else if (void 0 !== t.y) return this.getRightValue(t.y);
      return t;
    },
    getLabelForIndex: ut.noop,
    getPixelForValue: ut.noop,
    getValueForPixel: ut.noop,
    getPixelForTick: function getPixelForTick(t) {
      var e = this,
          i = e.options.offset;

      if (e.isHorizontal()) {
        var n = (e.width - (e.paddingLeft + e.paddingRight)) / Math.max(e._ticks.length - (i ? 0 : 1), 1),
            a = n * t + e.paddingLeft;
        i && (a += n / 2);
        var o = e.left + a;
        return o += e.isFullWidth() ? e.margins.left : 0;
      }

      var r = e.height - (e.paddingTop + e.paddingBottom);
      return e.top + t * (r / (e._ticks.length - 1));
    },
    getPixelForDecimal: function getPixelForDecimal(t) {
      var e = this;

      if (e.isHorizontal()) {
        var i = (e.width - (e.paddingLeft + e.paddingRight)) * t + e.paddingLeft,
            n = e.left + i;
        return n += e.isFullWidth() ? e.margins.left : 0;
      }

      return e.top + t * e.height;
    },
    getBasePixel: function getBasePixel() {
      return this.getPixelForValue(this.getBaseValue());
    },
    getBaseValue: function getBaseValue() {
      var t = this.min,
          e = this.max;
      return this.beginAtZero ? 0 : t < 0 && e < 0 ? e : t > 0 && e > 0 ? t : 0;
    },
    _autoSkip: function _autoSkip(t) {
      var e,
          i,
          n = this,
          a = n.isHorizontal(),
          o = n.options.ticks.minor,
          r = t.length,
          s = !1,
          l = o.maxTicksLimit,
          d = n._tickSize() * (r - 1),
          u = a ? n.width - (n.paddingLeft + n.paddingRight) : n.height - (n.paddingTop + n.PaddingBottom),
          h = [];

      for (d > u && (s = 1 + Math.floor(d / u)), r > l && (s = Math.max(s, 1 + Math.floor(r / l))), e = 0; e < r; e++) {
        i = t[e], s > 1 && e % s > 0 && delete i.label, h.push(i);
      }

      return h;
    },
    _tickSize: function _tickSize() {
      var t = this,
          e = t.isHorizontal(),
          i = t.options.ticks.minor,
          n = ut.toRadians(t.labelRotation),
          a = Math.abs(Math.cos(n)),
          o = Math.abs(Math.sin(n)),
          r = i.autoSkipPadding || 0,
          s = t.longestLabelWidth + r || 0,
          l = ut.options._parseFont(i),
          d = t._maxLabelLines * l.lineHeight + r || 0;

      return e ? d * a > s * o ? s / a : d / o : d * o < s * a ? d / a : s / o;
    },
    _isVisible: function _isVisible() {
      var t,
          e,
          i,
          n = this.chart,
          a = this.options.display;
      if ("auto" !== a) return !!a;

      for (t = 0, e = n.data.datasets.length; t < e; ++t) {
        if (n.isDatasetVisible(t) && ((i = n.getDatasetMeta(t)).xAxisID === this.id || i.yAxisID === this.id)) return !0;
      }

      return !1;
    },
    draw: function draw(t) {
      var e = this,
          i = e.options;

      if (e._isVisible()) {
        var n,
            a,
            o,
            r = e.chart,
            s = e.ctx,
            l = st.global.defaultFontColor,
            d = i.ticks.minor,
            u = i.ticks.major || d,
            h = i.gridLines,
            c = i.scaleLabel,
            f = i.position,
            g = 0 !== e.labelRotation,
            p = d.mirror,
            m = e.isHorizontal(),
            v = ut.options._parseFont,
            b = d.display && d.autoSkip ? e._autoSkip(e.getTicks()) : e.getTicks(),
            x = di(d.fontColor, l),
            y = v(d),
            k = y.lineHeight,
            w = di(u.fontColor, l),
            M = v(u),
            _ = d.padding,
            C = d.labelOffset,
            S = h.drawTicks ? h.tickMarkLength : 0,
            P = di(c.fontColor, l),
            I = v(c),
            A = ut.options.toPadding(c.padding),
            D = ut.toRadians(e.labelRotation),
            T = [],
            F = h.drawBorder ? ui(h.lineWidth, 0, 0) : 0,
            L = ut._alignPixel;
        "top" === f ? (n = L(r, e.bottom, F), a = e.bottom - S, o = n - F / 2) : "bottom" === f ? (n = L(r, e.top, F), a = n + F / 2, o = e.top + S) : "left" === f ? (n = L(r, e.right, F), a = e.right - S, o = n - F / 2) : (n = L(r, e.left, F), a = n + F / 2, o = e.left + S);

        if (ut.each(b, function (n, s) {
          if (!ut.isNullOrUndef(n.label)) {
            var l,
                d,
                u,
                c,
                v,
                b,
                x,
                y,
                w,
                M,
                P,
                I,
                A,
                R,
                O,
                z,
                B = n.label;
            s === e.zeroLineIndex && i.offset === h.offsetGridLines ? (l = h.zeroLineWidth, d = h.zeroLineColor, u = h.zeroLineBorderDash || [], c = h.zeroLineBorderDashOffset || 0) : (l = ui(h.lineWidth, s), d = ui(h.color, s), u = h.borderDash || [], c = h.borderDashOffset || 0);

            var N = ut.isArray(B) ? B.length : 1,
                W = function (t, e, i) {
              var n = t.getPixelForTick(e);
              return i && (1 === t.getTicks().length ? n -= t.isHorizontal() ? Math.max(n - t.left, t.right - n) : Math.max(n - t.top, t.bottom - n) : n -= 0 === e ? (t.getPixelForTick(1) - n) / 2 : (n - t.getPixelForTick(e - 1)) / 2), n;
            }(e, s, h.offsetGridLines);

            if (m) {
              var V = S + _;
              W < e.left - 1e-7 && (d = "rgba(0,0,0,0)"), v = x = w = P = L(r, W, l), b = a, y = o, A = e.getPixelForTick(s) + C, "top" === f ? (M = L(r, t.top, F) + F / 2, I = t.bottom, O = ((g ? 1 : .5) - N) * k, z = g ? "left" : "center", R = e.bottom - V) : (M = t.top, I = L(r, t.bottom, F) - F / 2, O = (g ? 0 : .5) * k, z = g ? "right" : "center", R = e.top + V);
            } else {
              var E = (p ? 0 : S) + _;
              W < e.top - 1e-7 && (d = "rgba(0,0,0,0)"), v = a, x = o, b = y = M = I = L(r, W, l), R = e.getPixelForTick(s) + C, O = (1 - N) * k / 2, "left" === f ? (w = L(r, t.left, F) + F / 2, P = t.right, z = p ? "left" : "right", A = e.right - E) : (w = t.left, P = L(r, t.right, F) - F / 2, z = p ? "right" : "left", A = e.left + E);
            }

            T.push({
              tx1: v,
              ty1: b,
              tx2: x,
              ty2: y,
              x1: w,
              y1: M,
              x2: P,
              y2: I,
              labelX: A,
              labelY: R,
              glWidth: l,
              glColor: d,
              glBorderDash: u,
              glBorderDashOffset: c,
              rotation: -1 * D,
              label: B,
              major: n.major,
              textOffset: O,
              textAlign: z
            });
          }
        }), ut.each(T, function (t) {
          var e = t.glWidth,
              i = t.glColor;

          if (h.display && e && i && (s.save(), s.lineWidth = e, s.strokeStyle = i, s.setLineDash && (s.setLineDash(t.glBorderDash), s.lineDashOffset = t.glBorderDashOffset), s.beginPath(), h.drawTicks && (s.moveTo(t.tx1, t.ty1), s.lineTo(t.tx2, t.ty2)), h.drawOnChartArea && (s.moveTo(t.x1, t.y1), s.lineTo(t.x2, t.y2)), s.stroke(), s.restore()), d.display) {
            s.save(), s.translate(t.labelX, t.labelY), s.rotate(t.rotation), s.font = t.major ? M.string : y.string, s.fillStyle = t.major ? w : x, s.textBaseline = "middle", s.textAlign = t.textAlign;
            var n = t.label,
                a = t.textOffset;
            if (ut.isArray(n)) for (var o = 0; o < n.length; ++o) {
              s.fillText("" + n[o], 0, a), a += k;
            } else s.fillText(n, 0, a);
            s.restore();
          }
        }), c.display) {
          var R,
              O,
              z = 0,
              B = I.lineHeight / 2;
          if (m) R = e.left + (e.right - e.left) / 2, O = "bottom" === f ? e.bottom - B - A.bottom : e.top + B + A.top;else {
            var N = "left" === f;
            R = N ? e.left + B + A.top : e.right - B - A.top, O = e.top + (e.bottom - e.top) / 2, z = N ? -.5 * Math.PI : .5 * Math.PI;
          }
          s.save(), s.translate(R, O), s.rotate(z), s.textAlign = "center", s.textBaseline = "middle", s.fillStyle = P, s.font = I.string, s.fillText(c.labelString, 0, 0), s.restore();
        }

        if (F) {
          var W,
              V,
              E,
              H,
              j = F,
              q = ui(h.lineWidth, b.length - 1, 0);
          m ? (W = L(r, e.left, j) - j / 2, V = L(r, e.right, q) + q / 2, E = H = n) : (E = L(r, e.top, j) - j / 2, H = L(r, e.bottom, q) + q / 2, W = V = n), s.lineWidth = F, s.strokeStyle = ui(h.color, 0), s.beginPath(), s.moveTo(W, E), s.lineTo(V, H), s.stroke();
        }
      }
    }
  }),
      gi = fi.extend({
    getLabels: function getLabels() {
      var t = this.chart.data;
      return this.options.labels || (this.isHorizontal() ? t.xLabels : t.yLabels) || t.labels;
    },
    determineDataLimits: function determineDataLimits() {
      var t,
          e = this,
          i = e.getLabels();
      e.minIndex = 0, e.maxIndex = i.length - 1, void 0 !== e.options.ticks.min && (t = i.indexOf(e.options.ticks.min), e.minIndex = -1 !== t ? t : e.minIndex), void 0 !== e.options.ticks.max && (t = i.indexOf(e.options.ticks.max), e.maxIndex = -1 !== t ? t : e.maxIndex), e.min = i[e.minIndex], e.max = i[e.maxIndex];
    },
    buildTicks: function buildTicks() {
      var t = this,
          e = t.getLabels();
      t.ticks = 0 === t.minIndex && t.maxIndex === e.length - 1 ? e : e.slice(t.minIndex, t.maxIndex + 1);
    },
    getLabelForIndex: function getLabelForIndex(t, e) {
      var i = this,
          n = i.chart;
      return n.getDatasetMeta(e).controller._getValueScaleId() === i.id ? i.getRightValue(n.data.datasets[e].data[t]) : i.ticks[t - i.minIndex];
    },
    getPixelForValue: function getPixelForValue(t, e) {
      var i,
          n = this,
          a = n.options.offset,
          o = Math.max(n.maxIndex + 1 - n.minIndex - (a ? 0 : 1), 1);

      if (null != t && (i = n.isHorizontal() ? t.x : t.y), void 0 !== i || void 0 !== t && isNaN(e)) {
        t = i || t;
        var r = n.getLabels().indexOf(t);
        e = -1 !== r ? r : e;
      }

      if (n.isHorizontal()) {
        var s = n.width / o,
            l = s * (e - n.minIndex);
        return a && (l += s / 2), n.left + l;
      }

      var d = n.height / o,
          u = d * (e - n.minIndex);
      return a && (u += d / 2), n.top + u;
    },
    getPixelForTick: function getPixelForTick(t) {
      return this.getPixelForValue(this.ticks[t], t + this.minIndex, null);
    },
    getValueForPixel: function getValueForPixel(t) {
      var e = this,
          i = e.options.offset,
          n = Math.max(e._ticks.length - (i ? 0 : 1), 1),
          a = e.isHorizontal(),
          o = (a ? e.width : e.height) / n;
      return t -= a ? e.left : e.top, i && (t -= o / 2), (t <= 0 ? 0 : Math.round(t / o)) + e.minIndex;
    },
    getBasePixel: function getBasePixel() {
      return this.bottom;
    }
  }),
      pi = {
    position: "bottom"
  };
  gi._defaults = pi;
  var mi = ut.noop,
      vi = ut.isNullOrUndef;
  var bi = fi.extend({
    getRightValue: function getRightValue(t) {
      return "string" == typeof t ? +t : fi.prototype.getRightValue.call(this, t);
    },
    handleTickRangeOptions: function handleTickRangeOptions() {
      var t = this,
          e = t.options.ticks;

      if (e.beginAtZero) {
        var i = ut.sign(t.min),
            n = ut.sign(t.max);
        i < 0 && n < 0 ? t.max = 0 : i > 0 && n > 0 && (t.min = 0);
      }

      var a = void 0 !== e.min || void 0 !== e.suggestedMin,
          o = void 0 !== e.max || void 0 !== e.suggestedMax;
      void 0 !== e.min ? t.min = e.min : void 0 !== e.suggestedMin && (null === t.min ? t.min = e.suggestedMin : t.min = Math.min(t.min, e.suggestedMin)), void 0 !== e.max ? t.max = e.max : void 0 !== e.suggestedMax && (null === t.max ? t.max = e.suggestedMax : t.max = Math.max(t.max, e.suggestedMax)), a !== o && t.min >= t.max && (a ? t.max = t.min + 1 : t.min = t.max - 1), t.min === t.max && (t.max++, e.beginAtZero || t.min--);
    },
    getTickLimit: function getTickLimit() {
      var t,
          e = this.options.ticks,
          i = e.stepSize,
          n = e.maxTicksLimit;
      return i ? t = Math.ceil(this.max / i) - Math.floor(this.min / i) + 1 : (t = this._computeTickLimit(), n = n || 11), n && (t = Math.min(n, t)), t;
    },
    _computeTickLimit: function _computeTickLimit() {
      return Number.POSITIVE_INFINITY;
    },
    handleDirectionalChanges: mi,
    buildTicks: function buildTicks() {
      var t = this,
          e = t.options.ticks,
          i = t.getTickLimit(),
          n = {
        maxTicks: i = Math.max(2, i),
        min: e.min,
        max: e.max,
        precision: e.precision,
        stepSize: ut.valueOrDefault(e.fixedStepSize, e.stepSize)
      },
          a = t.ticks = function (t, e) {
        var i,
            n,
            a,
            o,
            r = [],
            s = t.stepSize,
            l = s || 1,
            d = t.maxTicks - 1,
            u = t.min,
            h = t.max,
            c = t.precision,
            f = e.min,
            g = e.max,
            p = ut.niceNum((g - f) / d / l) * l;
        if (p < 1e-14 && vi(u) && vi(h)) return [f, g];
        (o = Math.ceil(g / p) - Math.floor(f / p)) > d && (p = ut.niceNum(o * p / d / l) * l), s || vi(c) ? i = Math.pow(10, ut._decimalPlaces(p)) : (i = Math.pow(10, c), p = Math.ceil(p * i) / i), n = Math.floor(f / p) * p, a = Math.ceil(g / p) * p, s && (!vi(u) && ut.almostWhole(u / p, p / 1e3) && (n = u), !vi(h) && ut.almostWhole(h / p, p / 1e3) && (a = h)), o = (a - n) / p, o = ut.almostEquals(o, Math.round(o), p / 1e3) ? Math.round(o) : Math.ceil(o), n = Math.round(n * i) / i, a = Math.round(a * i) / i, r.push(vi(u) ? n : u);

        for (var m = 1; m < o; ++m) {
          r.push(Math.round((n + m * p) * i) / i);
        }

        return r.push(vi(h) ? a : h), r;
      }(n, t);

      t.handleDirectionalChanges(), t.max = ut.max(a), t.min = ut.min(a), e.reverse ? (a.reverse(), t.start = t.max, t.end = t.min) : (t.start = t.min, t.end = t.max);
    },
    convertTicksToLabels: function convertTicksToLabels() {
      var t = this;
      t.ticksAsNumbers = t.ticks.slice(), t.zeroLineIndex = t.ticks.indexOf(0), fi.prototype.convertTicksToLabels.call(t);
    }
  }),
      xi = {
    position: "left",
    ticks: {
      callback: li.formatters.linear
    }
  },
      yi = bi.extend({
    determineDataLimits: function determineDataLimits() {
      var t = this,
          e = t.options,
          i = t.chart,
          n = i.data.datasets,
          a = t.isHorizontal();

      function o(e) {
        return a ? e.xAxisID === t.id : e.yAxisID === t.id;
      }

      t.min = null, t.max = null;
      var r = e.stacked;

      if (void 0 === r && ut.each(n, function (t, e) {
        if (!r) {
          var n = i.getDatasetMeta(e);
          i.isDatasetVisible(e) && o(n) && void 0 !== n.stack && (r = !0);
        }
      }), e.stacked || r) {
        var s = {};
        ut.each(n, function (n, a) {
          var r = i.getDatasetMeta(a),
              l = [r.type, void 0 === e.stacked && void 0 === r.stack ? a : "", r.stack].join(".");
          void 0 === s[l] && (s[l] = {
            positiveValues: [],
            negativeValues: []
          });
          var d = s[l].positiveValues,
              u = s[l].negativeValues;
          i.isDatasetVisible(a) && o(r) && ut.each(n.data, function (i, n) {
            var a = +t.getRightValue(i);
            isNaN(a) || r.data[n].hidden || (d[n] = d[n] || 0, u[n] = u[n] || 0, e.relativePoints ? d[n] = 100 : a < 0 ? u[n] += a : d[n] += a);
          });
        }), ut.each(s, function (e) {
          var i = e.positiveValues.concat(e.negativeValues),
              n = ut.min(i),
              a = ut.max(i);
          t.min = null === t.min ? n : Math.min(t.min, n), t.max = null === t.max ? a : Math.max(t.max, a);
        });
      } else ut.each(n, function (e, n) {
        var a = i.getDatasetMeta(n);
        i.isDatasetVisible(n) && o(a) && ut.each(e.data, function (e, i) {
          var n = +t.getRightValue(e);
          isNaN(n) || a.data[i].hidden || (null === t.min ? t.min = n : n < t.min && (t.min = n), null === t.max ? t.max = n : n > t.max && (t.max = n));
        });
      });

      t.min = isFinite(t.min) && !isNaN(t.min) ? t.min : 0, t.max = isFinite(t.max) && !isNaN(t.max) ? t.max : 1, this.handleTickRangeOptions();
    },
    _computeTickLimit: function _computeTickLimit() {
      var t;
      return this.isHorizontal() ? Math.ceil(this.width / 40) : (t = ut.options._parseFont(this.options.ticks), Math.ceil(this.height / t.lineHeight));
    },
    handleDirectionalChanges: function handleDirectionalChanges() {
      this.isHorizontal() || this.ticks.reverse();
    },
    getLabelForIndex: function getLabelForIndex(t, e) {
      return +this.getRightValue(this.chart.data.datasets[e].data[t]);
    },
    getPixelForValue: function getPixelForValue(t) {
      var e = this,
          i = e.start,
          n = +e.getRightValue(t),
          a = e.end - i;
      return e.isHorizontal() ? e.left + e.width / a * (n - i) : e.bottom - e.height / a * (n - i);
    },
    getValueForPixel: function getValueForPixel(t) {
      var e = this,
          i = e.isHorizontal(),
          n = i ? e.width : e.height,
          a = (i ? t - e.left : e.bottom - t) / n;
      return e.start + (e.end - e.start) * a;
    },
    getPixelForTick: function getPixelForTick(t) {
      return this.getPixelForValue(this.ticksAsNumbers[t]);
    }
  }),
      ki = xi;
  yi._defaults = ki;
  var wi = ut.valueOrDefault;
  var Mi = {
    position: "left",
    ticks: {
      callback: li.formatters.logarithmic
    }
  };

  function _i(t, e) {
    return ut.isFinite(t) && t >= 0 ? t : e;
  }

  var Ci = fi.extend({
    determineDataLimits: function determineDataLimits() {
      var t = this,
          e = t.options,
          i = t.chart,
          n = i.data.datasets,
          a = t.isHorizontal();

      function o(e) {
        return a ? e.xAxisID === t.id : e.yAxisID === t.id;
      }

      t.min = null, t.max = null, t.minNotZero = null;
      var r = e.stacked;

      if (void 0 === r && ut.each(n, function (t, e) {
        if (!r) {
          var n = i.getDatasetMeta(e);
          i.isDatasetVisible(e) && o(n) && void 0 !== n.stack && (r = !0);
        }
      }), e.stacked || r) {
        var s = {};
        ut.each(n, function (n, a) {
          var r = i.getDatasetMeta(a),
              l = [r.type, void 0 === e.stacked && void 0 === r.stack ? a : "", r.stack].join(".");
          i.isDatasetVisible(a) && o(r) && (void 0 === s[l] && (s[l] = []), ut.each(n.data, function (e, i) {
            var n = s[l],
                a = +t.getRightValue(e);
            isNaN(a) || r.data[i].hidden || a < 0 || (n[i] = n[i] || 0, n[i] += a);
          }));
        }), ut.each(s, function (e) {
          if (e.length > 0) {
            var i = ut.min(e),
                n = ut.max(e);
            t.min = null === t.min ? i : Math.min(t.min, i), t.max = null === t.max ? n : Math.max(t.max, n);
          }
        });
      } else ut.each(n, function (e, n) {
        var a = i.getDatasetMeta(n);
        i.isDatasetVisible(n) && o(a) && ut.each(e.data, function (e, i) {
          var n = +t.getRightValue(e);
          isNaN(n) || a.data[i].hidden || n < 0 || (null === t.min ? t.min = n : n < t.min && (t.min = n), null === t.max ? t.max = n : n > t.max && (t.max = n), 0 !== n && (null === t.minNotZero || n < t.minNotZero) && (t.minNotZero = n));
        });
      });

      this.handleTickRangeOptions();
    },
    handleTickRangeOptions: function handleTickRangeOptions() {
      var t = this,
          e = t.options.ticks;
      t.min = _i(e.min, t.min), t.max = _i(e.max, t.max), t.min === t.max && (0 !== t.min && null !== t.min ? (t.min = Math.pow(10, Math.floor(ut.log10(t.min)) - 1), t.max = Math.pow(10, Math.floor(ut.log10(t.max)) + 1)) : (t.min = 1, t.max = 10)), null === t.min && (t.min = Math.pow(10, Math.floor(ut.log10(t.max)) - 1)), null === t.max && (t.max = 0 !== t.min ? Math.pow(10, Math.floor(ut.log10(t.min)) + 1) : 10), null === t.minNotZero && (t.min > 0 ? t.minNotZero = t.min : t.max < 1 ? t.minNotZero = Math.pow(10, Math.floor(ut.log10(t.max))) : t.minNotZero = 1);
    },
    buildTicks: function buildTicks() {
      var t = this,
          e = t.options.ticks,
          i = !t.isHorizontal(),
          n = {
        min: _i(e.min),
        max: _i(e.max)
      },
          a = t.ticks = function (t, e) {
        var i,
            n,
            a = [],
            o = wi(t.min, Math.pow(10, Math.floor(ut.log10(e.min)))),
            r = Math.floor(ut.log10(e.max)),
            s = Math.ceil(e.max / Math.pow(10, r));
        0 === o ? (i = Math.floor(ut.log10(e.minNotZero)), n = Math.floor(e.minNotZero / Math.pow(10, i)), a.push(o), o = n * Math.pow(10, i)) : (i = Math.floor(ut.log10(o)), n = Math.floor(o / Math.pow(10, i)));
        var l = i < 0 ? Math.pow(10, Math.abs(i)) : 1;

        do {
          a.push(o), 10 == ++n && (n = 1, l = ++i >= 0 ? 1 : l), o = Math.round(n * Math.pow(10, i) * l) / l;
        } while (i < r || i === r && n < s);

        var d = wi(t.max, o);
        return a.push(d), a;
      }(n, t);

      t.max = ut.max(a), t.min = ut.min(a), e.reverse ? (i = !i, t.start = t.max, t.end = t.min) : (t.start = t.min, t.end = t.max), i && a.reverse();
    },
    convertTicksToLabels: function convertTicksToLabels() {
      this.tickValues = this.ticks.slice(), fi.prototype.convertTicksToLabels.call(this);
    },
    getLabelForIndex: function getLabelForIndex(t, e) {
      return +this.getRightValue(this.chart.data.datasets[e].data[t]);
    },
    getPixelForTick: function getPixelForTick(t) {
      return this.getPixelForValue(this.tickValues[t]);
    },
    _getFirstTickValue: function _getFirstTickValue(t) {
      var e = Math.floor(ut.log10(t));
      return Math.floor(t / Math.pow(10, e)) * Math.pow(10, e);
    },
    getPixelForValue: function getPixelForValue(t) {
      var e,
          i,
          n,
          a,
          o,
          r = this,
          s = r.options.ticks,
          l = s.reverse,
          d = ut.log10,
          u = r._getFirstTickValue(r.minNotZero),
          h = 0;

      return t = +r.getRightValue(t), l ? (n = r.end, a = r.start, o = -1) : (n = r.start, a = r.end, o = 1), r.isHorizontal() ? (e = r.width, i = l ? r.right : r.left) : (e = r.height, o *= -1, i = l ? r.top : r.bottom), t !== n && (0 === n && (e -= h = wi(s.fontSize, st.global.defaultFontSize), n = u), 0 !== t && (h += e / (d(a) - d(n)) * (d(t) - d(n))), i += o * h), i;
    },
    getValueForPixel: function getValueForPixel(t) {
      var e,
          i,
          n,
          a,
          o = this,
          r = o.options.ticks,
          s = r.reverse,
          l = ut.log10,
          d = o._getFirstTickValue(o.minNotZero);

      if (s ? (i = o.end, n = o.start) : (i = o.start, n = o.end), o.isHorizontal() ? (e = o.width, a = s ? o.right - t : t - o.left) : (e = o.height, a = s ? t - o.top : o.bottom - t), a !== i) {
        if (0 === i) {
          var u = wi(r.fontSize, st.global.defaultFontSize);
          a -= u, e -= u, i = d;
        }

        a *= l(n) - l(i), a /= e, a = Math.pow(10, l(i) + a);
      }

      return a;
    }
  }),
      Si = Mi;
  Ci._defaults = Si;
  var Pi = ut.valueOrDefault,
      Ii = ut.valueAtIndexOrDefault,
      Ai = ut.options.resolve,
      Di = {
    display: !0,
    animate: !0,
    position: "chartArea",
    angleLines: {
      display: !0,
      color: "rgba(0, 0, 0, 0.1)",
      lineWidth: 1,
      borderDash: [],
      borderDashOffset: 0
    },
    gridLines: {
      circular: !1
    },
    ticks: {
      showLabelBackdrop: !0,
      backdropColor: "rgba(255,255,255,0.75)",
      backdropPaddingY: 2,
      backdropPaddingX: 2,
      callback: li.formatters.linear
    },
    pointLabels: {
      display: !0,
      fontSize: 10,
      callback: function callback(t) {
        return t;
      }
    }
  };

  function Ti(t) {
    var e = t.options;
    return e.angleLines.display || e.pointLabels.display ? t.chart.data.labels.length : 0;
  }

  function Fi(t) {
    var e = t.ticks;
    return e.display && t.display ? Pi(e.fontSize, st.global.defaultFontSize) + 2 * e.backdropPaddingY : 0;
  }

  function Li(t, e, i, n, a) {
    return t === n || t === a ? {
      start: e - i / 2,
      end: e + i / 2
    } : t < n || t > a ? {
      start: e - i,
      end: e
    } : {
      start: e,
      end: e + i
    };
  }

  function Ri(t) {
    return 0 === t || 180 === t ? "center" : t < 180 ? "left" : "right";
  }

  function Oi(t, e, i, n) {
    var a,
        o,
        r = i.y + n / 2;
    if (ut.isArray(e)) for (a = 0, o = e.length; a < o; ++a) {
      t.fillText(e[a], i.x, r), r += n;
    } else t.fillText(e, i.x, r);
  }

  function zi(t, e, i) {
    90 === t || 270 === t ? i.y -= e.h / 2 : (t > 270 || t < 90) && (i.y -= e.h);
  }

  function Bi(t) {
    return ut.isNumber(t) ? t : 0;
  }

  var Ni = bi.extend({
    setDimensions: function setDimensions() {
      var t = this;
      t.width = t.maxWidth, t.height = t.maxHeight, t.paddingTop = Fi(t.options) / 2, t.xCenter = Math.floor(t.width / 2), t.yCenter = Math.floor((t.height - t.paddingTop) / 2), t.drawingArea = Math.min(t.height - t.paddingTop, t.width) / 2;
    },
    determineDataLimits: function determineDataLimits() {
      var t = this,
          e = t.chart,
          i = Number.POSITIVE_INFINITY,
          n = Number.NEGATIVE_INFINITY;
      ut.each(e.data.datasets, function (a, o) {
        if (e.isDatasetVisible(o)) {
          var r = e.getDatasetMeta(o);
          ut.each(a.data, function (e, a) {
            var o = +t.getRightValue(e);
            isNaN(o) || r.data[a].hidden || (i = Math.min(o, i), n = Math.max(o, n));
          });
        }
      }), t.min = i === Number.POSITIVE_INFINITY ? 0 : i, t.max = n === Number.NEGATIVE_INFINITY ? 0 : n, t.handleTickRangeOptions();
    },
    _computeTickLimit: function _computeTickLimit() {
      return Math.ceil(this.drawingArea / Fi(this.options));
    },
    convertTicksToLabels: function convertTicksToLabels() {
      var t = this;
      bi.prototype.convertTicksToLabels.call(t), t.pointLabels = t.chart.data.labels.map(t.options.pointLabels.callback, t);
    },
    getLabelForIndex: function getLabelForIndex(t, e) {
      return +this.getRightValue(this.chart.data.datasets[e].data[t]);
    },
    fit: function fit() {
      var t = this.options;
      t.display && t.pointLabels.display ? function (t) {
        var e,
            i,
            n,
            a = ut.options._parseFont(t.options.pointLabels),
            o = {
          l: 0,
          r: t.width,
          t: 0,
          b: t.height - t.paddingTop
        },
            r = {};

        t.ctx.font = a.string, t._pointLabelSizes = [];
        var s,
            l,
            d,
            u = Ti(t);

        for (e = 0; e < u; e++) {
          n = t.getPointPosition(e, t.drawingArea + 5), s = t.ctx, l = a.lineHeight, d = t.pointLabels[e] || "", i = ut.isArray(d) ? {
            w: ut.longestText(s, s.font, d),
            h: d.length * l
          } : {
            w: s.measureText(d).width,
            h: l
          }, t._pointLabelSizes[e] = i;
          var h = t.getIndexAngle(e),
              c = ut.toDegrees(h) % 360,
              f = Li(c, n.x, i.w, 0, 180),
              g = Li(c, n.y, i.h, 90, 270);
          f.start < o.l && (o.l = f.start, r.l = h), f.end > o.r && (o.r = f.end, r.r = h), g.start < o.t && (o.t = g.start, r.t = h), g.end > o.b && (o.b = g.end, r.b = h);
        }

        t.setReductions(t.drawingArea, o, r);
      }(this) : this.setCenterPoint(0, 0, 0, 0);
    },
    setReductions: function setReductions(t, e, i) {
      var n = this,
          a = e.l / Math.sin(i.l),
          o = Math.max(e.r - n.width, 0) / Math.sin(i.r),
          r = -e.t / Math.cos(i.t),
          s = -Math.max(e.b - (n.height - n.paddingTop), 0) / Math.cos(i.b);
      a = Bi(a), o = Bi(o), r = Bi(r), s = Bi(s), n.drawingArea = Math.min(Math.floor(t - (a + o) / 2), Math.floor(t - (r + s) / 2)), n.setCenterPoint(a, o, r, s);
    },
    setCenterPoint: function setCenterPoint(t, e, i, n) {
      var a = this,
          o = a.width - e - a.drawingArea,
          r = t + a.drawingArea,
          s = i + a.drawingArea,
          l = a.height - a.paddingTop - n - a.drawingArea;
      a.xCenter = Math.floor((r + o) / 2 + a.left), a.yCenter = Math.floor((s + l) / 2 + a.top + a.paddingTop);
    },
    getIndexAngle: function getIndexAngle(t) {
      return t * (2 * Math.PI / Ti(this)) + (this.chart.options && this.chart.options.startAngle ? this.chart.options.startAngle : 0) * Math.PI * 2 / 360;
    },
    getDistanceFromCenterForValue: function getDistanceFromCenterForValue(t) {
      var e = this;
      if (null === t) return 0;
      var i = e.drawingArea / (e.max - e.min);
      return e.options.ticks.reverse ? (e.max - t) * i : (t - e.min) * i;
    },
    getPointPosition: function getPointPosition(t, e) {
      var i = this.getIndexAngle(t) - Math.PI / 2;
      return {
        x: Math.cos(i) * e + this.xCenter,
        y: Math.sin(i) * e + this.yCenter
      };
    },
    getPointPositionForValue: function getPointPositionForValue(t, e) {
      return this.getPointPosition(t, this.getDistanceFromCenterForValue(e));
    },
    getBasePosition: function getBasePosition() {
      var t = this.min,
          e = this.max;
      return this.getPointPositionForValue(0, this.beginAtZero ? 0 : t < 0 && e < 0 ? e : t > 0 && e > 0 ? t : 0);
    },
    draw: function draw() {
      var t = this,
          e = t.options,
          i = e.gridLines,
          n = e.ticks;

      if (e.display) {
        var a = t.ctx,
            o = this.getIndexAngle(0),
            r = ut.options._parseFont(n);

        (e.angleLines.display || e.pointLabels.display) && function (t) {
          var e = t.ctx,
              i = t.options,
              n = i.angleLines,
              a = i.gridLines,
              o = i.pointLabels,
              r = Pi(n.lineWidth, a.lineWidth),
              s = Pi(n.color, a.color),
              l = Fi(i);
          e.save(), e.lineWidth = r, e.strokeStyle = s, e.setLineDash && (e.setLineDash(Ai([n.borderDash, a.borderDash, []])), e.lineDashOffset = Ai([n.borderDashOffset, a.borderDashOffset, 0]));

          var d = t.getDistanceFromCenterForValue(i.ticks.reverse ? t.min : t.max),
              u = ut.options._parseFont(o);

          e.font = u.string, e.textBaseline = "middle";

          for (var h = Ti(t) - 1; h >= 0; h--) {
            if (n.display && r && s) {
              var c = t.getPointPosition(h, d);
              e.beginPath(), e.moveTo(t.xCenter, t.yCenter), e.lineTo(c.x, c.y), e.stroke();
            }

            if (o.display) {
              var f = 0 === h ? l / 2 : 0,
                  g = t.getPointPosition(h, d + f + 5),
                  p = Ii(o.fontColor, h, st.global.defaultFontColor);
              e.fillStyle = p;
              var m = t.getIndexAngle(h),
                  v = ut.toDegrees(m);
              e.textAlign = Ri(v), zi(v, t._pointLabelSizes[h], g), Oi(e, t.pointLabels[h] || "", g, u.lineHeight);
            }
          }

          e.restore();
        }(t), ut.each(t.ticks, function (e, s) {
          if (s > 0 || n.reverse) {
            var l = t.getDistanceFromCenterForValue(t.ticksAsNumbers[s]);

            if (i.display && 0 !== s && function (t, e, i, n) {
              var a,
                  o = t.ctx,
                  r = e.circular,
                  s = Ti(t),
                  l = Ii(e.color, n - 1),
                  d = Ii(e.lineWidth, n - 1);

              if ((r || s) && l && d) {
                if (o.save(), o.strokeStyle = l, o.lineWidth = d, o.setLineDash && (o.setLineDash(e.borderDash || []), o.lineDashOffset = e.borderDashOffset || 0), o.beginPath(), r) o.arc(t.xCenter, t.yCenter, i, 0, 2 * Math.PI);else {
                  a = t.getPointPosition(0, i), o.moveTo(a.x, a.y);

                  for (var u = 1; u < s; u++) {
                    a = t.getPointPosition(u, i), o.lineTo(a.x, a.y);
                  }
                }
                o.closePath(), o.stroke(), o.restore();
              }
            }(t, i, l, s), n.display) {
              var d = Pi(n.fontColor, st.global.defaultFontColor);

              if (a.font = r.string, a.save(), a.translate(t.xCenter, t.yCenter), a.rotate(o), n.showLabelBackdrop) {
                var u = a.measureText(e).width;
                a.fillStyle = n.backdropColor, a.fillRect(-u / 2 - n.backdropPaddingX, -l - r.size / 2 - n.backdropPaddingY, u + 2 * n.backdropPaddingX, r.size + 2 * n.backdropPaddingY);
              }

              a.textAlign = "center", a.textBaseline = "middle", a.fillStyle = d, a.fillText(e, 0, -l), a.restore();
            }
          }
        });
      }
    }
  }),
      Wi = Di;
  Ni._defaults = Wi;
  var Vi = ut.valueOrDefault,
      Ei = Number.MIN_SAFE_INTEGER || -9007199254740991,
      Hi = Number.MAX_SAFE_INTEGER || 9007199254740991,
      ji = {
    millisecond: {
      common: !0,
      size: 1,
      steps: [1, 2, 5, 10, 20, 50, 100, 250, 500]
    },
    second: {
      common: !0,
      size: 1e3,
      steps: [1, 2, 5, 10, 15, 30]
    },
    minute: {
      common: !0,
      size: 6e4,
      steps: [1, 2, 5, 10, 15, 30]
    },
    hour: {
      common: !0,
      size: 36e5,
      steps: [1, 2, 3, 6, 12]
    },
    day: {
      common: !0,
      size: 864e5,
      steps: [1, 2, 5]
    },
    week: {
      common: !1,
      size: 6048e5,
      steps: [1, 2, 3, 4]
    },
    month: {
      common: !0,
      size: 2628e6,
      steps: [1, 2, 3]
    },
    quarter: {
      common: !1,
      size: 7884e6,
      steps: [1, 2, 3, 4]
    },
    year: {
      common: !0,
      size: 3154e7
    }
  },
      qi = Object.keys(ji);

  function Yi(t, e) {
    return t - e;
  }

  function Ui(t) {
    var e,
        i,
        n,
        a = {},
        o = [];

    for (e = 0, i = t.length; e < i; ++e) {
      a[n = t[e]] || (a[n] = !0, o.push(n));
    }

    return o;
  }

  function Xi(t, e, i, n) {
    var a = function (t, e, i) {
      for (var n, a, o, r = 0, s = t.length - 1; r >= 0 && r <= s;) {
        if (a = t[(n = r + s >> 1) - 1] || null, o = t[n], !a) return {
          lo: null,
          hi: o
        };
        if (o[e] < i) r = n + 1;else {
          if (!(a[e] > i)) return {
            lo: a,
            hi: o
          };
          s = n - 1;
        }
      }

      return {
        lo: o,
        hi: null
      };
    }(t, e, i),
        o = a.lo ? a.hi ? a.lo : t[t.length - 2] : t[0],
        r = a.lo ? a.hi ? a.hi : t[t.length - 1] : t[1],
        s = r[e] - o[e],
        l = s ? (i - o[e]) / s : 0,
        d = (r[n] - o[n]) * l;

    return o[n] + d;
  }

  function Ki(t, e) {
    var i = t._adapter,
        n = t.options.time,
        a = n.parser,
        o = a || n.format,
        r = e;
    return "function" == typeof a && (r = a(r)), ut.isFinite(r) || (r = "string" == typeof o ? i.parse(r, o) : i.parse(r)), null !== r ? +r : (a || "function" != typeof o || (r = o(e), ut.isFinite(r) || (r = i.parse(r))), r);
  }

  function Gi(t, e) {
    if (ut.isNullOrUndef(e)) return null;
    var i = t.options.time,
        n = Ki(t, t.getRightValue(e));
    return null === n ? n : (i.round && (n = +t._adapter.startOf(n, i.round)), n);
  }

  function Zi(t) {
    for (var e = qi.indexOf(t) + 1, i = qi.length; e < i; ++e) {
      if (ji[qi[e]].common) return qi[e];
    }
  }

  function $i(t, e, i, n) {
    var a,
        o = t._adapter,
        r = t.options,
        s = r.time,
        l = s.unit || function (t, e, i, n) {
      var a,
          o,
          r,
          s = qi.length;

      for (a = qi.indexOf(t); a < s - 1; ++a) {
        if (r = (o = ji[qi[a]]).steps ? o.steps[o.steps.length - 1] : Hi, o.common && Math.ceil((i - e) / (r * o.size)) <= n) return qi[a];
      }

      return qi[s - 1];
    }(s.minUnit, e, i, n),
        d = Zi(l),
        u = Vi(s.stepSize, s.unitStepSize),
        h = "week" === l && s.isoWeekday,
        c = r.ticks.major.enabled,
        f = ji[l],
        g = e,
        p = i,
        m = [];

    for (u || (u = function (t, e, i, n) {
      var a,
          o,
          r,
          s = e - t,
          l = ji[i],
          d = l.size,
          u = l.steps;
      if (!u) return Math.ceil(s / (n * d));

      for (a = 0, o = u.length; a < o && (r = u[a], !(Math.ceil(s / (d * r)) <= n)); ++a) {
        ;
      }

      return r;
    }(e, i, l, n)), h && (g = +o.startOf(g, "isoWeek", h), p = +o.startOf(p, "isoWeek", h)), g = +o.startOf(g, h ? "day" : l), (p = +o.startOf(p, h ? "day" : l)) < i && (p = +o.add(p, 1, l)), a = g, c && d && !h && !s.round && (a = +o.startOf(a, d), a = +o.add(a, ~~((g - a) / (f.size * u)) * u, l)); a < p; a = +o.add(a, u, l)) {
      m.push(+a);
    }

    return m.push(+a), m;
  }

  var Ji = fi.extend({
    initialize: function initialize() {
      this.mergeTicksOptions(), fi.prototype.initialize.call(this);
    },
    update: function update() {
      var t = this.options,
          e = t.time || (t.time = {}),
          i = this._adapter = new si._date(t.adapters.date);
      return e.format && console.warn("options.time.format is deprecated and replaced by options.time.parser."), ut.mergeIf(e.displayFormats, i.formats()), fi.prototype.update.apply(this, arguments);
    },
    getRightValue: function getRightValue(t) {
      return t && void 0 !== t.t && (t = t.t), fi.prototype.getRightValue.call(this, t);
    },
    determineDataLimits: function determineDataLimits() {
      var t,
          e,
          i,
          n,
          a,
          o,
          r = this,
          s = r.chart,
          l = r._adapter,
          d = r.options.time,
          u = d.unit || "day",
          h = Hi,
          c = Ei,
          f = [],
          g = [],
          p = [],
          m = s.data.labels || [];

      for (t = 0, i = m.length; t < i; ++t) {
        p.push(Gi(r, m[t]));
      }

      for (t = 0, i = (s.data.datasets || []).length; t < i; ++t) {
        if (s.isDatasetVisible(t)) {
          if (a = s.data.datasets[t].data, ut.isObject(a[0])) for (g[t] = [], e = 0, n = a.length; e < n; ++e) {
            o = Gi(r, a[e]), f.push(o), g[t][e] = o;
          } else {
            for (e = 0, n = p.length; e < n; ++e) {
              f.push(p[e]);
            }

            g[t] = p.slice(0);
          }
        } else g[t] = [];
      }

      p.length && (p = Ui(p).sort(Yi), h = Math.min(h, p[0]), c = Math.max(c, p[p.length - 1])), f.length && (f = Ui(f).sort(Yi), h = Math.min(h, f[0]), c = Math.max(c, f[f.length - 1])), h = Gi(r, d.min) || h, c = Gi(r, d.max) || c, h = h === Hi ? +l.startOf(Date.now(), u) : h, c = c === Ei ? +l.endOf(Date.now(), u) + 1 : c, r.min = Math.min(h, c), r.max = Math.max(h + 1, c), r._horizontal = r.isHorizontal(), r._table = [], r._timestamps = {
        data: f,
        datasets: g,
        labels: p
      };
    },
    buildTicks: function buildTicks() {
      var t,
          e,
          i,
          n = this,
          a = n.min,
          o = n.max,
          r = n.options,
          s = r.time,
          l = [],
          d = [];

      switch (r.ticks.source) {
        case "data":
          l = n._timestamps.data;
          break;

        case "labels":
          l = n._timestamps.labels;
          break;

        case "auto":
        default:
          l = $i(n, a, o, n.getLabelCapacity(a));
      }

      for ("ticks" === r.bounds && l.length && (a = l[0], o = l[l.length - 1]), a = Gi(n, s.min) || a, o = Gi(n, s.max) || o, t = 0, e = l.length; t < e; ++t) {
        (i = l[t]) >= a && i <= o && d.push(i);
      }

      return n.min = a, n.max = o, n._unit = s.unit || function (t, e, i, n, a) {
        var o, r;

        for (o = qi.length - 1; o >= qi.indexOf(i); o--) {
          if (r = qi[o], ji[r].common && t._adapter.diff(a, n, r) >= e.length) return r;
        }

        return qi[i ? qi.indexOf(i) : 0];
      }(n, d, s.minUnit, n.min, n.max), n._majorUnit = Zi(n._unit), n._table = function (t, e, i, n) {
        if ("linear" === n || !t.length) return [{
          time: e,
          pos: 0
        }, {
          time: i,
          pos: 1
        }];
        var a,
            o,
            r,
            s,
            l,
            d = [],
            u = [e];

        for (a = 0, o = t.length; a < o; ++a) {
          (s = t[a]) > e && s < i && u.push(s);
        }

        for (u.push(i), a = 0, o = u.length; a < o; ++a) {
          l = u[a + 1], r = u[a - 1], s = u[a], void 0 !== r && void 0 !== l && Math.round((l + r) / 2) === s || d.push({
            time: s,
            pos: a / (o - 1)
          });
        }

        return d;
      }(n._timestamps.data, a, o, r.distribution), n._offsets = function (t, e, i, n, a) {
        var o,
            r,
            s = 0,
            l = 0;
        return a.offset && e.length && (a.time.min || (o = Xi(t, "time", e[0], "pos"), s = 1 === e.length ? 1 - o : (Xi(t, "time", e[1], "pos") - o) / 2), a.time.max || (r = Xi(t, "time", e[e.length - 1], "pos"), l = 1 === e.length ? r : (r - Xi(t, "time", e[e.length - 2], "pos")) / 2)), {
          start: s,
          end: l
        };
      }(n._table, d, 0, 0, r), r.ticks.reverse && d.reverse(), function (t, e, i) {
        var n,
            a,
            o,
            r,
            s = [];

        for (n = 0, a = e.length; n < a; ++n) {
          o = e[n], r = !!i && o === +t._adapter.startOf(o, i), s.push({
            value: o,
            major: r
          });
        }

        return s;
      }(n, d, n._majorUnit);
    },
    getLabelForIndex: function getLabelForIndex(t, e) {
      var i = this,
          n = i._adapter,
          a = i.chart.data,
          o = i.options.time,
          r = a.labels && t < a.labels.length ? a.labels[t] : "",
          s = a.datasets[e].data[t];
      return ut.isObject(s) && (r = i.getRightValue(s)), o.tooltipFormat ? n.format(Ki(i, r), o.tooltipFormat) : "string" == typeof r ? r : n.format(Ki(i, r), o.displayFormats.datetime);
    },
    tickFormatFunction: function tickFormatFunction(t, e, i, n) {
      var a = this._adapter,
          o = this.options,
          r = o.time.displayFormats,
          s = r[this._unit],
          l = this._majorUnit,
          d = r[l],
          u = +a.startOf(t, l),
          h = o.ticks.major,
          c = h.enabled && l && d && t === u,
          f = a.format(t, n || (c ? d : s)),
          g = c ? h : o.ticks.minor,
          p = Vi(g.callback, g.userCallback);
      return p ? p(f, e, i) : f;
    },
    convertTicksToLabels: function convertTicksToLabels(t) {
      var e,
          i,
          n = [];

      for (e = 0, i = t.length; e < i; ++e) {
        n.push(this.tickFormatFunction(t[e].value, e, t));
      }

      return n;
    },
    getPixelForOffset: function getPixelForOffset(t) {
      var e = this,
          i = e.options.ticks.reverse,
          n = e._horizontal ? e.width : e.height,
          a = e._horizontal ? i ? e.right : e.left : i ? e.bottom : e.top,
          o = Xi(e._table, "time", t, "pos"),
          r = n * (e._offsets.start + o) / (e._offsets.start + 1 + e._offsets.end);
      return i ? a - r : a + r;
    },
    getPixelForValue: function getPixelForValue(t, e, i) {
      var n = null;
      if (void 0 !== e && void 0 !== i && (n = this._timestamps.datasets[i][e]), null === n && (n = Gi(this, t)), null !== n) return this.getPixelForOffset(n);
    },
    getPixelForTick: function getPixelForTick(t) {
      var e = this.getTicks();
      return t >= 0 && t < e.length ? this.getPixelForOffset(e[t].value) : null;
    },
    getValueForPixel: function getValueForPixel(t) {
      var e = this,
          i = e._horizontal ? e.width : e.height,
          n = e._horizontal ? e.left : e.top,
          a = (i ? (t - n) / i : 0) * (e._offsets.start + 1 + e._offsets.start) - e._offsets.end,
          o = Xi(e._table, "pos", a, "time");
      return e._adapter._create(o);
    },
    getLabelWidth: function getLabelWidth(t) {
      var e = this.options.ticks,
          i = this.ctx.measureText(t).width,
          n = ut.toRadians(e.maxRotation),
          a = Math.cos(n),
          o = Math.sin(n);
      return i * a + Vi(e.fontSize, st.global.defaultFontSize) * o;
    },
    getLabelCapacity: function getLabelCapacity(t) {
      var e = this,
          i = e.options.time.displayFormats.millisecond,
          n = e.tickFormatFunction(t, 0, [], i),
          a = e.getLabelWidth(n),
          o = e.isHorizontal() ? e.width : e.height,
          r = Math.floor(o / a);
      return r > 0 ? r : 1;
    }
  }),
      Qi = {
    position: "bottom",
    distribution: "linear",
    bounds: "data",
    adapters: {},
    time: {
      parser: !1,
      format: !1,
      unit: !1,
      round: !1,
      displayFormat: !1,
      isoWeekday: !1,
      minUnit: "millisecond",
      displayFormats: {}
    },
    ticks: {
      autoSkip: !1,
      source: "auto",
      major: {
        enabled: !1
      }
    }
  };
  Ji._defaults = Qi;
  var tn = {
    category: gi,
    linear: yi,
    logarithmic: Ci,
    radialLinear: Ni,
    time: Ji
  },
      en = {
    datetime: "MMM D, YYYY, h:mm:ss a",
    millisecond: "h:mm:ss.SSS a",
    second: "h:mm:ss a",
    minute: "h:mm a",
    hour: "hA",
    day: "MMM D",
    week: "ll",
    month: "MMM YYYY",
    quarter: "[Q]Q - YYYY",
    year: "YYYY"
  };
  si._date.override("function" == typeof t ? {
    _id: "moment",
    formats: function formats() {
      return en;
    },
    parse: function parse(e, i) {
      return "string" == typeof e && "string" == typeof i ? e = t(e, i) : e instanceof t || (e = t(e)), e.isValid() ? e.valueOf() : null;
    },
    format: function format(e, i) {
      return t(e).format(i);
    },
    add: function add(e, i, n) {
      return t(e).add(i, n).valueOf();
    },
    diff: function diff(e, i, n) {
      return t.duration(t(e).diff(t(i))).as(n);
    },
    startOf: function startOf(e, i, n) {
      return e = t(e), "isoWeek" === i ? e.isoWeekday(n).valueOf() : e.startOf(i).valueOf();
    },
    endOf: function endOf(e, i) {
      return t(e).endOf(i).valueOf();
    },
    _create: function _create(e) {
      return t(e);
    }
  } : {}), st._set("global", {
    plugins: {
      filler: {
        propagate: !0
      }
    }
  });
  var nn = {
    dataset: function dataset(t) {
      var e = t.fill,
          i = t.chart,
          n = i.getDatasetMeta(e),
          a = n && i.isDatasetVisible(e) && n.dataset._children || [],
          o = a.length || 0;
      return o ? function (t, e) {
        return e < o && a[e]._view || null;
      } : null;
    },
    boundary: function boundary(t) {
      var e = t.boundary,
          i = e ? e.x : null,
          n = e ? e.y : null;
      return function (t) {
        return {
          x: null === i ? t.x : i,
          y: null === n ? t.y : n
        };
      };
    }
  };

  function an(t, e, i) {
    var n,
        a = t._model || {},
        o = a.fill;
    if (void 0 === o && (o = !!a.backgroundColor), !1 === o || null === o) return !1;
    if (!0 === o) return "origin";
    if (n = parseFloat(o, 10), isFinite(n) && Math.floor(n) === n) return "-" !== o[0] && "+" !== o[0] || (n = e + n), !(n === e || n < 0 || n >= i) && n;

    switch (o) {
      case "bottom":
        return "start";

      case "top":
        return "end";

      case "zero":
        return "origin";

      case "origin":
      case "start":
      case "end":
        return o;

      default:
        return !1;
    }
  }

  function on(t) {
    var e,
        i = t.el._model || {},
        n = t.el._scale || {},
        a = t.fill,
        o = null;
    if (isFinite(a)) return null;

    if ("start" === a ? o = void 0 === i.scaleBottom ? n.bottom : i.scaleBottom : "end" === a ? o = void 0 === i.scaleTop ? n.top : i.scaleTop : void 0 !== i.scaleZero ? o = i.scaleZero : n.getBasePosition ? o = n.getBasePosition() : n.getBasePixel && (o = n.getBasePixel()), null != o) {
      if (void 0 !== o.x && void 0 !== o.y) return o;
      if (ut.isFinite(o)) return {
        x: (e = n.isHorizontal()) ? o : null,
        y: e ? null : o
      };
    }

    return null;
  }

  function rn(t, e, i) {
    var n,
        a = t[e].fill,
        o = [e];
    if (!i) return a;

    for (; !1 !== a && -1 === o.indexOf(a);) {
      if (!isFinite(a)) return a;
      if (!(n = t[a])) return !1;
      if (n.visible) return a;
      o.push(a), a = n.fill;
    }

    return !1;
  }

  function sn(t) {
    var e = t.fill,
        i = "dataset";
    return !1 === e ? null : (isFinite(e) || (i = "boundary"), nn[i](t));
  }

  function ln(t) {
    return t && !t.skip;
  }

  function dn(t, e, i, n, a) {
    var o;

    if (n && a) {
      for (t.moveTo(e[0].x, e[0].y), o = 1; o < n; ++o) {
        ut.canvas.lineTo(t, e[o - 1], e[o]);
      }

      for (t.lineTo(i[a - 1].x, i[a - 1].y), o = a - 1; o > 0; --o) {
        ut.canvas.lineTo(t, i[o], i[o - 1], !0);
      }
    }
  }

  var un = {
    id: "filler",
    afterDatasetsUpdate: function afterDatasetsUpdate(t, e) {
      var i,
          n,
          a,
          o,
          r = (t.data.datasets || []).length,
          s = e.propagate,
          l = [];

      for (n = 0; n < r; ++n) {
        o = null, (a = (i = t.getDatasetMeta(n)).dataset) && a._model && a instanceof Wt.Line && (o = {
          visible: t.isDatasetVisible(n),
          fill: an(a, n, r),
          chart: t,
          el: a
        }), i.$filler = o, l.push(o);
      }

      for (n = 0; n < r; ++n) {
        (o = l[n]) && (o.fill = rn(l, n, s), o.boundary = on(o), o.mapper = sn(o));
      }
    },
    beforeDatasetDraw: function beforeDatasetDraw(t, e) {
      var i = e.meta.$filler;

      if (i) {
        var n = t.ctx,
            a = i.el,
            o = a._view,
            r = a._children || [],
            s = i.mapper,
            l = o.backgroundColor || st.global.defaultColor;
        s && l && r.length && (ut.canvas.clipArea(n, t.chartArea), function (t, e, i, n, a, o) {
          var r,
              s,
              l,
              d,
              u,
              h,
              c,
              f = e.length,
              g = n.spanGaps,
              p = [],
              m = [],
              v = 0,
              b = 0;

          for (t.beginPath(), r = 0, s = f + !!o; r < s; ++r) {
            u = i(d = e[l = r % f]._view, l, n), h = ln(d), c = ln(u), h && c ? (v = p.push(d), b = m.push(u)) : v && b && (g ? (h && p.push(d), c && m.push(u)) : (dn(t, p, m, v, b), v = b = 0, p = [], m = []));
          }

          dn(t, p, m, v, b), t.closePath(), t.fillStyle = a, t.fill();
        }(n, r, s, o, l, a._loop), ut.canvas.unclipArea(n));
      }
    }
  },
      hn = ut.noop,
      cn = ut.valueOrDefault;

  function fn(t, e) {
    return t.usePointStyle && t.boxWidth > e ? e : t.boxWidth;
  }

  st._set("global", {
    legend: {
      display: !0,
      position: "top",
      fullWidth: !0,
      reverse: !1,
      weight: 1e3,
      onClick: function onClick(t, e) {
        var i = e.datasetIndex,
            n = this.chart,
            a = n.getDatasetMeta(i);
        a.hidden = null === a.hidden ? !n.data.datasets[i].hidden : null, n.update();
      },
      onHover: null,
      onLeave: null,
      labels: {
        boxWidth: 40,
        padding: 10,
        generateLabels: function generateLabels(t) {
          var e = t.data;
          return ut.isArray(e.datasets) ? e.datasets.map(function (e, i) {
            return {
              text: e.label,
              fillStyle: ut.isArray(e.backgroundColor) ? e.backgroundColor[0] : e.backgroundColor,
              hidden: !t.isDatasetVisible(i),
              lineCap: e.borderCapStyle,
              lineDash: e.borderDash,
              lineDashOffset: e.borderDashOffset,
              lineJoin: e.borderJoinStyle,
              lineWidth: e.borderWidth,
              strokeStyle: e.borderColor,
              pointStyle: e.pointStyle,
              datasetIndex: i
            };
          }, this) : [];
        }
      }
    },
    legendCallback: function legendCallback(t) {
      var e = [];
      e.push('<ul class="' + t.id + '-legend">');

      for (var i = 0; i < t.data.datasets.length; i++) {
        e.push('<li><span style="background-color:' + t.data.datasets[i].backgroundColor + '"></span>'), t.data.datasets[i].label && e.push(t.data.datasets[i].label), e.push("</li>");
      }

      return e.push("</ul>"), e.join("");
    }
  });

  var gn = pt.extend({
    initialize: function initialize(t) {
      ut.extend(this, t), this.legendHitBoxes = [], this._hoveredItem = null, this.doughnutMode = !1;
    },
    beforeUpdate: hn,
    update: function update(t, e, i) {
      var n = this;
      return n.beforeUpdate(), n.maxWidth = t, n.maxHeight = e, n.margins = i, n.beforeSetDimensions(), n.setDimensions(), n.afterSetDimensions(), n.beforeBuildLabels(), n.buildLabels(), n.afterBuildLabels(), n.beforeFit(), n.fit(), n.afterFit(), n.afterUpdate(), n.minSize;
    },
    afterUpdate: hn,
    beforeSetDimensions: hn,
    setDimensions: function setDimensions() {
      var t = this;
      t.isHorizontal() ? (t.width = t.maxWidth, t.left = 0, t.right = t.width) : (t.height = t.maxHeight, t.top = 0, t.bottom = t.height), t.paddingLeft = 0, t.paddingTop = 0, t.paddingRight = 0, t.paddingBottom = 0, t.minSize = {
        width: 0,
        height: 0
      };
    },
    afterSetDimensions: hn,
    beforeBuildLabels: hn,
    buildLabels: function buildLabels() {
      var t = this,
          e = t.options.labels || {},
          i = ut.callback(e.generateLabels, [t.chart], t) || [];
      e.filter && (i = i.filter(function (i) {
        return e.filter(i, t.chart.data);
      })), t.options.reverse && i.reverse(), t.legendItems = i;
    },
    afterBuildLabels: hn,
    beforeFit: hn,
    fit: function fit() {
      var t = this,
          e = t.options,
          i = e.labels,
          n = e.display,
          a = t.ctx,
          o = ut.options._parseFont(i),
          r = o.size,
          s = t.legendHitBoxes = [],
          l = t.minSize,
          d = t.isHorizontal();

      if (d ? (l.width = t.maxWidth, l.height = n ? 10 : 0) : (l.width = n ? 10 : 0, l.height = t.maxHeight), n) if (a.font = o.string, d) {
        var u = t.lineWidths = [0],
            h = 0;
        a.textAlign = "left", a.textBaseline = "top", ut.each(t.legendItems, function (t, e) {
          var n = fn(i, r) + r / 2 + a.measureText(t.text).width;
          (0 === e || u[u.length - 1] + n + i.padding > l.width) && (h += r + i.padding, u[u.length - (e > 0 ? 0 : 1)] = i.padding), s[e] = {
            left: 0,
            top: 0,
            width: n,
            height: r
          }, u[u.length - 1] += n + i.padding;
        }), l.height += h;
      } else {
        var c = i.padding,
            f = t.columnWidths = [],
            g = i.padding,
            p = 0,
            m = 0,
            v = r + c;
        ut.each(t.legendItems, function (t, e) {
          var n = fn(i, r) + r / 2 + a.measureText(t.text).width;
          e > 0 && m + v > l.height - c && (g += p + i.padding, f.push(p), p = 0, m = 0), p = Math.max(p, n), m += v, s[e] = {
            left: 0,
            top: 0,
            width: n,
            height: r
          };
        }), g += p, f.push(p), l.width += g;
      }
      t.width = l.width, t.height = l.height;
    },
    afterFit: hn,
    isHorizontal: function isHorizontal() {
      return "top" === this.options.position || "bottom" === this.options.position;
    },
    draw: function draw() {
      var t = this,
          e = t.options,
          i = e.labels,
          n = st.global,
          a = n.defaultColor,
          o = n.elements.line,
          r = t.width,
          s = t.lineWidths;

      if (e.display) {
        var l,
            d = t.ctx,
            u = cn(i.fontColor, n.defaultFontColor),
            h = ut.options._parseFont(i),
            c = h.size;

        d.textAlign = "left", d.textBaseline = "middle", d.lineWidth = .5, d.strokeStyle = u, d.fillStyle = u, d.font = h.string;
        var f = fn(i, c),
            g = t.legendHitBoxes,
            p = t.isHorizontal();
        l = p ? {
          x: t.left + (r - s[0]) / 2 + i.padding,
          y: t.top + i.padding,
          line: 0
        } : {
          x: t.left + i.padding,
          y: t.top + i.padding,
          line: 0
        };
        var m = c + i.padding;
        ut.each(t.legendItems, function (n, u) {
          var h = d.measureText(n.text).width,
              v = f + c / 2 + h,
              b = l.x,
              x = l.y;
          p ? u > 0 && b + v + i.padding > t.left + t.minSize.width && (x = l.y += m, l.line++, b = l.x = t.left + (r - s[l.line]) / 2 + i.padding) : u > 0 && x + m > t.top + t.minSize.height && (b = l.x = b + t.columnWidths[l.line] + i.padding, x = l.y = t.top + i.padding, l.line++), function (t, i, n) {
            if (!(isNaN(f) || f <= 0)) {
              d.save();
              var r = cn(n.lineWidth, o.borderWidth);

              if (d.fillStyle = cn(n.fillStyle, a), d.lineCap = cn(n.lineCap, o.borderCapStyle), d.lineDashOffset = cn(n.lineDashOffset, o.borderDashOffset), d.lineJoin = cn(n.lineJoin, o.borderJoinStyle), d.lineWidth = r, d.strokeStyle = cn(n.strokeStyle, a), d.setLineDash && d.setLineDash(cn(n.lineDash, o.borderDash)), e.labels && e.labels.usePointStyle) {
                var s = f * Math.SQRT2 / 2,
                    l = t + f / 2,
                    u = i + c / 2;
                ut.canvas.drawPoint(d, n.pointStyle, s, l, u);
              } else 0 !== r && d.strokeRect(t, i, f, c), d.fillRect(t, i, f, c);

              d.restore();
            }
          }(b, x, n), g[u].left = b, g[u].top = x, function (t, e, i, n) {
            var a = c / 2,
                o = f + a + t,
                r = e + a;
            d.fillText(i.text, o, r), i.hidden && (d.beginPath(), d.lineWidth = 2, d.moveTo(o, r), d.lineTo(o + n, r), d.stroke());
          }(b, x, n, h), p ? l.x += v + i.padding : l.y += m;
        });
      }
    },
    _getLegendItemAt: function _getLegendItemAt(t, e) {
      var i,
          n,
          a,
          o = this;
      if (t >= o.left && t <= o.right && e >= o.top && e <= o.bottom) for (a = o.legendHitBoxes, i = 0; i < a.length; ++i) {
        if (t >= (n = a[i]).left && t <= n.left + n.width && e >= n.top && e <= n.top + n.height) return o.legendItems[i];
      }
      return null;
    },
    handleEvent: function handleEvent(t) {
      var e,
          i = this,
          n = i.options,
          a = "mouseup" === t.type ? "click" : t.type;

      if ("mousemove" === a) {
        if (!n.onHover && !n.onLeave) return;
      } else {
        if ("click" !== a) return;
        if (!n.onClick) return;
      }

      e = i._getLegendItemAt(t.x, t.y), "click" === a ? e && n.onClick && n.onClick.call(i, t.native, e) : (n.onLeave && e !== i._hoveredItem && (i._hoveredItem && n.onLeave.call(i, t.native, i._hoveredItem), i._hoveredItem = e), n.onHover && e && n.onHover.call(i, t.native, e));
    }
  });

  function pn(t, e) {
    var i = new gn({
      ctx: t.ctx,
      options: e,
      chart: t
    });
    ke.configure(t, i, e), ke.addBox(t, i), t.legend = i;
  }

  var mn = {
    id: "legend",
    _element: gn,
    beforeInit: function beforeInit(t) {
      var e = t.options.legend;
      e && pn(t, e);
    },
    beforeUpdate: function beforeUpdate(t) {
      var e = t.options.legend,
          i = t.legend;
      e ? (ut.mergeIf(e, st.global.legend), i ? (ke.configure(t, i, e), i.options = e) : pn(t, e)) : i && (ke.removeBox(t, i), delete t.legend);
    },
    afterEvent: function afterEvent(t, e) {
      var i = t.legend;
      i && i.handleEvent(e);
    }
  },
      vn = ut.noop;

  st._set("global", {
    title: {
      display: !1,
      fontStyle: "bold",
      fullWidth: !0,
      padding: 10,
      position: "top",
      text: "",
      weight: 2e3
    }
  });

  var bn = pt.extend({
    initialize: function initialize(t) {
      ut.extend(this, t), this.legendHitBoxes = [];
    },
    beforeUpdate: vn,
    update: function update(t, e, i) {
      var n = this;
      return n.beforeUpdate(), n.maxWidth = t, n.maxHeight = e, n.margins = i, n.beforeSetDimensions(), n.setDimensions(), n.afterSetDimensions(), n.beforeBuildLabels(), n.buildLabels(), n.afterBuildLabels(), n.beforeFit(), n.fit(), n.afterFit(), n.afterUpdate(), n.minSize;
    },
    afterUpdate: vn,
    beforeSetDimensions: vn,
    setDimensions: function setDimensions() {
      var t = this;
      t.isHorizontal() ? (t.width = t.maxWidth, t.left = 0, t.right = t.width) : (t.height = t.maxHeight, t.top = 0, t.bottom = t.height), t.paddingLeft = 0, t.paddingTop = 0, t.paddingRight = 0, t.paddingBottom = 0, t.minSize = {
        width: 0,
        height: 0
      };
    },
    afterSetDimensions: vn,
    beforeBuildLabels: vn,
    buildLabels: vn,
    afterBuildLabels: vn,
    beforeFit: vn,
    fit: function fit() {
      var t = this,
          e = t.options,
          i = e.display,
          n = t.minSize,
          a = ut.isArray(e.text) ? e.text.length : 1,
          o = ut.options._parseFont(e),
          r = i ? a * o.lineHeight + 2 * e.padding : 0;

      t.isHorizontal() ? (n.width = t.maxWidth, n.height = r) : (n.width = r, n.height = t.maxHeight), t.width = n.width, t.height = n.height;
    },
    afterFit: vn,
    isHorizontal: function isHorizontal() {
      var t = this.options.position;
      return "top" === t || "bottom" === t;
    },
    draw: function draw() {
      var t = this,
          e = t.ctx,
          i = t.options;

      if (i.display) {
        var n,
            a,
            o,
            r = ut.options._parseFont(i),
            s = r.lineHeight,
            l = s / 2 + i.padding,
            d = 0,
            u = t.top,
            h = t.left,
            c = t.bottom,
            f = t.right;

        e.fillStyle = ut.valueOrDefault(i.fontColor, st.global.defaultFontColor), e.font = r.string, t.isHorizontal() ? (a = h + (f - h) / 2, o = u + l, n = f - h) : (a = "left" === i.position ? h + l : f - l, o = u + (c - u) / 2, n = c - u, d = Math.PI * ("left" === i.position ? -.5 : .5)), e.save(), e.translate(a, o), e.rotate(d), e.textAlign = "center", e.textBaseline = "middle";
        var g = i.text;
        if (ut.isArray(g)) for (var p = 0, m = 0; m < g.length; ++m) {
          e.fillText(g[m], 0, p, n), p += s;
        } else e.fillText(g, 0, 0, n);
        e.restore();
      }
    }
  });

  function xn(t, e) {
    var i = new bn({
      ctx: t.ctx,
      options: e,
      chart: t
    });
    ke.configure(t, i, e), ke.addBox(t, i), t.titleBlock = i;
  }

  var yn = {},
      kn = un,
      wn = mn,
      Mn = {
    id: "title",
    _element: bn,
    beforeInit: function beforeInit(t) {
      var e = t.options.title;
      e && xn(t, e);
    },
    beforeUpdate: function beforeUpdate(t) {
      var e = t.options.title,
          i = t.titleBlock;
      e ? (ut.mergeIf(e, st.global.title), i ? (ke.configure(t, i, e), i.options = e) : xn(t, e)) : i && (ke.removeBox(t, i), delete t.titleBlock);
    }
  };

  for (var _n in yn.filler = kn, yn.legend = wn, yn.title = Mn, ai.helpers = ut, function () {
    function t(t, e, i) {
      var n;
      return "string" == typeof t ? (n = parseInt(t, 10), -1 !== t.indexOf("%") && (n = n / 100 * e.parentNode[i])) : n = t, n;
    }

    function e(t) {
      return null != t && "none" !== t;
    }

    function i(i, n, a) {
      var o = document.defaultView,
          r = ut._getParentNode(i),
          s = o.getComputedStyle(i)[n],
          l = o.getComputedStyle(r)[n],
          d = e(s),
          u = e(l),
          h = Number.POSITIVE_INFINITY;

      return d || u ? Math.min(d ? t(s, i, a) : h, u ? t(l, r, a) : h) : "none";
    }

    ut.where = function (t, e) {
      if (ut.isArray(t) && Array.prototype.filter) return t.filter(e);
      var i = [];
      return ut.each(t, function (t) {
        e(t) && i.push(t);
      }), i;
    }, ut.findIndex = Array.prototype.findIndex ? function (t, e, i) {
      return t.findIndex(e, i);
    } : function (t, e, i) {
      i = void 0 === i ? t : i;

      for (var n = 0, a = t.length; n < a; ++n) {
        if (e.call(i, t[n], n, t)) return n;
      }

      return -1;
    }, ut.findNextWhere = function (t, e, i) {
      ut.isNullOrUndef(i) && (i = -1);

      for (var n = i + 1; n < t.length; n++) {
        var a = t[n];
        if (e(a)) return a;
      }
    }, ut.findPreviousWhere = function (t, e, i) {
      ut.isNullOrUndef(i) && (i = t.length);

      for (var n = i - 1; n >= 0; n--) {
        var a = t[n];
        if (e(a)) return a;
      }
    }, ut.isNumber = function (t) {
      return !isNaN(parseFloat(t)) && isFinite(t);
    }, ut.almostEquals = function (t, e, i) {
      return Math.abs(t - e) < i;
    }, ut.almostWhole = function (t, e) {
      var i = Math.round(t);
      return i - e < t && i + e > t;
    }, ut.max = function (t) {
      return t.reduce(function (t, e) {
        return isNaN(e) ? t : Math.max(t, e);
      }, Number.NEGATIVE_INFINITY);
    }, ut.min = function (t) {
      return t.reduce(function (t, e) {
        return isNaN(e) ? t : Math.min(t, e);
      }, Number.POSITIVE_INFINITY);
    }, ut.sign = Math.sign ? function (t) {
      return Math.sign(t);
    } : function (t) {
      return 0 == (t = +t) || isNaN(t) ? t : t > 0 ? 1 : -1;
    }, ut.log10 = Math.log10 ? function (t) {
      return Math.log10(t);
    } : function (t) {
      var e = Math.log(t) * Math.LOG10E,
          i = Math.round(e);
      return t === Math.pow(10, i) ? i : e;
    }, ut.toRadians = function (t) {
      return t * (Math.PI / 180);
    }, ut.toDegrees = function (t) {
      return t * (180 / Math.PI);
    }, ut._decimalPlaces = function (t) {
      if (ut.isFinite(t)) {
        for (var e = 1, i = 0; Math.round(t * e) / e !== t;) {
          e *= 10, i++;
        }

        return i;
      }
    }, ut.getAngleFromPoint = function (t, e) {
      var i = e.x - t.x,
          n = e.y - t.y,
          a = Math.sqrt(i * i + n * n),
          o = Math.atan2(n, i);
      return o < -.5 * Math.PI && (o += 2 * Math.PI), {
        angle: o,
        distance: a
      };
    }, ut.distanceBetweenPoints = function (t, e) {
      return Math.sqrt(Math.pow(e.x - t.x, 2) + Math.pow(e.y - t.y, 2));
    }, ut.aliasPixel = function (t) {
      return t % 2 == 0 ? 0 : .5;
    }, ut._alignPixel = function (t, e, i) {
      var n = t.currentDevicePixelRatio,
          a = i / 2;
      return Math.round((e - a) * n) / n + a;
    }, ut.splineCurve = function (t, e, i, n) {
      var a = t.skip ? e : t,
          o = e,
          r = i.skip ? e : i,
          s = Math.sqrt(Math.pow(o.x - a.x, 2) + Math.pow(o.y - a.y, 2)),
          l = Math.sqrt(Math.pow(r.x - o.x, 2) + Math.pow(r.y - o.y, 2)),
          d = s / (s + l),
          u = l / (s + l),
          h = n * (d = isNaN(d) ? 0 : d),
          c = n * (u = isNaN(u) ? 0 : u);
      return {
        previous: {
          x: o.x - h * (r.x - a.x),
          y: o.y - h * (r.y - a.y)
        },
        next: {
          x: o.x + c * (r.x - a.x),
          y: o.y + c * (r.y - a.y)
        }
      };
    }, ut.EPSILON = Number.EPSILON || 1e-14, ut.splineCurveMonotone = function (t) {
      var e,
          i,
          n,
          a,
          o,
          r,
          s,
          l,
          d,
          u = (t || []).map(function (t) {
        return {
          model: t._model,
          deltaK: 0,
          mK: 0
        };
      }),
          h = u.length;

      for (e = 0; e < h; ++e) {
        if (!(n = u[e]).model.skip) {
          if (i = e > 0 ? u[e - 1] : null, (a = e < h - 1 ? u[e + 1] : null) && !a.model.skip) {
            var c = a.model.x - n.model.x;
            n.deltaK = 0 !== c ? (a.model.y - n.model.y) / c : 0;
          }

          !i || i.model.skip ? n.mK = n.deltaK : !a || a.model.skip ? n.mK = i.deltaK : this.sign(i.deltaK) !== this.sign(n.deltaK) ? n.mK = 0 : n.mK = (i.deltaK + n.deltaK) / 2;
        }
      }

      for (e = 0; e < h - 1; ++e) {
        n = u[e], a = u[e + 1], n.model.skip || a.model.skip || (ut.almostEquals(n.deltaK, 0, this.EPSILON) ? n.mK = a.mK = 0 : (o = n.mK / n.deltaK, r = a.mK / n.deltaK, (l = Math.pow(o, 2) + Math.pow(r, 2)) <= 9 || (s = 3 / Math.sqrt(l), n.mK = o * s * n.deltaK, a.mK = r * s * n.deltaK)));
      }

      for (e = 0; e < h; ++e) {
        (n = u[e]).model.skip || (i = e > 0 ? u[e - 1] : null, a = e < h - 1 ? u[e + 1] : null, i && !i.model.skip && (d = (n.model.x - i.model.x) / 3, n.model.controlPointPreviousX = n.model.x - d, n.model.controlPointPreviousY = n.model.y - d * n.mK), a && !a.model.skip && (d = (a.model.x - n.model.x) / 3, n.model.controlPointNextX = n.model.x + d, n.model.controlPointNextY = n.model.y + d * n.mK));
      }
    }, ut.nextItem = function (t, e, i) {
      return i ? e >= t.length - 1 ? t[0] : t[e + 1] : e >= t.length - 1 ? t[t.length - 1] : t[e + 1];
    }, ut.previousItem = function (t, e, i) {
      return i ? e <= 0 ? t[t.length - 1] : t[e - 1] : e <= 0 ? t[0] : t[e - 1];
    }, ut.niceNum = function (t, e) {
      var i = Math.floor(ut.log10(t)),
          n = t / Math.pow(10, i);
      return (e ? n < 1.5 ? 1 : n < 3 ? 2 : n < 7 ? 5 : 10 : n <= 1 ? 1 : n <= 2 ? 2 : n <= 5 ? 5 : 10) * Math.pow(10, i);
    }, ut.requestAnimFrame = "undefined" == typeof window ? function (t) {
      t();
    } : window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (t) {
      return window.setTimeout(t, 1e3 / 60);
    }, ut.getRelativePosition = function (t, e) {
      var i,
          n,
          a = t.originalEvent || t,
          o = t.target || t.srcElement,
          r = o.getBoundingClientRect(),
          s = a.touches;
      s && s.length > 0 ? (i = s[0].clientX, n = s[0].clientY) : (i = a.clientX, n = a.clientY);
      var l = parseFloat(ut.getStyle(o, "padding-left")),
          d = parseFloat(ut.getStyle(o, "padding-top")),
          u = parseFloat(ut.getStyle(o, "padding-right")),
          h = parseFloat(ut.getStyle(o, "padding-bottom")),
          c = r.right - r.left - l - u,
          f = r.bottom - r.top - d - h;
      return {
        x: i = Math.round((i - r.left - l) / c * o.width / e.currentDevicePixelRatio),
        y: n = Math.round((n - r.top - d) / f * o.height / e.currentDevicePixelRatio)
      };
    }, ut.getConstraintWidth = function (t) {
      return i(t, "max-width", "clientWidth");
    }, ut.getConstraintHeight = function (t) {
      return i(t, "max-height", "clientHeight");
    }, ut._calculatePadding = function (t, e, i) {
      return (e = ut.getStyle(t, e)).indexOf("%") > -1 ? i * parseInt(e, 10) / 100 : parseInt(e, 10);
    }, ut._getParentNode = function (t) {
      var e = t.parentNode;
      return e && "[object ShadowRoot]" === e.toString() && (e = e.host), e;
    }, ut.getMaximumWidth = function (t) {
      var e = ut._getParentNode(t);

      if (!e) return t.clientWidth;

      var i = e.clientWidth,
          n = i - ut._calculatePadding(e, "padding-left", i) - ut._calculatePadding(e, "padding-right", i),
          a = ut.getConstraintWidth(t);

      return isNaN(a) ? n : Math.min(n, a);
    }, ut.getMaximumHeight = function (t) {
      var e = ut._getParentNode(t);

      if (!e) return t.clientHeight;

      var i = e.clientHeight,
          n = i - ut._calculatePadding(e, "padding-top", i) - ut._calculatePadding(e, "padding-bottom", i),
          a = ut.getConstraintHeight(t);

      return isNaN(a) ? n : Math.min(n, a);
    }, ut.getStyle = function (t, e) {
      return t.currentStyle ? t.currentStyle[e] : document.defaultView.getComputedStyle(t, null).getPropertyValue(e);
    }, ut.retinaScale = function (t, e) {
      var i = t.currentDevicePixelRatio = e || "undefined" != typeof window && window.devicePixelRatio || 1;

      if (1 !== i) {
        var n = t.canvas,
            a = t.height,
            o = t.width;
        n.height = a * i, n.width = o * i, t.ctx.scale(i, i), n.style.height || n.style.width || (n.style.height = a + "px", n.style.width = o + "px");
      }
    }, ut.fontString = function (t, e, i) {
      return e + " " + t + "px " + i;
    }, ut.longestText = function (t, e, i, n) {
      var a = (n = n || {}).data = n.data || {},
          o = n.garbageCollect = n.garbageCollect || [];
      n.font !== e && (a = n.data = {}, o = n.garbageCollect = [], n.font = e), t.font = e;
      var r = 0;
      ut.each(i, function (e) {
        null != e && !0 !== ut.isArray(e) ? r = ut.measureText(t, a, o, r, e) : ut.isArray(e) && ut.each(e, function (e) {
          null == e || ut.isArray(e) || (r = ut.measureText(t, a, o, r, e));
        });
      });
      var s = o.length / 2;

      if (s > i.length) {
        for (var l = 0; l < s; l++) {
          delete a[o[l]];
        }

        o.splice(0, s);
      }

      return r;
    }, ut.measureText = function (t, e, i, n, a) {
      var o = e[a];
      return o || (o = e[a] = t.measureText(a).width, i.push(a)), o > n && (n = o), n;
    }, ut.numberOfLabelLines = function (t) {
      var e = 1;
      return ut.each(t, function (t) {
        ut.isArray(t) && t.length > e && (e = t.length);
      }), e;
    }, ut.color = X ? function (t) {
      return t instanceof CanvasGradient && (t = st.global.defaultColor), X(t);
    } : function (t) {
      return console.error("Color.js not found!"), t;
    }, ut.getHoverColor = function (t) {
      return t instanceof CanvasPattern || t instanceof CanvasGradient ? t : ut.color(t).saturate(.5).darken(.1).rgbString();
    };
  }(), ai._adapters = si, ai.Animation = vt, ai.animationService = bt, ai.controllers = ue, ai.DatasetController = Mt, ai.defaults = st, ai.Element = pt, ai.elements = Wt, ai.Interaction = ve, ai.layouts = ke, ai.platform = Ve, ai.plugins = Ee, ai.Scale = fi, ai.scaleService = He, ai.Ticks = li, ai.Tooltip = Je, ai.helpers.each(tn, function (t, e) {
    ai.scaleService.registerScaleType(e, t, t._defaults);
  }), yn) {
    yn.hasOwnProperty(_n) && ai.plugins.register(yn[_n]);
  }

  ai.platform.initialize();
  var Cn = ai;
  return "undefined" != typeof window && (window.Chart = ai), ai.Chart = ai, ai.Legend = yn.legend._element, ai.Title = yn.title._element, ai.pluginService = ai.plugins, ai.PluginBase = ai.Element.extend({}), ai.canvasHelpers = ai.helpers.canvas, ai.layoutService = ai.layouts, ai.LinearScaleBase = bi, ai.helpers.each(["Bar", "Bubble", "Doughnut", "Line", "PolarArea", "Radar", "Scatter"], function (t) {
    ai[t] = function (e, i) {
      return new ai(e, ai.helpers.merge(i || {}, {
        type: t.charAt(0).toLowerCase() + t.slice(1)
      }));
    };
  }), Cn;
});
},{"moment":"node_modules/moment/moment.js"}],"node_modules/parcel-bundler/src/builtins/hmr-runtime.js":[function(require,module,exports) {
var global = arguments[3];
var OVERLAY_ID = '__parcel__error__overlay__';
var OldModule = module.bundle.Module;

function Module(moduleName) {
  OldModule.call(this, moduleName);
  this.hot = {
    data: module.bundle.hotData,
    _acceptCallbacks: [],
    _disposeCallbacks: [],
    accept: function (fn) {
      this._acceptCallbacks.push(fn || function () {});
    },
    dispose: function (fn) {
      this._disposeCallbacks.push(fn);
    }
  };
  module.bundle.hotData = null;
}

module.bundle.Module = Module;
var checkedAssets, assetsToAccept;
var parent = module.bundle.parent;

if ((!parent || !parent.isParcelRequire) && typeof WebSocket !== 'undefined') {
  var hostname = "" || location.hostname;
  var protocol = location.protocol === 'https:' ? 'wss' : 'ws';
  var ws = new WebSocket(protocol + '://' + hostname + ':' + "53056" + '/');

  ws.onmessage = function (event) {
    checkedAssets = {};
    assetsToAccept = [];
    var data = JSON.parse(event.data);

    if (data.type === 'update') {
      var handled = false;
      data.assets.forEach(function (asset) {
        if (!asset.isNew) {
          var didAccept = hmrAcceptCheck(global.parcelRequire, asset.id);

          if (didAccept) {
            handled = true;
          }
        }
      }); // Enable HMR for CSS by default.

      handled = handled || data.assets.every(function (asset) {
        return asset.type === 'css' && asset.generated.js;
      });

      if (handled) {
        console.clear();
        data.assets.forEach(function (asset) {
          hmrApply(global.parcelRequire, asset);
        });
        assetsToAccept.forEach(function (v) {
          hmrAcceptRun(v[0], v[1]);
        });
      } else if (location.reload) {
        // `location` global exists in a web worker context but lacks `.reload()` function.
        location.reload();
      }
    }

    if (data.type === 'reload') {
      ws.close();

      ws.onclose = function () {
        location.reload();
      };
    }

    if (data.type === 'error-resolved') {
      console.log('[parcel] ✨ Error resolved');
      removeErrorOverlay();
    }

    if (data.type === 'error') {
      console.error('[parcel] 🚨  ' + data.error.message + '\n' + data.error.stack);
      removeErrorOverlay();
      var overlay = createErrorOverlay(data);
      document.body.appendChild(overlay);
    }
  };
}

function removeErrorOverlay() {
  var overlay = document.getElementById(OVERLAY_ID);

  if (overlay) {
    overlay.remove();
  }
}

function createErrorOverlay(data) {
  var overlay = document.createElement('div');
  overlay.id = OVERLAY_ID; // html encode message and stack trace

  var message = document.createElement('div');
  var stackTrace = document.createElement('pre');
  message.innerText = data.error.message;
  stackTrace.innerText = data.error.stack;
  overlay.innerHTML = '<div style="background: black; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; opacity: 0.85; font-family: Menlo, Consolas, monospace; z-index: 9999;">' + '<span style="background: red; padding: 2px 4px; border-radius: 2px;">ERROR</span>' + '<span style="top: 2px; margin-left: 5px; position: relative;">🚨</span>' + '<div style="font-size: 18px; font-weight: bold; margin-top: 20px;">' + message.innerHTML + '</div>' + '<pre>' + stackTrace.innerHTML + '</pre>' + '</div>';
  return overlay;
}

function getParents(bundle, id) {
  var modules = bundle.modules;

  if (!modules) {
    return [];
  }

  var parents = [];
  var k, d, dep;

  for (k in modules) {
    for (d in modules[k][1]) {
      dep = modules[k][1][d];

      if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) {
        parents.push(k);
      }
    }
  }

  if (bundle.parent) {
    parents = parents.concat(getParents(bundle.parent, id));
  }

  return parents;
}

function hmrApply(bundle, asset) {
  var modules = bundle.modules;

  if (!modules) {
    return;
  }

  if (modules[asset.id] || !bundle.parent) {
    var fn = new Function('require', 'module', 'exports', asset.generated.js);
    asset.isNew = !modules[asset.id];
    modules[asset.id] = [fn, asset.deps];
  } else if (bundle.parent) {
    hmrApply(bundle.parent, asset);
  }
}

function hmrAcceptCheck(bundle, id) {
  var modules = bundle.modules;

  if (!modules) {
    return;
  }

  if (!modules[id] && bundle.parent) {
    return hmrAcceptCheck(bundle.parent, id);
  }

  if (checkedAssets[id]) {
    return;
  }

  checkedAssets[id] = true;
  var cached = bundle.cache[id];
  assetsToAccept.push([bundle, id]);

  if (cached && cached.hot && cached.hot._acceptCallbacks.length) {
    return true;
  }

  return getParents(global.parcelRequire, id).some(function (id) {
    return hmrAcceptCheck(global.parcelRequire, id);
  });
}

function hmrAcceptRun(bundle, id) {
  var cached = bundle.cache[id];
  bundle.hotData = {};

  if (cached) {
    cached.hot.data = bundle.hotData;
  }

  if (cached && cached.hot && cached.hot._disposeCallbacks.length) {
    cached.hot._disposeCallbacks.forEach(function (cb) {
      cb(bundle.hotData);
    });
  }

  delete bundle.cache[id];
  bundle(id);
  cached = bundle.cache[id];

  if (cached && cached.hot && cached.hot._acceptCallbacks.length) {
    cached.hot._acceptCallbacks.forEach(function (cb) {
      cb();
    });

    return true;
  }
}
},{}]},{},["node_modules/parcel-bundler/src/builtins/hmr-runtime.js","vendor/chart.js/Chart.min.js"], null)
//# sourceMappingURL=/Chart.min.976080ca.js.map